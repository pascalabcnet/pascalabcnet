// This code was generated by the Gardens Point Parser Generator
// Copyright (c) Wayne Kelly, QUT 2005-2010
// (see accompanying GPPGcopyright.rtf)

// GPPG version 1.3.6
// Machine:  SSM
// DateTime: 13.03.2013 16:51:39
// UserName: ?????????
// Input file <oberon00.y>

// options: no-lines gplex

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using QUT.Gppg;
using PascalABCCompiler.SyntaxTree;
using PascalABCCompiler.Errors;
using PascalABCCompiler.Oberon00Parser;

namespace GPPGParserScanner
{
public enum Tokens {
    error=1,EOF=2,ID=3,STRING_CONST=4,INTNUM=5,REALNUM=6,
    LONGINTNUM=7,TRUE=8,FALSE=9,CHAR_CONST=10,PLUS=11,MINUS=12,
    MULT=13,DIVIDE=14,AND=15,OR=16,LT=17,GT=18,
    LE=19,GE=20,EQ=21,NE=22,DIV=23,MOD=24,
    NOT=25,ASSIGN=26,SEMICOLUMN=27,LPAREN=28,RPAREN=29,COLUMN=30,
    COMMA=31,COLON=32,EXCLAMATION=33,LBRACE=34,RBRACE=35,DOUBLEPOINT=36,
    LBRACKET=37,RBRACKET=38,PIPE=39,IF=40,THEN=41,ELSE=42,
    ELSEIF=43,BEGIN=44,END=45,WHILE=46,DO=47,MODULE=48,
    CONST=49,VAR=50,TYPE=51,INVISIBLE=52,PROCEDURE=53,ARRAY=54,
    OF=55,RECORD=56,REPEAT=57,UNTIL=58,FOR=59,TO=60,
    BY=61,CASE=62,POINTER=63,ODD=64,UMINUS=65,UPLUS=66};

public struct ValueType
{ 
		public bool bVal;  
		public string sVal; 
		public int iVal; 
		public long lVal;								// Длинное целое
		public char cVal;
		public double rVal;
		public pascal_set_constant sc;					// Константа - множество
		public named_type_reference ntr;				// Именованное определение типа
		public type_definition tdef;					// Сам тип		
		public diapason dpsn;							// Тип диапазон
		public array_type arrt;							// Тип массив
		public class_definition cldef;					// Определение записи
		public indexers_types indts;					// Тип типы индексов массива
		public ref_type rft;							// Тип указатель
		public ident_list il;							// Список идентификаторов
		public ident id;								// Идентификатор
		public oberon_ident_with_export_marker obrid;	// Обероновский уточненный идентификатор
		public oberon_export_marker obrem;				// Обероновская экспортная метка
		public var_def_statement vds;					// Описание переменных
		public variable_definitions vdss;				// Секция описания переменных
		public type_declarations td;					// Секция определения типов
		public type_declaration tdec;					// Описание типа
		public expression ex;							// Выражение
		public expression_list el;						// Список выражений
		public Operators ops;							// Операторы (операции)
		public block bl;								// Программный блок
		public statement st;							// Оператор программный
		public statement_list sl;						// Список операторов
		public case_variants cvars;						// Список вариантов оператора CASE
		public case_variant cvar;							// Вариант оператора CASE
		public declaration decsec;						// Описание
		public declarations decl;						// Список описаний
		public simple_const_definition scd;				// Определение константы
		public consts_definitions_list cdl;				// Список описаний констант		
		public procedure_definition pd;					// Описание процедуры
		public dot_node dn;								// Узел в точечной нотации
		public addressed_value adrv;					// Адресованное значение		
	}
// Abstract base class for GPLEX scanners
public abstract class ScanBase : AbstractScanner<ValueType,LexLocation> {
  private LexLocation __yylloc = new LexLocation();
  public override LexLocation yylloc { get { return __yylloc; } set { __yylloc = value; } }
  protected virtual bool yywrap() { return true; }
}

public class GPPGParser: ShiftReduceParser<ValueType, LexLocation>
{
  // Verbatim content from oberon00.y
// Эти объявления добавляются в класс GPPGParser, представляющий собой парсер, генерируемый системой gppg
    public syntax_tree_node root; // Корневой узел синтаксического дерева 
    public GPPGParser(AbstractScanner<ValueType, LexLocation> scanner) : base(scanner) { }
  // End verbatim content from oberon00.y

#pragma warning disable 649
  private static Dictionary<int, string> aliasses;
#pragma warning restore 649
  private static Rule[] rules = new Rule[147];
  private static State[] states = new State[253];
  private static string[] nonTerms = new string[] {
      "module", "ident", "specifiedIdent", "identDef", "ExportLabel", "IDList", 
      "complexTypeIdent", "SetConstant", "SetElemList", "expr", "ConstExpr", 
      "SetElem", "SimpleExpr", "ForStep", "CaseVariantLabels", "term", "signedTerm", 
      "factor", "AddList", "FactorList", "Assignment", "IfStatement", "ElseIfStatements", 
      "ElseStatements", "WhileStatement", "WriteStatement", "RepeatStatement", 
      "Statement", "ForStatement", "CaseStatement", "ElseBranch", "EmptyStatement", 
      "ProcCallStatement", "StatementSequence", "CaseVariantList", "CaseVariant", 
      "Declarations", "DeclarationsSect", "VarDecl", "VarDeclarations", "VarDeclarationsSect", 
      "ConstDecl", "ConstDeclarations", "ConstDeclarationsSect", "TypeDeclarationsSect", 
      "TypeDeclarations", "TypeDecl", "TypeDef", "ArrayType", "PointerType", 
      "RecordType", "ProcedureDeclarationSect", "mainblock", "factparams", "ExprList", 
      "CaseVariantLabelList", "Length", "LengthList", "AddOperator", "MultOperator", 
      "Relation", "ComplexDesignator", "Designator", "maybevar", "$accept", "maybeformalparams", 
      "maybereturn", "FPList", "FPSect", };

  static GPPGParser() {
    states[0] = new State(new int[]{48,3,52,251},new int[]{-1,1});
    states[1] = new State(new int[]{2,2});
    states[2] = new State(-1);
    states[3] = new State(new int[]{3,9},new int[]{-2,4});
    states[4] = new State(new int[]{27,5});
    states[5] = new State(-135,new int[]{-53,6,-37,10});
    states[6] = new State(new int[]{3,9},new int[]{-2,7});
    states[7] = new State(new int[]{31,8});
    states[8] = new State(-2);
    states[9] = new State(-4);
    states[10] = new State(new int[]{44,11,50,173,49,212,51,221,53,230},new int[]{-38,171,-41,172,-44,211,-45,220,-52,229});
    states[11] = new State(new int[]{3,9,40,103,46,115,57,121,59,126,62,137,33,149,45,-102,27,-102},new int[]{-34,12,-28,113,-21,16,-63,17,-3,34,-2,95,-62,46,-22,102,-25,114,-27,120,-29,125,-30,136,-26,148,-33,151,-32,152});
    states[12] = new State(new int[]{45,13,27,14});
    states[13] = new State(-11);
    states[14] = new State(new int[]{3,9,40,103,46,115,57,121,59,126,62,137,33,149,45,-102,27,-102,42,-102,43,-102,58,-102,39,-102},new int[]{-28,15,-21,16,-63,17,-3,34,-2,95,-62,46,-22,102,-25,114,-27,120,-29,125,-30,136,-26,148,-33,151,-32,152});
    states[15] = new State(-74);
    states[16] = new State(-64);
    states[17] = new State(new int[]{26,18});
    states[18] = new State(new int[]{3,9,5,53,7,54,6,55,8,56,9,57,10,58,4,59,28,60,25,63,34,66,12,74,11,76},new int[]{-10,19,-13,20,-17,23,-16,42,-18,28,-63,33,-3,34,-2,43,-62,46,-8,65});
    states[19] = new State(-75);
    states[20] = new State(new int[]{21,89,22,90,17,91,19,92,18,93,20,94,45,-18,27,-18,42,-18,43,-18,58,-18,39,-18,38,-18,30,-18,29,-18,36,-18,35,-18,41,-18,47,-18,60,-18,61,-18,55,-18,32,-18,2,-18},new int[]{-61,21});
    states[21] = new State(new int[]{3,9,5,53,7,54,6,55,8,56,9,57,10,58,4,59,28,60,25,63,34,66,12,74,11,76},new int[]{-13,22,-17,23,-16,42,-18,28,-63,33,-3,34,-2,43,-62,46,-8,65});
    states[22] = new State(-19);
    states[23] = new State(new int[]{12,85,11,86,16,87,21,-26,22,-26,17,-26,19,-26,18,-26,20,-26,45,-26,27,-26,42,-26,43,-26,58,-26,39,-26,38,-26,30,-26,29,-26,36,-26,35,-26,41,-26,47,-26,60,-26,61,-26,55,-26,32,-26,2,-26},new int[]{-59,24});
    states[24] = new State(new int[]{3,9,5,53,7,54,6,55,8,56,9,57,10,58,4,59,28,60,25,63,34,66},new int[]{-19,25,-16,88,-18,28,-63,33,-3,34,-2,43,-62,46,-8,65});
    states[25] = new State(new int[]{12,85,11,86,16,87,21,-27,22,-27,17,-27,19,-27,18,-27,20,-27,45,-27,27,-27,42,-27,43,-27,58,-27,39,-27,38,-27,30,-27,29,-27,36,-27,35,-27,41,-27,47,-27,60,-27,61,-27,55,-27,32,-27,2,-27},new int[]{-59,26});
    states[26] = new State(new int[]{3,9,5,53,7,54,6,55,8,56,9,57,10,58,4,59,28,60,25,63,34,66},new int[]{-16,27,-18,28,-63,33,-3,34,-2,43,-62,46,-8,65});
    states[27] = new State(-32);
    states[28] = new State(new int[]{13,79,14,80,23,81,24,82,15,83,12,-33,11,-33,16,-33,21,-33,22,-33,17,-33,19,-33,18,-33,20,-33,45,-33,27,-33,42,-33,43,-33,58,-33,39,-33,38,-33,30,-33,29,-33,36,-33,35,-33,41,-33,47,-33,60,-33,61,-33,55,-33,32,-33,2,-33},new int[]{-60,29});
    states[29] = new State(new int[]{3,9,5,53,7,54,6,55,8,56,9,57,10,58,4,59,28,60,25,63,34,66},new int[]{-20,30,-18,84,-63,33,-3,34,-2,43,-62,46,-8,65});
    states[30] = new State(new int[]{13,79,14,80,23,81,24,82,15,83,12,-34,11,-34,16,-34,21,-34,22,-34,17,-34,19,-34,18,-34,20,-34,45,-34,27,-34,42,-34,43,-34,58,-34,39,-34,38,-34,30,-34,29,-34,36,-34,35,-34,41,-34,47,-34,60,-34,61,-34,55,-34,32,-34,2,-34},new int[]{-60,31});
    states[31] = new State(new int[]{3,9,5,53,7,54,6,55,8,56,9,57,10,58,4,59,28,60,25,63,34,66},new int[]{-18,32,-63,33,-3,34,-2,43,-62,46,-8,65});
    states[32] = new State(-36);
    states[33] = new State(-37);
    states[34] = new State(new int[]{31,35,37,37,26,-48,13,-48,14,-48,23,-48,24,-48,15,-48,12,-48,11,-48,16,-48,21,-48,22,-48,17,-48,19,-48,18,-48,20,-48,45,-48,27,-48,42,-48,43,-48,58,-48,39,-48,38,-48,30,-48,29,-48,36,-48,35,-48,41,-48,47,-48,60,-48,61,-48,55,-48,32,-48,2,-48});
    states[35] = new State(new int[]{3,9},new int[]{-2,36});
    states[36] = new State(-50);
    states[37] = new State(new int[]{3,9,5,53,7,54,6,55,8,56,9,57,10,58,4,59,28,60,25,63,34,66,12,74,11,76},new int[]{-55,38,-10,52,-13,20,-17,23,-16,42,-18,28,-63,33,-3,34,-2,43,-62,46,-8,65});
    states[38] = new State(new int[]{38,39,30,40});
    states[39] = new State(-51);
    states[40] = new State(new int[]{3,9,5,53,7,54,6,55,8,56,9,57,10,58,4,59,28,60,25,63,34,66,12,74,11,76},new int[]{-10,41,-13,20,-17,23,-16,42,-18,28,-63,33,-3,34,-2,43,-62,46,-8,65});
    states[41] = new State(-55);
    states[42] = new State(-28);
    states[43] = new State(new int[]{31,44,37,-6,13,-6,14,-6,23,-6,24,-6,15,-6,12,-6,11,-6,16,-6,21,-6,22,-6,17,-6,19,-6,18,-6,20,-6,45,-6,27,-6,42,-6,43,-6,58,-6,39,-6,38,-6,30,-6,29,-6,36,-6,35,-6,41,-6,47,-6,60,-6,61,-6,55,-6,32,-6,2,-6});
    states[44] = new State(new int[]{3,9},new int[]{-2,45});
    states[45] = new State(-5);
    states[46] = new State(new int[]{31,47,37,49,26,-49,13,-49,14,-49,23,-49,24,-49,15,-49,12,-49,11,-49,16,-49,21,-49,22,-49,17,-49,19,-49,18,-49,20,-49,45,-49,27,-49,42,-49,43,-49,58,-49,39,-49,38,-49,30,-49,29,-49,36,-49,35,-49,41,-49,47,-49,60,-49,61,-49,55,-49,32,-49,2,-49});
    states[47] = new State(new int[]{3,9},new int[]{-2,48});
    states[48] = new State(-52);
    states[49] = new State(new int[]{3,9,5,53,7,54,6,55,8,56,9,57,10,58,4,59,28,60,25,63,34,66,12,74,11,76},new int[]{-55,50,-10,52,-13,20,-17,23,-16,42,-18,28,-63,33,-3,34,-2,43,-62,46,-8,65});
    states[50] = new State(new int[]{38,51,30,40});
    states[51] = new State(-53);
    states[52] = new State(-54);
    states[53] = new State(-38);
    states[54] = new State(-39);
    states[55] = new State(-40);
    states[56] = new State(-41);
    states[57] = new State(-42);
    states[58] = new State(-43);
    states[59] = new State(-44);
    states[60] = new State(new int[]{3,9,5,53,7,54,6,55,8,56,9,57,10,58,4,59,28,60,25,63,34,66,12,74,11,76},new int[]{-10,61,-13,20,-17,23,-16,42,-18,28,-63,33,-3,34,-2,43,-62,46,-8,65});
    states[61] = new State(new int[]{29,62});
    states[62] = new State(-45);
    states[63] = new State(new int[]{3,9,5,53,7,54,6,55,8,56,9,57,10,58,4,59,28,60,25,63,34,66},new int[]{-18,64,-63,33,-3,34,-2,43,-62,46,-8,65});
    states[64] = new State(-46);
    states[65] = new State(-47);
    states[66] = new State(new int[]{3,9,5,53,7,54,6,55,8,56,9,57,10,58,4,59,28,60,25,63,34,66,12,74,11,76,35,-15,30,-15},new int[]{-9,67,-12,78,-10,71,-13,20,-17,23,-16,42,-18,28,-63,33,-3,34,-2,43,-62,46,-8,65});
    states[67] = new State(new int[]{35,68,30,69});
    states[68] = new State(-12);
    states[69] = new State(new int[]{3,9,5,53,7,54,6,55,8,56,9,57,10,58,4,59,28,60,25,63,34,66,12,74,11,76},new int[]{-12,70,-10,71,-13,20,-17,23,-16,42,-18,28,-63,33,-3,34,-2,43,-62,46,-8,65});
    states[70] = new State(-14);
    states[71] = new State(new int[]{36,72,35,-16,30,-16});
    states[72] = new State(new int[]{3,9,5,53,7,54,6,55,8,56,9,57,10,58,4,59,28,60,25,63,34,66,12,74,11,76},new int[]{-10,73,-13,20,-17,23,-16,42,-18,28,-63,33,-3,34,-2,43,-62,46,-8,65});
    states[73] = new State(-17);
    states[74] = new State(new int[]{3,9,5,53,7,54,6,55,8,56,9,57,10,58,4,59,28,60,25,63,34,66},new int[]{-16,75,-18,28,-63,33,-3,34,-2,43,-62,46,-8,65});
    states[75] = new State(-29);
    states[76] = new State(new int[]{3,9,5,53,7,54,6,55,8,56,9,57,10,58,4,59,28,60,25,63,34,66},new int[]{-16,77,-18,28,-63,33,-3,34,-2,43,-62,46,-8,65});
    states[77] = new State(-30);
    states[78] = new State(-13);
    states[79] = new State(-59);
    states[80] = new State(-60);
    states[81] = new State(-61);
    states[82] = new State(-62);
    states[83] = new State(-63);
    states[84] = new State(-35);
    states[85] = new State(-56);
    states[86] = new State(-57);
    states[87] = new State(-58);
    states[88] = new State(-31);
    states[89] = new State(-20);
    states[90] = new State(-21);
    states[91] = new State(-22);
    states[92] = new State(-23);
    states[93] = new State(-24);
    states[94] = new State(-25);
    states[95] = new State(new int[]{31,44,28,96,37,-6,26,-6});
    states[96] = new State(new int[]{3,9,5,53,7,54,6,55,8,56,9,57,10,58,4,59,28,60,25,63,34,66,12,74,11,76},new int[]{-54,97,-10,101,-13,20,-17,23,-16,42,-18,28,-63,33,-3,34,-2,43,-62,46,-8,65});
    states[97] = new State(new int[]{29,98,30,99});
    states[98] = new State(-101);
    states[99] = new State(new int[]{3,9,5,53,7,54,6,55,8,56,9,57,10,58,4,59,28,60,25,63,34,66,12,74,11,76},new int[]{-10,100,-13,20,-17,23,-16,42,-18,28,-63,33,-3,34,-2,43,-62,46,-8,65});
    states[100] = new State(-100);
    states[101] = new State(-99);
    states[102] = new State(-65);
    states[103] = new State(new int[]{3,9,5,53,7,54,6,55,8,56,9,57,10,58,4,59,28,60,25,63,34,66,12,74,11,76},new int[]{-10,104,-13,20,-17,23,-16,42,-18,28,-63,33,-3,34,-2,43,-62,46,-8,65});
    states[104] = new State(new int[]{41,105});
    states[105] = new State(new int[]{3,9,40,103,46,115,57,121,59,126,62,137,33,149,27,-102,42,-102,43,-102,45,-102},new int[]{-34,106,-28,113,-21,16,-63,17,-3,34,-2,95,-62,46,-22,102,-25,114,-27,120,-29,125,-30,136,-26,148,-33,151,-32,152});
    states[106] = new State(new int[]{27,14,42,111,43,165,45,-79},new int[]{-24,107,-23,109});
    states[107] = new State(new int[]{45,108});
    states[108] = new State(-76);
    states[109] = new State(new int[]{45,110});
    states[110] = new State(-77);
    states[111] = new State(new int[]{3,9,40,103,46,115,57,121,59,126,62,137,33,149,27,-102,45,-102},new int[]{-34,112,-28,113,-21,16,-63,17,-3,34,-2,95,-62,46,-22,102,-25,114,-27,120,-29,125,-30,136,-26,148,-33,151,-32,152});
    states[112] = new State(new int[]{27,14,45,-78});
    states[113] = new State(-73);
    states[114] = new State(-66);
    states[115] = new State(new int[]{3,9,5,53,7,54,6,55,8,56,9,57,10,58,4,59,28,60,25,63,34,66,12,74,11,76},new int[]{-10,116,-13,20,-17,23,-16,42,-18,28,-63,33,-3,34,-2,43,-62,46,-8,65});
    states[116] = new State(new int[]{47,117});
    states[117] = new State(new int[]{3,9,40,103,46,115,57,121,59,126,62,137,33,149,45,-102,27,-102},new int[]{-34,118,-28,113,-21,16,-63,17,-3,34,-2,95,-62,46,-22,102,-25,114,-27,120,-29,125,-30,136,-26,148,-33,151,-32,152});
    states[118] = new State(new int[]{45,119,27,14});
    states[119] = new State(-82);
    states[120] = new State(-67);
    states[121] = new State(new int[]{3,9,40,103,46,115,57,121,59,126,62,137,33,149,58,-102,27,-102},new int[]{-34,122,-28,113,-21,16,-63,17,-3,34,-2,95,-62,46,-22,102,-25,114,-27,120,-29,125,-30,136,-26,148,-33,151,-32,152});
    states[122] = new State(new int[]{58,123,27,14});
    states[123] = new State(new int[]{3,9,5,53,7,54,6,55,8,56,9,57,10,58,4,59,28,60,25,63,34,66,12,74,11,76},new int[]{-10,124,-13,20,-17,23,-16,42,-18,28,-63,33,-3,34,-2,43,-62,46,-8,65});
    states[124] = new State(-83);
    states[125] = new State(-68);
    states[126] = new State(new int[]{3,9},new int[]{-2,127});
    states[127] = new State(new int[]{26,128});
    states[128] = new State(new int[]{3,9,5,53,7,54,6,55,8,56,9,57,10,58,4,59,28,60,25,63,34,66,12,74,11,76},new int[]{-10,129,-13,20,-17,23,-16,42,-18,28,-63,33,-3,34,-2,43,-62,46,-8,65});
    states[129] = new State(new int[]{60,130});
    states[130] = new State(new int[]{3,9,5,53,7,54,6,55,8,56,9,57,10,58,4,59,28,60,25,63,34,66,12,74,11,76},new int[]{-10,131,-13,20,-17,23,-16,42,-18,28,-63,33,-3,34,-2,43,-62,46,-8,65});
    states[131] = new State(new int[]{61,163,47,-86},new int[]{-14,132});
    states[132] = new State(new int[]{47,133});
    states[133] = new State(new int[]{3,9,40,103,46,115,57,121,59,126,62,137,33,149,45,-102,27,-102},new int[]{-34,134,-28,113,-21,16,-63,17,-3,34,-2,95,-62,46,-22,102,-25,114,-27,120,-29,125,-30,136,-26,148,-33,151,-32,152});
    states[134] = new State(new int[]{45,135,27,14});
    states[135] = new State(-84);
    states[136] = new State(-69);
    states[137] = new State(new int[]{3,9,5,53,7,54,6,55,8,56,9,57,10,58,4,59,28,60,25,63,34,66,12,74,11,76},new int[]{-10,138,-13,20,-17,23,-16,42,-18,28,-63,33,-3,34,-2,43,-62,46,-8,65});
    states[138] = new State(new int[]{55,139});
    states[139] = new State(new int[]{3,9,5,53,7,54,6,55,8,56,9,57,10,58,4,59,28,60,25,63,34,66,12,74,11,76,39,-90,42,-90,45,-90},new int[]{-35,140,-36,162,-56,145,-15,159,-11,155,-10,158,-13,20,-17,23,-16,42,-18,28,-63,33,-3,34,-2,43,-62,46,-8,65});
    states[140] = new State(new int[]{39,143,42,160,45,-97},new int[]{-31,141});
    states[141] = new State(new int[]{45,142});
    states[142] = new State(-87);
    states[143] = new State(new int[]{3,9,5,53,7,54,6,55,8,56,9,57,10,58,4,59,28,60,25,63,34,66,12,74,11,76},new int[]{-36,144,-56,145,-15,159,-11,155,-10,158,-13,20,-17,23,-16,42,-18,28,-63,33,-3,34,-2,43,-62,46,-8,65});
    states[144] = new State(-89);
    states[145] = new State(new int[]{32,146,30,153});
    states[146] = new State(new int[]{3,9,40,103,46,115,57,121,59,126,62,137,33,149,27,-102,39,-102,42,-102,45,-102},new int[]{-34,147,-28,113,-21,16,-63,17,-3,34,-2,95,-62,46,-22,102,-25,114,-27,120,-29,125,-30,136,-26,148,-33,151,-32,152});
    states[147] = new State(new int[]{27,14,39,-91,42,-91,45,-91});
    states[148] = new State(-70);
    states[149] = new State(new int[]{3,9,5,53,7,54,6,55,8,56,9,57,10,58,4,59,28,60,25,63,34,66,12,74,11,76},new int[]{-10,150,-13,20,-17,23,-16,42,-18,28,-63,33,-3,34,-2,43,-62,46,-8,65});
    states[150] = new State(-98);
    states[151] = new State(-71);
    states[152] = new State(-72);
    states[153] = new State(new int[]{3,9,5,53,7,54,6,55,8,56,9,57,10,58,4,59,28,60,25,63,34,66,12,74,11,76},new int[]{-15,154,-11,155,-10,158,-13,20,-17,23,-16,42,-18,28,-63,33,-3,34,-2,43,-62,46,-8,65});
    states[154] = new State(-93);
    states[155] = new State(new int[]{36,156,32,-94,30,-94});
    states[156] = new State(new int[]{3,9,5,53,7,54,6,55,8,56,9,57,10,58,4,59,28,60,25,63,34,66,12,74,11,76},new int[]{-11,157,-10,158,-13,20,-17,23,-16,42,-18,28,-63,33,-3,34,-2,43,-62,46,-8,65});
    states[157] = new State(-95);
    states[158] = new State(-109);
    states[159] = new State(-92);
    states[160] = new State(new int[]{3,9,40,103,46,115,57,121,59,126,62,137,33,149,27,-102,45,-102},new int[]{-34,161,-28,113,-21,16,-63,17,-3,34,-2,95,-62,46,-22,102,-25,114,-27,120,-29,125,-30,136,-26,148,-33,151,-32,152});
    states[161] = new State(new int[]{27,14,45,-96});
    states[162] = new State(-88);
    states[163] = new State(new int[]{3,9,5,53,7,54,6,55,8,56,9,57,10,58,4,59,28,60,25,63,34,66,12,74,11,76},new int[]{-11,164,-10,158,-13,20,-17,23,-16,42,-18,28,-63,33,-3,34,-2,43,-62,46,-8,65});
    states[164] = new State(-85);
    states[165] = new State(new int[]{3,9,5,53,7,54,6,55,8,56,9,57,10,58,4,59,28,60,25,63,34,66,12,74,11,76},new int[]{-10,166,-13,20,-17,23,-16,42,-18,28,-63,33,-3,34,-2,43,-62,46,-8,65});
    states[166] = new State(new int[]{41,167});
    states[167] = new State(new int[]{3,9,40,103,46,115,57,121,59,126,62,137,33,149,27,-102,42,-102,43,-102,45,-102},new int[]{-34,168,-28,113,-21,16,-63,17,-3,34,-2,95,-62,46,-22,102,-25,114,-27,120,-29,125,-30,136,-26,148,-33,151,-32,152});
    states[168] = new State(new int[]{27,14,42,111,43,165,45,-79},new int[]{-24,169,-23,170});
    states[169] = new State(-80);
    states[170] = new State(-81);
    states[171] = new State(-136);
    states[172] = new State(-131);
    states[173] = new State(new int[]{3,9},new int[]{-40,174,-39,210,-6,176,-4,209,-2,205});
    states[174] = new State(new int[]{3,9,44,-113,50,-113,49,-113,51,-113,53,-113},new int[]{-39,175,-6,176,-4,209,-2,205});
    states[175] = new State(-107);
    states[176] = new State(new int[]{32,177,30,203});
    states[177] = new State(new int[]{3,9,54,185,56,189,63,193},new int[]{-48,178,-7,180,-2,183,-49,184,-51,188,-50,192});
    states[178] = new State(new int[]{27,179});
    states[179] = new State(-105);
    states[180] = new State(new int[]{31,181,27,-118,29,-118});
    states[181] = new State(new int[]{3,9},new int[]{-2,182});
    states[182] = new State(-130);
    states[183] = new State(-129);
    states[184] = new State(-119);
    states[185] = new State(new int[]{55,186,3,9,5,53,7,54,6,55,8,56,9,57,10,58,4,59,28,60,25,63,34,66,12,74,11,76},new int[]{-58,196,-57,202,-11,201,-10,158,-13,20,-17,23,-16,42,-18,28,-63,33,-3,34,-2,43,-62,46,-8,65});
    states[186] = new State(new int[]{3,9,54,185,56,189,63,193},new int[]{-48,187,-7,180,-2,183,-49,184,-51,188,-50,192});
    states[187] = new State(-122);
    states[188] = new State(-120);
    states[189] = new State(new int[]{45,190});
    states[190] = new State(new int[]{30,191});
    states[191] = new State(-124);
    states[192] = new State(-121);
    states[193] = new State(new int[]{60,194});
    states[194] = new State(new int[]{3,9,54,185,56,189,63,193},new int[]{-48,195,-7,180,-2,183,-49,184,-51,188,-50,192});
    states[195] = new State(-128);
    states[196] = new State(new int[]{55,197,30,199});
    states[197] = new State(new int[]{3,9,54,185,56,189,63,193},new int[]{-48,198,-7,180,-2,183,-49,184,-51,188,-50,192});
    states[198] = new State(-123);
    states[199] = new State(new int[]{3,9,5,53,7,54,6,55,8,56,9,57,10,58,4,59,28,60,25,63,34,66,12,74,11,76},new int[]{-57,200,-11,201,-10,158,-13,20,-17,23,-16,42,-18,28,-63,33,-3,34,-2,43,-62,46,-8,65});
    states[200] = new State(-126);
    states[201] = new State(-127);
    states[202] = new State(-125);
    states[203] = new State(new int[]{3,9},new int[]{-4,204,-2,205});
    states[204] = new State(-104);
    states[205] = new State(new int[]{13,207,12,208,32,-10,30,-10,21,-10},new int[]{-5,206});
    states[206] = new State(-7);
    states[207] = new State(-8);
    states[208] = new State(-9);
    states[209] = new State(-103);
    states[210] = new State(-106);
    states[211] = new State(-132);
    states[212] = new State(new int[]{3,9},new int[]{-43,213,-42,219,-4,215,-2,205});
    states[213] = new State(new int[]{3,9,44,-112,50,-112,49,-112,51,-112,53,-112},new int[]{-42,214,-4,215,-2,205});
    states[214] = new State(-111);
    states[215] = new State(new int[]{21,216});
    states[216] = new State(new int[]{3,9,5,53,7,54,6,55,8,56,9,57,10,58,4,59,28,60,25,63,34,66,12,74,11,76},new int[]{-11,217,-10,158,-13,20,-17,23,-16,42,-18,28,-63,33,-3,34,-2,43,-62,46,-8,65});
    states[217] = new State(new int[]{27,218});
    states[218] = new State(-108);
    states[219] = new State(-110);
    states[220] = new State(-133);
    states[221] = new State(new int[]{3,9},new int[]{-46,222,-47,228,-4,224,-2,205});
    states[222] = new State(new int[]{3,9,44,-114,50,-114,49,-114,51,-114,53,-114},new int[]{-47,223,-4,224,-2,205});
    states[223] = new State(-116);
    states[224] = new State(new int[]{21,225});
    states[225] = new State(new int[]{3,9,54,185,56,189,63,193},new int[]{-48,226,-7,180,-2,183,-49,184,-51,188,-50,192});
    states[226] = new State(new int[]{27,227});
    states[227] = new State(-117);
    states[228] = new State(-115);
    states[229] = new State(-134);
    states[230] = new State(new int[]{3,9},new int[]{-2,231});
    states[231] = new State(new int[]{28,240,30,-138,27,-138},new int[]{-66,232});
    states[232] = new State(new int[]{30,238,27,-140},new int[]{-67,233});
    states[233] = new State(new int[]{27,234});
    states[234] = new State(-135,new int[]{-53,235,-37,10});
    states[235] = new State(new int[]{3,9},new int[]{-2,236});
    states[236] = new State(new int[]{27,237});
    states[237] = new State(-137);
    states[238] = new State(new int[]{3,9,54,185,56,189,63,193},new int[]{-48,239,-7,180,-2,183,-49,184,-51,188,-50,192});
    states[239] = new State(-141);
    states[240] = new State(new int[]{50,249,3,-145},new int[]{-68,241,-69,250,-64,245});
    states[241] = new State(new int[]{29,242,27,243});
    states[242] = new State(-139);
    states[243] = new State(new int[]{50,249,3,-145},new int[]{-69,244,-64,245});
    states[244] = new State(-143);
    states[245] = new State(new int[]{3,9},new int[]{-6,246,-4,209,-2,205});
    states[246] = new State(new int[]{32,247,30,203});
    states[247] = new State(new int[]{3,9,54,185,56,189,63,193},new int[]{-48,248,-7,180,-2,183,-49,184,-51,188,-50,192});
    states[248] = new State(-144);
    states[249] = new State(-146);
    states[250] = new State(-142);
    states[251] = new State(new int[]{3,9,5,53,7,54,6,55,8,56,9,57,10,58,4,59,28,60,25,63,34,66,12,74,11,76},new int[]{-10,252,-13,20,-17,23,-16,42,-18,28,-63,33,-3,34,-2,43,-62,46,-8,65});
    states[252] = new State(-3);

    rules[1] = new Rule(-65, new int[]{-1,2});
    rules[2] = new Rule(-1, new int[]{48,-2,27,-53,-2,31});
    rules[3] = new Rule(-1, new int[]{52,-10});
    rules[4] = new Rule(-2, new int[]{3});
    rules[5] = new Rule(-3, new int[]{-2,31,-2});
    rules[6] = new Rule(-3, new int[]{-2});
    rules[7] = new Rule(-4, new int[]{-2,-5});
    rules[8] = new Rule(-5, new int[]{13});
    rules[9] = new Rule(-5, new int[]{12});
    rules[10] = new Rule(-5, new int[]{});
    rules[11] = new Rule(-53, new int[]{-37,44,-34,45});
    rules[12] = new Rule(-8, new int[]{34,-9,35});
    rules[13] = new Rule(-9, new int[]{-12});
    rules[14] = new Rule(-9, new int[]{-9,30,-12});
    rules[15] = new Rule(-9, new int[]{});
    rules[16] = new Rule(-12, new int[]{-10});
    rules[17] = new Rule(-12, new int[]{-10,36,-10});
    rules[18] = new Rule(-10, new int[]{-13});
    rules[19] = new Rule(-10, new int[]{-13,-61,-13});
    rules[20] = new Rule(-61, new int[]{21});
    rules[21] = new Rule(-61, new int[]{22});
    rules[22] = new Rule(-61, new int[]{17});
    rules[23] = new Rule(-61, new int[]{19});
    rules[24] = new Rule(-61, new int[]{18});
    rules[25] = new Rule(-61, new int[]{20});
    rules[26] = new Rule(-13, new int[]{-17});
    rules[27] = new Rule(-13, new int[]{-17,-59,-19});
    rules[28] = new Rule(-17, new int[]{-16});
    rules[29] = new Rule(-17, new int[]{12,-16});
    rules[30] = new Rule(-17, new int[]{11,-16});
    rules[31] = new Rule(-19, new int[]{-16});
    rules[32] = new Rule(-19, new int[]{-19,-59,-16});
    rules[33] = new Rule(-16, new int[]{-18});
    rules[34] = new Rule(-16, new int[]{-18,-60,-20});
    rules[35] = new Rule(-20, new int[]{-18});
    rules[36] = new Rule(-20, new int[]{-20,-60,-18});
    rules[37] = new Rule(-18, new int[]{-63});
    rules[38] = new Rule(-18, new int[]{5});
    rules[39] = new Rule(-18, new int[]{7});
    rules[40] = new Rule(-18, new int[]{6});
    rules[41] = new Rule(-18, new int[]{8});
    rules[42] = new Rule(-18, new int[]{9});
    rules[43] = new Rule(-18, new int[]{10});
    rules[44] = new Rule(-18, new int[]{4});
    rules[45] = new Rule(-18, new int[]{28,-10,29});
    rules[46] = new Rule(-18, new int[]{25,-18});
    rules[47] = new Rule(-18, new int[]{-8});
    rules[48] = new Rule(-63, new int[]{-3});
    rules[49] = new Rule(-63, new int[]{-62});
    rules[50] = new Rule(-62, new int[]{-3,31,-2});
    rules[51] = new Rule(-62, new int[]{-3,37,-55,38});
    rules[52] = new Rule(-62, new int[]{-62,31,-2});
    rules[53] = new Rule(-62, new int[]{-62,37,-55,38});
    rules[54] = new Rule(-55, new int[]{-10});
    rules[55] = new Rule(-55, new int[]{-55,30,-10});
    rules[56] = new Rule(-59, new int[]{12});
    rules[57] = new Rule(-59, new int[]{11});
    rules[58] = new Rule(-59, new int[]{16});
    rules[59] = new Rule(-60, new int[]{13});
    rules[60] = new Rule(-60, new int[]{14});
    rules[61] = new Rule(-60, new int[]{23});
    rules[62] = new Rule(-60, new int[]{24});
    rules[63] = new Rule(-60, new int[]{15});
    rules[64] = new Rule(-28, new int[]{-21});
    rules[65] = new Rule(-28, new int[]{-22});
    rules[66] = new Rule(-28, new int[]{-25});
    rules[67] = new Rule(-28, new int[]{-27});
    rules[68] = new Rule(-28, new int[]{-29});
    rules[69] = new Rule(-28, new int[]{-30});
    rules[70] = new Rule(-28, new int[]{-26});
    rules[71] = new Rule(-28, new int[]{-33});
    rules[72] = new Rule(-28, new int[]{-32});
    rules[73] = new Rule(-34, new int[]{-28});
    rules[74] = new Rule(-34, new int[]{-34,27,-28});
    rules[75] = new Rule(-21, new int[]{-63,26,-10});
    rules[76] = new Rule(-22, new int[]{40,-10,41,-34,-24,45});
    rules[77] = new Rule(-22, new int[]{40,-10,41,-34,-23,45});
    rules[78] = new Rule(-24, new int[]{42,-34});
    rules[79] = new Rule(-24, new int[]{});
    rules[80] = new Rule(-23, new int[]{43,-10,41,-34,-24});
    rules[81] = new Rule(-23, new int[]{43,-10,41,-34,-23});
    rules[82] = new Rule(-25, new int[]{46,-10,47,-34,45});
    rules[83] = new Rule(-27, new int[]{57,-34,58,-10});
    rules[84] = new Rule(-29, new int[]{59,-2,26,-10,60,-10,-14,47,-34,45});
    rules[85] = new Rule(-14, new int[]{61,-11});
    rules[86] = new Rule(-14, new int[]{});
    rules[87] = new Rule(-30, new int[]{62,-10,55,-35,-31,45});
    rules[88] = new Rule(-35, new int[]{-36});
    rules[89] = new Rule(-35, new int[]{-35,39,-36});
    rules[90] = new Rule(-35, new int[]{});
    rules[91] = new Rule(-36, new int[]{-56,32,-34});
    rules[92] = new Rule(-56, new int[]{-15});
    rules[93] = new Rule(-56, new int[]{-56,30,-15});
    rules[94] = new Rule(-15, new int[]{-11});
    rules[95] = new Rule(-15, new int[]{-11,36,-11});
    rules[96] = new Rule(-31, new int[]{42,-34});
    rules[97] = new Rule(-31, new int[]{});
    rules[98] = new Rule(-26, new int[]{33,-10});
    rules[99] = new Rule(-54, new int[]{-10});
    rules[100] = new Rule(-54, new int[]{-54,30,-10});
    rules[101] = new Rule(-33, new int[]{-2,28,-54,29});
    rules[102] = new Rule(-32, new int[]{});
    rules[103] = new Rule(-6, new int[]{-4});
    rules[104] = new Rule(-6, new int[]{-6,30,-4});
    rules[105] = new Rule(-39, new int[]{-6,32,-48,27});
    rules[106] = new Rule(-40, new int[]{-39});
    rules[107] = new Rule(-40, new int[]{-40,-39});
    rules[108] = new Rule(-42, new int[]{-4,21,-11,27});
    rules[109] = new Rule(-11, new int[]{-10});
    rules[110] = new Rule(-43, new int[]{-42});
    rules[111] = new Rule(-43, new int[]{-43,-42});
    rules[112] = new Rule(-44, new int[]{49,-43});
    rules[113] = new Rule(-41, new int[]{50,-40});
    rules[114] = new Rule(-45, new int[]{51,-46});
    rules[115] = new Rule(-46, new int[]{-47});
    rules[116] = new Rule(-46, new int[]{-46,-47});
    rules[117] = new Rule(-47, new int[]{-4,21,-48,27});
    rules[118] = new Rule(-48, new int[]{-7});
    rules[119] = new Rule(-48, new int[]{-49});
    rules[120] = new Rule(-48, new int[]{-51});
    rules[121] = new Rule(-48, new int[]{-50});
    rules[122] = new Rule(-49, new int[]{54,55,-48});
    rules[123] = new Rule(-49, new int[]{54,-58,55,-48});
    rules[124] = new Rule(-51, new int[]{56,45,30});
    rules[125] = new Rule(-58, new int[]{-57});
    rules[126] = new Rule(-58, new int[]{-58,30,-57});
    rules[127] = new Rule(-57, new int[]{-11});
    rules[128] = new Rule(-50, new int[]{63,60,-48});
    rules[129] = new Rule(-7, new int[]{-2});
    rules[130] = new Rule(-7, new int[]{-7,31,-2});
    rules[131] = new Rule(-38, new int[]{-41});
    rules[132] = new Rule(-38, new int[]{-44});
    rules[133] = new Rule(-38, new int[]{-45});
    rules[134] = new Rule(-38, new int[]{-52});
    rules[135] = new Rule(-37, new int[]{});
    rules[136] = new Rule(-37, new int[]{-37,-38});
    rules[137] = new Rule(-52, new int[]{53,-2,-66,-67,27,-53,-2,27});
    rules[138] = new Rule(-66, new int[]{});
    rules[139] = new Rule(-66, new int[]{28,-68,29});
    rules[140] = new Rule(-67, new int[]{});
    rules[141] = new Rule(-67, new int[]{30,-48});
    rules[142] = new Rule(-68, new int[]{-69});
    rules[143] = new Rule(-68, new int[]{-68,27,-69});
    rules[144] = new Rule(-69, new int[]{-64,-6,32,-48});
    rules[145] = new Rule(-64, new int[]{});
    rules[146] = new Rule(-64, new int[]{50});
  }

  protected override void Initialize() {
    this.InitSpecialTokens((int)Tokens.error, (int)Tokens.EOF);
    this.InitStates(states);
    this.InitRules(rules);
    this.InitNonTerminals(nonTerms);
  }

  protected override void DoAction(int action)
  {
    switch (action)
    {
      case 2: // module -> MODULE, ident, SEMICOLUMN, mainblock, ident, COMMA
{
		if (ValueStack[ValueStack.Depth-5].id.name != ValueStack[ValueStack.Depth-2].id.name)
			PT.AddError("Имя " + ValueStack[ValueStack.Depth-2].id.name + " должно совпадать с именем модуля " + ValueStack[ValueStack.Depth-5].id.name, LocationStack[LocationStack.Depth-2]);
		
		// Подключение стандартного модуля Oberon00System, написанного на PascalABC.NET
		var ul = new uses_list("Oberon00System");
		
		// Формирование модуля основной программы (используется фабричный метод вместо конструктора)
		root = program_module.create(ValueStack[ValueStack.Depth-5].id, ul, ValueStack[ValueStack.Depth-3].bl, CurrentLocationSpan);
    }
        break;
      case 3: // module -> INVISIBLE, expr
{ // Для Intellisense
		root = ValueStack[ValueStack.Depth-1].ex;
	}
        break;
      case 4: // ident -> ID
{
		CurrentSemanticValue.id = new ident(ValueStack[ValueStack.Depth-1].sVal,CurrentLocationSpan); 
	}
        break;
      case 5: // specifiedIdent -> ident, COMMA, ident
{
		CurrentSemanticValue.adrv = new dot_node(ValueStack[ValueStack.Depth-3].id, ValueStack[ValueStack.Depth-1].id, CurrentLocationSpan);
	}
        break;
      case 6: // specifiedIdent -> ident
{
		CurrentSemanticValue.adrv = ValueStack[ValueStack.Depth-1].id;
	}
        break;
      case 7: // identDef -> ident, ExportLabel
{
		CurrentSemanticValue.obrid = new oberon_ident_with_export_marker(ValueStack[ValueStack.Depth-2].id.name, ValueStack[ValueStack.Depth-1].obrem, CurrentLocationSpan);
	}
        break;
      case 8: // ExportLabel -> MULT
{
		CurrentSemanticValue.obrem = oberon_export_marker.export;
	}
        break;
      case 9: // ExportLabel -> MINUS
{
		CurrentSemanticValue.obrem = oberon_export_marker.export_readonly;
	}
        break;
      case 10: // ExportLabel -> /* empty */
{
		//$$ = oberon_export_marker.nonexport;
		CurrentSemanticValue.obrem = oberon_export_marker.export;
	}
        break;
      case 11: // mainblock -> Declarations, BEGIN, StatementSequence, END
{
		CurrentSemanticValue.bl = new block(ValueStack[ValueStack.Depth-4].decl, ValueStack[ValueStack.Depth-2].sl, CurrentLocationSpan);
	}
        break;
      case 12: // SetConstant -> LBRACE, SetElemList, RBRACE
{
		CurrentSemanticValue.sc = ValueStack[ValueStack.Depth-2].sc;
		CurrentSemanticValue.sc.source_context = CurrentLocationSpan;
	}
        break;
      case 13: // SetElemList -> SetElem
{
		CurrentSemanticValue.sc = new pascal_set_constant();
		CurrentSemanticValue.sc.Add(ValueStack[ValueStack.Depth-1].ex);
		CurrentSemanticValue.sc.source_context = CurrentLocationSpan;
		
	}
        break;
      case 14: // SetElemList -> SetElemList, COLUMN, SetElem
{
		CurrentSemanticValue.sc = ValueStack[ValueStack.Depth-3].sc;
		CurrentSemanticValue.sc.Add(ValueStack[ValueStack.Depth-1].ex);
		CurrentSemanticValue.sc.source_context = CurrentLocationSpan;
	}
        break;
      case 15: // SetElemList -> /* empty */
{
		CurrentSemanticValue.sc = new pascal_set_constant();
	}
        break;
      case 17: // SetElem -> expr, DOUBLEPOINT, expr
{
		CurrentSemanticValue.ex = new diapason_expr(ValueStack[ValueStack.Depth-3].ex, ValueStack[ValueStack.Depth-1].ex, CurrentLocationSpan);
	}
        break;
      case 18: // expr -> SimpleExpr
{
		CurrentSemanticValue.ex = ValueStack[ValueStack.Depth-1].ex;
	}
        break;
      case 19: // expr -> SimpleExpr, Relation, SimpleExpr
{
		CurrentSemanticValue.ex = new bin_expr(ValueStack[ValueStack.Depth-3].ex, ValueStack[ValueStack.Depth-1].ex, ValueStack[ValueStack.Depth-2].ops, CurrentLocationSpan);
	}
        break;
      case 20: // Relation -> EQ
{
		CurrentSemanticValue.ops = Operators.Equal;
	}
        break;
      case 21: // Relation -> NE
{
		CurrentSemanticValue.ops = Operators.NotEqual;
	}
        break;
      case 22: // Relation -> LT
{
		CurrentSemanticValue.ops = Operators.Less;
	}
        break;
      case 23: // Relation -> LE
{
		CurrentSemanticValue.ops = Operators.LessEqual;
	}
        break;
      case 24: // Relation -> GT
{
		CurrentSemanticValue.ops = Operators.Greater;
	}
        break;
      case 25: // Relation -> GE
{
		CurrentSemanticValue.ops = Operators.GreaterEqual;
	}
        break;
      case 26: // SimpleExpr -> signedTerm
{
		CurrentSemanticValue.ex = ValueStack[ValueStack.Depth-1].ex;
		CurrentSemanticValue.ex.source_context = CurrentLocationSpan;
	}
        break;
      case 27: // SimpleExpr -> signedTerm, AddOperator, AddList
{
		CurrentSemanticValue.ex = new bin_expr(ValueStack[ValueStack.Depth-3].ex, ValueStack[ValueStack.Depth-1].ex, ValueStack[ValueStack.Depth-2].ops, CurrentLocationSpan);
	}
        break;
      case 29: // signedTerm -> MINUS, term
{
		CurrentSemanticValue.ex = new un_expr(ValueStack[ValueStack.Depth-1].ex, Operators.Minus, CurrentLocationSpan);
	}
        break;
      case 30: // signedTerm -> PLUS, term
{
		CurrentSemanticValue.ex = new un_expr(ValueStack[ValueStack.Depth-1].ex, Operators.Plus, CurrentLocationSpan);
	}
        break;
      case 32: // AddList -> AddList, AddOperator, term
{
		CurrentSemanticValue.ex = new bin_expr(ValueStack[ValueStack.Depth-3].ex, ValueStack[ValueStack.Depth-1].ex, ValueStack[ValueStack.Depth-2].ops, CurrentLocationSpan);
	}
        break;
      case 34: // term -> factor, MultOperator, FactorList
{
		CurrentSemanticValue.ex = new bin_expr(ValueStack[ValueStack.Depth-3].ex, ValueStack[ValueStack.Depth-1].ex, ValueStack[ValueStack.Depth-2].ops, CurrentLocationSpan);
	}
        break;
      case 36: // FactorList -> FactorList, MultOperator, factor
{
		CurrentSemanticValue.ex = new bin_expr(ValueStack[ValueStack.Depth-3].ex, ValueStack[ValueStack.Depth-1].ex, ValueStack[ValueStack.Depth-2].ops, CurrentLocationSpan);
	}
        break;
      case 37: // factor -> Designator
{
		CurrentSemanticValue.ex = ValueStack[ValueStack.Depth-1].adrv;
	}
        break;
      case 38: // factor -> INTNUM
{ 
		CurrentSemanticValue.ex = new int32_const(ValueStack[ValueStack.Depth-1].iVal,CurrentLocationSpan); 		
	}
        break;
      case 39: // factor -> LONGINTNUM
{
		CurrentSemanticValue.ex = new int64_const(ValueStack[ValueStack.Depth-1].lVal, CurrentLocationSpan); 		
	}
        break;
      case 40: // factor -> REALNUM
{
		CurrentSemanticValue.ex = new double_const(ValueStack[ValueStack.Depth-1].rVal, CurrentLocationSpan);
	}
        break;
      case 41: // factor -> TRUE
{
		CurrentSemanticValue.ex = new bool_const(true,CurrentLocationSpan);
	}
        break;
      case 42: // factor -> FALSE
{
		CurrentSemanticValue.ex = new bool_const(false,CurrentLocationSpan);
	}
        break;
      case 43: // factor -> CHAR_CONST
{
		CurrentSemanticValue.ex = new char_const(ValueStack[ValueStack.Depth-1].cVal, CurrentLocationSpan);
	}
        break;
      case 44: // factor -> STRING_CONST
{
		CurrentSemanticValue.ex = new string_const(ValueStack[ValueStack.Depth-1].sVal, CurrentLocationSpan);
	}
        break;
      case 45: // factor -> LPAREN, expr, RPAREN
{ 
		CurrentSemanticValue.ex = ValueStack[ValueStack.Depth-2].ex;
	}
        break;
      case 46: // factor -> NOT, factor
{
		CurrentSemanticValue.ex = new un_expr(ValueStack[ValueStack.Depth-1].ex,Operators.LogicalNOT,CurrentLocationSpan);
	}
        break;
      case 48: // Designator -> specifiedIdent
{
		CurrentSemanticValue.adrv = ValueStack[ValueStack.Depth-1].adrv;
	}
        break;
      case 49: // Designator -> ComplexDesignator
{
		CurrentSemanticValue.adrv = ValueStack[ValueStack.Depth-1].adrv;
	}
        break;
      case 50: // ComplexDesignator -> specifiedIdent, COMMA, ident
{
		CurrentSemanticValue.adrv = new dot_node(ValueStack[ValueStack.Depth-3].adrv, ValueStack[ValueStack.Depth-1].id, CurrentLocationSpan);
	}
        break;
      case 51: // ComplexDesignator -> specifiedIdent, LBRACKET, ExprList, RBRACKET
{
		indexer indxr = new indexer();
		indxr.dereferencing_value = ValueStack[ValueStack.Depth-4].adrv;
		indxr.indexes = ValueStack[ValueStack.Depth-2].el;
		CurrentSemanticValue.adrv = indxr;
		CurrentSemanticValue.adrv.source_context = CurrentLocationSpan;
	}
        break;
      case 52: // ComplexDesignator -> ComplexDesignator, COMMA, ident
{
		CurrentSemanticValue.adrv = new dot_node(ValueStack[ValueStack.Depth-3].adrv, ValueStack[ValueStack.Depth-1].id, CurrentLocationSpan);
	}
        break;
      case 53: // ComplexDesignator -> ComplexDesignator, LBRACKET, ExprList, RBRACKET
{
		indexer indxr = new indexer();
		indxr.dereferencing_value = ValueStack[ValueStack.Depth-4].adrv;
		indxr.indexes = ValueStack[ValueStack.Depth-2].el;
		CurrentSemanticValue.adrv = indxr;
		CurrentSemanticValue.adrv.source_context = CurrentLocationSpan;
	}
        break;
      case 54: // ExprList -> expr
{
		CurrentSemanticValue.el = new expression_list(ValueStack[ValueStack.Depth-1].ex, CurrentLocationSpan);
	}
        break;
      case 55: // ExprList -> ExprList, COLUMN, expr
{
		CurrentSemanticValue.el = ValueStack[ValueStack.Depth-3].el;
		CurrentSemanticValue.el.Add(ValueStack[ValueStack.Depth-1].ex, LocationStack[LocationStack.Depth-1]);
		CurrentSemanticValue.el.source_context = CurrentLocationSpan;
	}
        break;
      case 56: // AddOperator -> MINUS
{
		CurrentSemanticValue.ops = Operators.Minus;
	}
        break;
      case 57: // AddOperator -> PLUS
{
		CurrentSemanticValue.ops = Operators.Plus;
	}
        break;
      case 58: // AddOperator -> OR
{
		CurrentSemanticValue.ops = Operators.LogicalOR;
	}
        break;
      case 59: // MultOperator -> MULT
{
		CurrentSemanticValue.ops = Operators.Multiplication;
	}
        break;
      case 60: // MultOperator -> DIVIDE
{
		CurrentSemanticValue.ops = Operators.Division;
	}
        break;
      case 61: // MultOperator -> DIV
{
		CurrentSemanticValue.ops = Operators.IntegerDivision;
	}
        break;
      case 62: // MultOperator -> MOD
{
		CurrentSemanticValue.ops = Operators.ModulusRemainder;
	}
        break;
      case 63: // MultOperator -> AND
{
		CurrentSemanticValue.ops = Operators.LogicalAND;
	}
        break;
      case 73: // StatementSequence -> Statement
{
		CurrentSemanticValue.sl = new statement_list(ValueStack[ValueStack.Depth-1].st,CurrentLocationSpan);
	}
        break;
      case 74: // StatementSequence -> StatementSequence, SEMICOLUMN, Statement
{
		ValueStack[ValueStack.Depth-3].sl.Add(ValueStack[ValueStack.Depth-1].st,CurrentLocationSpan);
		CurrentSemanticValue.sl = ValueStack[ValueStack.Depth-3].sl;
	}
        break;
      case 75: // Assignment -> Designator, ASSIGN, expr
{
		CurrentSemanticValue.st = new assign(ValueStack[ValueStack.Depth-3].adrv, ValueStack[ValueStack.Depth-1].ex, Operators.Assignment, CurrentLocationSpan);
	}
        break;
      case 76: // IfStatement -> IF, expr, THEN, StatementSequence, ElseStatements, END
{
		CurrentSemanticValue.st = new if_node(ValueStack[ValueStack.Depth-5].ex, ValueStack[ValueStack.Depth-3].sl, ValueStack[ValueStack.Depth-2].st, CurrentLocationSpan);
	}
        break;
      case 77: // IfStatement -> IF, expr, THEN, StatementSequence, ElseIfStatements, END
{
		CurrentSemanticValue.st = new if_node(ValueStack[ValueStack.Depth-5].ex, ValueStack[ValueStack.Depth-3].sl, ValueStack[ValueStack.Depth-2].st, CurrentLocationSpan);
	}
        break;
      case 78: // ElseStatements -> ELSE, StatementSequence
{
		CurrentSemanticValue.st = ValueStack[ValueStack.Depth-1].sl;
		CurrentSemanticValue.st.source_context = CurrentLocationSpan;
	}
        break;
      case 79: // ElseStatements -> /* empty */
{
		CurrentSemanticValue.st = null;
	}
        break;
      case 80: // ElseIfStatements -> ELSEIF, expr, THEN, StatementSequence, ElseStatements
{
		CurrentSemanticValue.st = new if_node(ValueStack[ValueStack.Depth-4].ex, ValueStack[ValueStack.Depth-2].sl, ValueStack[ValueStack.Depth-1].st, CurrentLocationSpan);
	}
        break;
      case 81: // ElseIfStatements -> ELSEIF, expr, THEN, StatementSequence, ElseIfStatements
{
		CurrentSemanticValue.st = new if_node(ValueStack[ValueStack.Depth-4].ex, ValueStack[ValueStack.Depth-2].sl, ValueStack[ValueStack.Depth-1].st, CurrentLocationSpan);
	}
        break;
      case 82: // WhileStatement -> WHILE, expr, DO, StatementSequence, END
{
		CurrentSemanticValue.st = new while_node(ValueStack[ValueStack.Depth-4].ex, ValueStack[ValueStack.Depth-2].sl, WhileCycleType.While, CurrentLocationSpan);
	}
        break;
      case 83: // RepeatStatement -> REPEAT, StatementSequence, UNTIL, expr
{
		CurrentSemanticValue.st = new repeat_node(ValueStack[ValueStack.Depth-3].sl, ValueStack[ValueStack.Depth-1].ex, CurrentLocationSpan);
	}
        break;
      case 84: // ForStatement -> FOR, ident, ASSIGN, expr, TO, expr, ForStep, DO, 
               //                 StatementSequence, END
{
		expression step;
		if (ValueStack[ValueStack.Depth-4].ex != null) 	step = ValueStack[ValueStack.Depth-4].ex;
		else 				step = new int32_const(1, LocationStack[LocationStack.Depth-4]);
		// Будем моделировать цикл через while
		statement_list forStmnt = GetForThroughWhile(ValueStack[ValueStack.Depth-9].id, ValueStack[ValueStack.Depth-7].ex, ValueStack[ValueStack.Depth-5].ex, ValueStack[ValueStack.Depth-2].sl, step, LocationStack[LocationStack.Depth-8], CurrentLocationSpan);
		CurrentSemanticValue.st = forStmnt;
		CurrentSemanticValue.st.source_context = CurrentLocationSpan;
	}
        break;
      case 85: // ForStep -> BY, ConstExpr
{
		int32_const step32 = ValueStack[ValueStack.Depth-1].ex as int32_const;
		if (step32 != null) {	// шаг является просто целым числом (без знака)
			if (step32.val == 0)	PT.AddError("Шаг цикла не может быть нулевым", LocationStack[LocationStack.Depth-2]);
			else					CurrentSemanticValue.ex = new int32_const(step32.val, CurrentLocationSpan);
		}
		else {					// в значении шага либо присутствует знак, либо это вообще не целое
			un_expr stepMinus = ValueStack[ValueStack.Depth-1].ex as un_expr;
			int32_const stepMinusTerm = stepMinus.subnode as int32_const;
			bool signMinus = (stepMinusTerm != null) &&	(stepMinus.operation_type == Operators.Minus);
			if (signMinus)
				if (stepMinusTerm.val == 0)
					PT.AddError("Шаг цикла не может быть нулевым", LocationStack[LocationStack.Depth-2]);
				else	
					CurrentSemanticValue.ex = new un_expr(stepMinusTerm, Operators.Minus, LocationStack[LocationStack.Depth-1]);
			else
				PT.AddError("Шаг цикла должен быть целым числом", LocationStack[LocationStack.Depth-2]);
		}
	}
        break;
      case 86: // ForStep -> /* empty */
{
		CurrentSemanticValue.ex = null;
	}
        break;
      case 87: // CaseStatement -> CASE, expr, OF, CaseVariantList, ElseBranch, END
{
		CurrentSemanticValue.st = new case_node(ValueStack[ValueStack.Depth-5].ex, ValueStack[ValueStack.Depth-3].cvars, ValueStack[ValueStack.Depth-2].st, CurrentLocationSpan);
	}
        break;
      case 88: // CaseVariantList -> CaseVariant
{
		CurrentSemanticValue.cvars = new case_variants();
		CurrentSemanticValue.cvars.Add(ValueStack[ValueStack.Depth-1].cvar);
		CurrentSemanticValue.cvars.source_context = CurrentLocationSpan;
	}
        break;
      case 89: // CaseVariantList -> CaseVariantList, PIPE, CaseVariant
{
		CurrentSemanticValue.cvars = ValueStack[ValueStack.Depth-3].cvars;
		CurrentSemanticValue.cvars.Add(ValueStack[ValueStack.Depth-1].cvar);
		CurrentSemanticValue.cvars.source_context = CurrentLocationSpan;
	}
        break;
      case 90: // CaseVariantList -> /* empty */
{
		CurrentSemanticValue.cvars = new case_variants();
	}
        break;
      case 91: // CaseVariant -> CaseVariantLabelList, COLON, StatementSequence
{
		CurrentSemanticValue.cvar = new case_variant(ValueStack[ValueStack.Depth-3].el, ValueStack[ValueStack.Depth-1].sl, CurrentLocationSpan);
	}
        break;
      case 92: // CaseVariantLabelList -> CaseVariantLabels
{
		CurrentSemanticValue.el = new expression_list(ValueStack[ValueStack.Depth-1].ex, CurrentLocationSpan);
	}
        break;
      case 93: // CaseVariantLabelList -> CaseVariantLabelList, COLUMN, CaseVariantLabels
{
		CurrentSemanticValue.el = ValueStack[ValueStack.Depth-3].el;
		CurrentSemanticValue.el.Add(ValueStack[ValueStack.Depth-1].ex, LocationStack[LocationStack.Depth-1]);
		CurrentSemanticValue.el.source_context = CurrentLocationSpan;
	}
        break;
      case 94: // CaseVariantLabels -> ConstExpr
{
		CurrentSemanticValue.ex = ValueStack[ValueStack.Depth-1].ex;
	}
        break;
      case 95: // CaseVariantLabels -> ConstExpr, DOUBLEPOINT, ConstExpr
{
		CurrentSemanticValue.ex = new diapason_expr(ValueStack[ValueStack.Depth-3].ex, ValueStack[ValueStack.Depth-1].ex, CurrentLocationSpan);
	}
        break;
      case 96: // ElseBranch -> ELSE, StatementSequence
{
		CurrentSemanticValue.st = ValueStack[ValueStack.Depth-1].sl;
		CurrentSemanticValue.st.source_context = CurrentLocationSpan;
	}
        break;
      case 97: // ElseBranch -> /* empty */
{
		CurrentSemanticValue.st = null;
	}
        break;
      case 98: // WriteStatement -> EXCLAMATION, expr
{
		expression_list el = new expression_list(ValueStack[ValueStack.Depth-1].ex,CurrentLocationSpan);
		method_call mc = new method_call(el);
		mc.dereferencing_value = new ident("print");
		CurrentSemanticValue.st = mc;
	}
        break;
      case 99: // factparams -> expr
{
		CurrentSemanticValue.el = new expression_list(ValueStack[ValueStack.Depth-1].ex,CurrentLocationSpan);
	}
        break;
      case 100: // factparams -> factparams, COLUMN, expr
{
		ValueStack[ValueStack.Depth-3].el.Add(ValueStack[ValueStack.Depth-1].ex,CurrentLocationSpan);
		CurrentSemanticValue.el = ValueStack[ValueStack.Depth-3].el;
	}
        break;
      case 101: // ProcCallStatement -> ident, LPAREN, factparams, RPAREN
{
		CurrentSemanticValue.st = new method_call(ValueStack[ValueStack.Depth-4].id,ValueStack[ValueStack.Depth-2].el,CurrentLocationSpan);
	}
        break;
      case 102: // EmptyStatement -> /* empty */
{
		CurrentSemanticValue.st = new empty_statement();		
	}
        break;
      case 103: // IDList -> identDef
{
		CurrentSemanticValue.il=new ident_list(ValueStack[ValueStack.Depth-1].obrid,CurrentLocationSpan);
		
	}
        break;
      case 104: // IDList -> IDList, COLUMN, identDef
{
		ValueStack[ValueStack.Depth-3].il.Add(ValueStack[ValueStack.Depth-1].obrid,CurrentLocationSpan);
		CurrentSemanticValue.il = ValueStack[ValueStack.Depth-3].il;
	}
        break;
      case 105: // VarDecl -> IDList, COLON, TypeDef, SEMICOLUMN
{
		CurrentSemanticValue.vds  = new var_def_statement(ValueStack[ValueStack.Depth-4].il, ValueStack[ValueStack.Depth-2].tdef, null, definition_attribute.None, false, CurrentLocationSpan);
	}
        break;
      case 106: // VarDeclarations -> VarDecl
{
		CurrentSemanticValue.vdss = new variable_definitions(ValueStack[ValueStack.Depth-1].vds,CurrentLocationSpan);
	}
        break;
      case 107: // VarDeclarations -> VarDeclarations, VarDecl
{
		ValueStack[ValueStack.Depth-2].vdss.Add(ValueStack[ValueStack.Depth-1].vds,CurrentLocationSpan);
		CurrentSemanticValue.vdss = ValueStack[ValueStack.Depth-2].vdss;
	}
        break;
      case 108: // ConstDecl -> identDef, EQ, ConstExpr, SEMICOLUMN
{
		CurrentSemanticValue.scd = new simple_const_definition(ValueStack[ValueStack.Depth-4].obrid,ValueStack[ValueStack.Depth-2].ex,CurrentLocationSpan);
	}
        break;
      case 110: // ConstDeclarations -> ConstDecl
{
		CurrentSemanticValue.cdl = new consts_definitions_list(ValueStack[ValueStack.Depth-1].scd,CurrentLocationSpan);
	}
        break;
      case 111: // ConstDeclarations -> ConstDeclarations, ConstDecl
{
		ValueStack[ValueStack.Depth-2].cdl.Add(ValueStack[ValueStack.Depth-1].scd,CurrentLocationSpan); 
		CurrentSemanticValue.cdl = ValueStack[ValueStack.Depth-2].cdl;
	}
        break;
      case 112: // ConstDeclarationsSect -> CONST, ConstDeclarations
{
		CurrentSemanticValue.cdl = ValueStack[ValueStack.Depth-1].cdl;
		CurrentSemanticValue.cdl.source_context = CurrentLocationSpan;
	}
        break;
      case 113: // VarDeclarationsSect -> VAR, VarDeclarations
{
		CurrentSemanticValue.vdss = ValueStack[ValueStack.Depth-1].vdss;
		CurrentSemanticValue.vdss.source_context = CurrentLocationSpan;
	}
        break;
      case 114: // TypeDeclarationsSect -> TYPE, TypeDeclarations
{
		CurrentSemanticValue.td = ValueStack[ValueStack.Depth-1].td;
		CurrentSemanticValue.td.source_context = CurrentLocationSpan;
	}
        break;
      case 115: // TypeDeclarations -> TypeDecl
{
		CurrentSemanticValue.td = new  type_declarations();
		CurrentSemanticValue.td.Add(ValueStack[ValueStack.Depth-1].tdec);
		CurrentSemanticValue.td.source_context = CurrentLocationSpan;
	}
        break;
      case 116: // TypeDeclarations -> TypeDeclarations, TypeDecl
{
		CurrentSemanticValue.td = ValueStack[ValueStack.Depth-2].td;
		CurrentSemanticValue.td.Add(ValueStack[ValueStack.Depth-1].tdec);
		CurrentSemanticValue.td.source_context = CurrentLocationSpan;
	}
        break;
      case 117: // TypeDecl -> identDef, EQ, TypeDef, SEMICOLUMN
{
		CurrentSemanticValue.tdec = new type_declaration(ValueStack[ValueStack.Depth-4].obrid, ValueStack[ValueStack.Depth-2].tdef, CurrentLocationSpan);
	}
        break;
      case 118: // TypeDef -> complexTypeIdent
{
		CurrentSemanticValue.tdef = ValueStack[ValueStack.Depth-1].ntr;
	}
        break;
      case 119: // TypeDef -> ArrayType
{
		CurrentSemanticValue.tdef = ValueStack[ValueStack.Depth-1].tdef;
		CurrentSemanticValue.tdef.source_context = CurrentLocationSpan;
	}
        break;
      case 120: // TypeDef -> RecordType
{
		CurrentSemanticValue.tdef = ValueStack[ValueStack.Depth-1].cldef;
		CurrentSemanticValue.tdef.source_context = CurrentLocationSpan;
	}
        break;
      case 121: // TypeDef -> PointerType
{
		CurrentSemanticValue.tdef = ValueStack[ValueStack.Depth-1].rft;
		CurrentSemanticValue.tdef.source_context = CurrentLocationSpan;
	}
        break;
      case 122: // ArrayType -> ARRAY, OF, TypeDef
{
		// открытый массив
		diapason dp = new diapason(new int32_const(0), new int32_const(0));
		indexers_types inxr = new indexers_types();
		inxr.Add(dp);
		CurrentSemanticValue.tdef = new array_type(inxr, ValueStack[ValueStack.Depth-1].tdef, CurrentLocationSpan);
	}
        break;
      case 123: // ArrayType -> ARRAY, LengthList, OF, TypeDef
{
		// Будем искать array n of char, чтобы заменить на строку
		named_type_reference ntr = ValueStack[ValueStack.Depth-1].tdef as named_type_reference;
		bool complexArr = 	(ntr != null) && (ntr.names.Count == 1) && 
							(ntr.names[0].name == "char");
		if (complexArr) 
			CurrentSemanticValue.tdef = GetArrWithStrInsteadCharArr(ValueStack[ValueStack.Depth-3].indts, LocationStack[LocationStack.Depth-3], CurrentLocationSpan);
		else
			CurrentSemanticValue.tdef = new array_type(ValueStack[ValueStack.Depth-3].indts, ValueStack[ValueStack.Depth-1].tdef, CurrentLocationSpan); 
	}
        break;
      case 124: // RecordType -> RECORD, END, COLUMN
{
	
	}
        break;
      case 125: // LengthList -> Length
{
		CurrentSemanticValue.indts = new indexers_types();
		CurrentSemanticValue.indts.source_context = CurrentLocationSpan;
		CurrentSemanticValue.indts.Add(ValueStack[ValueStack.Depth-1].dpsn);
	}
        break;
      case 126: // LengthList -> LengthList, COLUMN, Length
{
		CurrentSemanticValue.indts = ValueStack[ValueStack.Depth-3].indts;
		CurrentSemanticValue.indts.source_context = CurrentLocationSpan;
		CurrentSemanticValue.indts.Add(ValueStack[ValueStack.Depth-1].dpsn);
	}
        break;
      case 127: // Length -> ConstExpr
{
		// В обероне в массиве указывается целочисленная длина
		// Поэтому надо проверить, что выражение относится к целому типу
		object[] types = {ValueStack[ValueStack.Depth-1].ex};
		bool isLength = typeof(int32_const) == System.Type.GetTypeArray(types)[0];
		if (isLength)	
			CurrentSemanticValue.dpsn = GetDiapasonByArrLength(ValueStack[ValueStack.Depth-1].ex, CurrentLocationSpan);
		else
			PT.AddError("Длина должна быть целым числом", LocationStack[LocationStack.Depth-1]);
	}
        break;
      case 128: // PointerType -> POINTER, TO, TypeDef
{
		CurrentSemanticValue.rft = new ref_type(ValueStack[ValueStack.Depth-1].tdef, CurrentLocationSpan);
	}
        break;
      case 129: // complexTypeIdent -> ident
{
		CurrentSemanticValue.ntr = new named_type_reference(PT.InternalTypeName(ValueStack[ValueStack.Depth-1].id.name), CurrentLocationSpan);
	}
        break;
      case 130: // complexTypeIdent -> complexTypeIdent, COMMA, ident
{
		CurrentSemanticValue.ntr = ValueStack[ValueStack.Depth-3].ntr;
		CurrentSemanticValue.ntr.Add(PT.InternalTypeName(ValueStack[ValueStack.Depth-1].id.name));
		CurrentSemanticValue.ntr.source_context = CurrentLocationSpan;
	}
        break;
      case 131: // DeclarationsSect -> VarDeclarationsSect
{
		CurrentSemanticValue.decsec = ValueStack[ValueStack.Depth-1].vdss;
	}
        break;
      case 132: // DeclarationsSect -> ConstDeclarationsSect
{
		CurrentSemanticValue.decsec = ValueStack[ValueStack.Depth-1].cdl;
	}
        break;
      case 133: // DeclarationsSect -> TypeDeclarationsSect
{
		CurrentSemanticValue.decsec = ValueStack[ValueStack.Depth-1].td;
	}
        break;
      case 134: // DeclarationsSect -> ProcedureDeclarationSect
{
		CurrentSemanticValue.decsec = ValueStack[ValueStack.Depth-1].pd;
	}
        break;
      case 135: // Declarations -> /* empty */
{
	  CurrentSemanticValue.decl = new declarations();
	}
        break;
      case 136: // Declarations -> Declarations, DeclarationsSect
{
		if (ValueStack[ValueStack.Depth-1].decsec != null)
			ValueStack[ValueStack.Depth-2].decl.Add(ValueStack[ValueStack.Depth-1].decsec);
		CurrentSemanticValue.decl = ValueStack[ValueStack.Depth-2].decl;
		CurrentSemanticValue.decl.source_context = CurrentLocationSpan;			// Необходимо показать место в программе, т.к. неявно это не сделано
										// (например, в конструкторе)
	}
        break;
      case 137: // ProcedureDeclarationSect -> PROCEDURE, ident, maybeformalparams, maybereturn, 
                //                             SEMICOLUMN, mainblock, ident, SEMICOLUMN
{
	
	}
        break;
      case 138: // maybeformalparams -> /* empty */
{
		//$$ = null;
	}
        break;
      case 139: // maybeformalparams -> LPAREN, FPList, RPAREN
{
		//$$ = $2;
	}
        break;
      case 140: // maybereturn -> /* empty */
{
		
	}
        break;
      case 141: // maybereturn -> COLUMN, TypeDef
{
	
	}
        break;
      case 142: // FPList -> FPSect
{
	
	}
        break;
      case 143: // FPList -> FPList, SEMICOLUMN, FPSect
{
	
	}
        break;
      case 144: // FPSect -> maybevar, IDList, COLON, TypeDef
{
	
	}
        break;
      case 145: // maybevar -> /* empty */
{
		CurrentSemanticValue.bVal = false;
	}
        break;
      case 146: // maybevar -> VAR
{
		CurrentSemanticValue.bVal = true;
	}
        break;
    }
  }

  protected override string TerminalToString(int terminal)
  {
    if (aliasses != null && aliasses.ContainsKey(terminal))
        return aliasses[terminal];
    else if (((Tokens)terminal).ToString() != terminal.ToString(CultureInfo.InvariantCulture))
        return ((Tokens)terminal).ToString();
    else
        return CharToString((char)terminal);
  }


/* 	Возвращает последовательность операторов, соответсвующую
	циклу for, моделируемому через while */
public static statement_list GetForThroughWhile(ident id, expression expr, expression endExpr, statement_list stmnts,
		expression step, SourceContext assignSC, SourceContext wholeSC){
	// Будем моделировать цикл через while
	statement_list forStmnt = new statement_list();
	ident endFor = new ident("_oberon_for_end_");
	forStmnt.Add(new var_statement(new var_def_statement(
		new ident_list("_oberon_for_end_"),
		new named_type_reference("integer", null),
		endExpr,
		definition_attribute.None,
		false))
	);
	forStmnt.Add( new assign(id, expr, Operators.Assignment, assignSC) );
	statement_list posStatementList = new statement_list();		// при положительном шаге
		posStatementList.Add(stmnts);
		posStatementList.Add( new assign(id, step, Operators.AssignmentAddition) );
	while_node posWhile = new while_node(
		new bin_expr(id, endFor, Operators.LessEqual),
		posStatementList,
		WhileCycleType.While);
	statement_list negStatementList = new statement_list();		// при отрицательном шаге
		negStatementList.Add(stmnts);
		negStatementList.Add( new assign(id, step, Operators.AssignmentAddition) );
	while_node negWhile = new while_node(
		new bin_expr(id, endFor, Operators.GreaterEqual),
		negStatementList,
		WhileCycleType.While);
	forStmnt.Add( new if_node(
		new bin_expr(step, new int32_const(0), Operators.Greater),
		posWhile,
		negWhile, 
		wholeSC));
	return forStmnt;
}

/* 	Возвращает многомерный массив, в котором при необходимости
	массив символов заменен на строку */	
public static type_definition GetArrWithStrInsteadCharArr(indexers_types lenList,
		SourceContext lenListSC, SourceContext wholeSC){
	List<type_definition> indxrs = lenList.indexers;
	diapason dp = indxrs[indxrs.Count - 1] as diapason;
	int32_const len = new int32_const();
	len.val = (dp.right as int32_const).val + 1;
	type_definition result = new string_num_definition(len, new ident("string", lenListSC), wholeSC);
	if (indxrs.Count > 1) {			// надо делать массив массивов ... строк
		indxrs.RemoveAt(indxrs.Count - 1);
		result = new array_type(lenList, result, wholeSC); 
	}
	return result;
}

/* 	Возвращает диапазон 0..Length-1, полученный по обероновской длине
	массива, и необходимый для паскалевского синтаксического узла */	
public static diapason GetDiapasonByArrLength(expression lenExpr, SourceContext lenSC){
	int32_const zero = new int32_const();
	zero.val = 0;
	int32_const max = (int32_const)lenExpr;
	max.val = max.val - 1;
	return new diapason(zero, max, lenSC);
}
}
}
