#### Подсказка при наведении мыши
На верхнем уровне реализуется в классе `TooltipServiceManager`. Основная логика реализована в методе `GetPopupHintText`. Вначале вызывается `FindExpressionFromAnyPosition` для получения нужного `expression` в виде строки.
Затем вызывается нужный парсер для получения дерева выражения (используется часть грамматики, связанная с нетерминалом parts). Если не получается распарсить, то делается попытка с удалением символа разыменования в выражении, пока неясно в какой ситуации это требуется.
Еще удаление разыменования присутствует в методе `GetDefinitionPosition` из `CodeCompletionActions`. 
Затем делается еще попытка с тем же выражением без скобочек. При этом, если без скобочек распарсить не удается, то вне зависимости от успешности парсинга полного `expression` возвращается `null`.
В конце проверяется был ли успешен обход дерева программы визитором (`DomSyntaxTreeVisitor`). Если это так, то в словаре откомпилированных модулей будет данный модуль и соответствующий ему `DomConverter`.
Тогда есть возможность вызвать метод `GetDescription` из этого класса, который выдаст нам описание выражения.

#### Подсказка параметров функции
На нажатие клавиш (скобки, квадратной скобки или запятой) реагирует `TextAreaKeyEventHandler` из класса `CodeCompletionKeyHandler`. Там создается экземпляр `DefaultInsightDataProvider`, который загружается в стек провайдеров. Информация для подсказки формируется в методе `SetupDataProvider` инсайт-провайдера. После выяснения кода на текущей подстроке вызывается `FindExpressionForMethod` из `LanguageInformation`.
Далее делается попытка парсинга стандартным парсером языка и наконец из `DomConverter` вызывается `GetNameOfMethod`, либо `GetIndex` в зависимости от нажатой клавиши.

#### Подсказка по нажатию клавиш
`CodeCompletionKeyHandler` реагирует на нажатие вызовом метода `ShowCompletionWindow`. В нем есть обращение к `GenerateCompletionDataWithKeyword` из класса `CodeCompletionProvider`. В этом методе выделяется нужная подстрока и есть обращение к методу `GetCompletionData`. 
**Логика этого метода следующая:**
Вначале выясняется контекст вызова Intellisense, а именно нажатые пользователем клавиши и т. п. Далее вызывается специальный метод для получения текста выражения, введенного пользователем. При этом
1) если был нажат `ctrl + space` или `shift + space` 
Вызывается `FindPattern` из `LanguageInformation` для получения "токена" до курсора. Если в процессе встретится точка, то вызывается `FindExpression`.  
2) если был нажат пробел после `new` 
Вызывается SkipNew для пропуска `new`  и поиска expression перед ним.
3) иначе, если пользователем была введена точка
вызывается `FindExpression` (c текущей позиции)

Ниже если был нажат `ctrl + space` не после точки и pattern пустой то в итоговый список `ICompletionData` добавляются ключевые слова языка.

Далее, если выражение не пусто, то строится дерево требуемого expression (это не требуется для `ctrl + space` и `shift + space`, кроме случая, когда они нажаты в цепочечном выражении с точками). Внутри метода построения дерева делается попытка вызова функции `GetTypeAsExpression`, а затем `GetExpression`. Если ничего не удалось построить и мы не в случае пробела после `new`, то нужно выходить из внешнего метода `GetCompletionData`. 

Далее получаем необходимую информацию о выражениях для нужного expression из таблицы символов (в специальном методе). Если визитор Intellisense успешно не обошел текущий модуль (тогда мы не получим соотв. экземпляр `DomConverter`), то
	 - Если у нас не случай `ctrl + space` или `shift + space` , нужно вернуть пустой массив `ICompletionData`.
	 - Для случая `uses` сразу добавляем массив стандартных модулей языка

Иначе, если у нас есть `DomConverter`:
	- Если пробел после `new`, то вызываем `GetTypes`
	- Иначе, если `uses`, то работаем со списком стандартных модулей + пр-в имен в случае семантического Intellisense.
	- Иначе, если была нажата точка, либо `ctrl + space` или `shift + space` сразу после точки, то вызываем `GetName` для получения всех возможных имен после точки
	- Иначе, если `ctrl + space`, то либо ищем имена, подходящие для помещения после точки, начинающиеся на `pattern` - `GetName` + `StartsWith`, либо просто ищем имя по его началу - `GetNameByPattern` 
	

В конце по полученным SymInfo строится результирующий список CompletionData (без повторений).

> [!NOTE] Замечание
>Случаи обработки `ctrl + space` и `shift + space` перед вызовом `GetCompletionData` обрабатываются не в классе `CodeCompletionKeyHandler`, а в отдельных классах файла CodeCompletionActions. У `ctrl + space` класс называется `CodeCompletionAllNamesAction`, а у  `shift + space` - `CodeCompletionShiftSpaceActions`. При этом для `shift + space` в вышеупомянутом классе предварительно проверяются еще два сценария его применения помимо подсказки локальных имен, реализованной в `GetCompletionData`. Эти сценарии - это автодополнение xml-комментария и автодополнение выражений из файла template.pct языка.

#### Подсказка по первому символу выражения
Данная ситуация обрабатывается в последней ветке метода `TextAreaKeyEventHandler` класса `CodeCompletionKeyHandler`. Оттуда цепочка вызовов приходит к методу `GetCompletionDataByFirst`. В этом методе мы так же как в `GetCompletionData` вначале выясняем контекст, а именно должен ли в данной позиции быть введен тип данных, либо мы находимся в секции "uses". Если мы не в "uses", то можно добавить в результирующий список подсказок нужные ключевые слова. 

Далее получаем нужную информацию из таблицы символов в специальном методе по следующим правилам:
Если `DomConverter` данного модуля получить невозможно, то в случае "uses" можно добавить список стандартных модулей.
Если же `DomConverter` получен, то
	- если нужно подсказать типы данных вызывается `GetTypeByPattern`
	- если секция "uses", то либо вызывается `GetNamespaces` когда включен семантический Intellisense, либо просто добавляется список стандартных модулей
	- во всех остальных ситуациях вызывается `GetNameByPattern`, причем ему передается пустой `pattern`

После этого в специальном методе по полученным SymInfo строим результирующий список подсказок без повторений. При этом назначается значение `defaultCompletionElement` (подсказки, которая выбирается по умолчанию). Это будет либо прошлый выбранный вариант подсказки, либо если такого не найдется, то минимальный элемент по длине.
#### Переход к определению символа
В `CodeCompletionActions` есть специальный класс `GotoAction`, в котором вызывается метод `GoToDefinition`. В этом методе используется метод `GetDefinitionPosition`, который в свою очередь (тоже косвенно) использует `FindExpressionFromAnyPosition` из `LanguageInformation` и `GetDefinition` из `CodeCompletionProvider`. Последний вышеупомянутый метод является оберткой над `GetDefinition` из `DomConverter`.