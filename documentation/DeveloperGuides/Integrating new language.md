 ### Шаг 1
Необходимо создать папку, называющуюся так же, как Ваш язык в папке *LanguagePlugins*, расположенной в корне репозитория. Далее создать в ней два обязательных проекта. Это проект парсера Вашего языка, а также проект, содержащий класс Вашего языка (унаследованный от класса `BaseLanguage`, находящегося в стандартном проекте `LanguageIntegrator`). 

Для совместимости целевой платформой Ваших проектов должна быть *.NET Framework 4.0*. В свойствах проекта и для Release, и для Debug версии должен быть выбран выходной путь `..\..\..\bin\`. 

> [!NOTE] Соглашение об именовании
> Чтобы платформа PascalABC.NET смогла подключить библиотеку с Вашим языком нужно, чтобы имя Вашей основной сборки (содержащей наследника `BaseLanguage`) заканчивалось на "LanguageInfo" (то есть имело вид \*LanguageInfo.dll). Имя наследника `BaseLanguage` должно иметь постфикс "Language".

### Шаг 2
В проекты Вы добавляете все необходимые для работы ссылки. Вам точно понадобятся ссылки на проекты `ParserTools`, `Errors`, `SyntaxTree` в проекте Вашего парсера и на проекты `LanguageIntegrator`, `SyntaxVisitors`, `TreeConverter` в проекте с наследником `BaseLanguage`. 
### Шаг 3
Вам нужно унаследовать Ваш парсер (который является оберткой над GPPG парсером) от класса `BaseParser`, либо напрямую реализовать интерфейс `IParser`, если Вы не хотите пользоваться функциональностью из `BaseParser`.

Класс `BaseParser` содержит абстрактные методы, обязательные к реализации, самый главный из которых называется `BuildTreeInNormalMode`. Он отвечает за построение синтаксического дерева программы при обычном процессе компиляции. Остальные методы относятся к *Intellisense* и их реализация может быть пустой на первое время. 

Для реализации `BuildTreeInNormalMode` Вам потребуется вызвать в этом методе сгенерированный GPPG парсер Вашего языка. Возвращаемое значение должно быть корнем полученного в результате парсинга синтаксического дерева.

Для реализации парсера Вы можете также использовать такие базовые абстрактные классы как `BaseKeywords` и `BaseParserTools`.
### Шаг 4
В сделанном Вами наследнике `BaseLanguage` Вы пишете конструктор, который передает в `base()` следующие параметры:
1) имя языка, версия языка, строка с указанием авторских прав
2) класс "базы данных" языка, хранящий информацию в основном необходимую для Intellisense (наследник `BaseLanguageInformation`). На первое время можно использовать PascalABCLangaugeInformation.
3) парсер Вашего языка (наследник `BaseParser`)
4) парсер XML-комментариев (если его нет, то можно передавать `null`)
5) список преобразователей синтаксического дерева с одним обязательным элементом (для него можно взять стандартную базовую версию под названием `DefaultSyntaxTreeConverter`)
6) флаг дающий системе Intellisense информацию о том, нужно ли запускать преобразователи синтаксического дерева
7) расширения файлов Вашего языка
8) чувствительность к регистру
9) имена стандартных модулей языка

Также Вы реализуете метод `SetSemanticConstants`, в котором задаете необходимые  параметры (значения переменных) из файла *SemanticRulesConstants.cs*  (проект TreeConverter). 

И наконец, реализуете метод `SetSyntaxTreeToSemanticTreeConverter`, в котором создаете новый экземпляр преобразователя синтаксического дерева в семантическое (присваиваете его свойству `SyntaxTreeToSemanticTreeConverter`). Для простых языков в качестве преобразователя Вам подойдет стандартный `syntax_tree_visitor`.

---
Если описанные выше шаги проделаны правильно, то при запуске оболочки в окне сообщений компилятора Вы увидите информацию о Вашем языке в списке подключенных. Если же в этом окне будет выводиться ошибка, связанная с подключением сборки Вашего языка, то обратитесь к файлу *log.txt* в папке `bin` (запись в лог ведется только в режиме Debug).