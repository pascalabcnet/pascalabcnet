<html>

<head>
<object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e">
<param name="Keyword" value="Размерные типы">
<param name="Keyword" value="Ссылочные типы">
</object>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<title></title>
<link rel="StyleSheet" href="../../default.css">
</head>

<body>
<H1>Размерные и ссылочные типы</H1>
<p>Большинство типов в <strong>PascalABC.NET</strong> подразделяются на две большие группы: <i><b>размерные</b></i> и 
<i><b>ссылочные</b></i>. </p>
<p>К размерным относятся все простые типы и <a href="records.html">записи</a>. Более 
точно, все размерные типы наследуются от .NET-типа System.ValueType. </p>
<p>К ссылочным типам относятся <a href="string.html">строки</a>,
<a href="dynamicarrays.html">динамические массивы</a>, <a href="tuples.html">кортежи</a>, 
<a href="../Classes/index_classes.html">классы</a>, <a href="sequences.html">
последовательности</a> и 
<a href="proctype.html">процедурный тип</a>. Более точно, все ссылочные типы наследуются от .NET-типа 
System.Object и не наследуются от System.ValueType.</p>
<p>Размерные и ссылочные типы отличаются следующими характеристиками:</p>
<ul>
	<li>выделение памяти </li>
	<li>управление памятью</li>
	<li>присваивание</li>
	<li>сравнение</li>
	<li>передача в подпрограммы</li>
</ul>
<p>Кроме того, в PascalABC.NET имеется несколько типов, унаследованных от Delphi 
Object Pascal, которые трудно отнести к размерному или ссылочному типу. Это
<a href="staticarrays.html">статические массивы</a>, <a href="sets.html">
множества</a>, <a href="valuestrings.html">размерные строки</a> и
<a href="files.html">файлы</a>. По представлению в памяти они относятся к 
ссылочному типу, но по поведению (присваивание, сравнение, передача в 
подпрограммы) - к размерному.</p>
<p>Размерные типы более эффективны при вычислениях: они занимают меньше памяти и 
операции, выполняемые над небольшими размерными типами, максимально эффективны. 
Ссылочные типы обладают большей гибкостью: память под них выделяется динамически 
в процессе работы программы и освобождается автоматически когда объект 
ссылочного типа перестаёт использоваться.</p>
<h2>Выделение памяти</h2>
<p>Память под переменную размерного типа выделяется на программном стеке. Для 
глобальных переменных память выделяется при запуске программы, для локальных - в 
момент вызова подпрограммы. При этом переменная размерного типа хранит значение этого 
типа.</p>
<blockquote>
	<p><code><strong>var</strong> i: integer; // под i выделяется память на 
	программном стеке<br>
	i := 5; </code></p>
</blockquote>
<p>Переменная ссылочного типа хранит ссылку на объект некоторого 
класса в динамической памяти. Если она не инициализирована, то хранит 
специальное значение nil (нулевая ссылка). Для инициализации ссылочных 
переменных используется вызов <a href="../Classes/constrdestr.html">конструктора</a> соответствующего класса:</p>
<blockquote>
	<p><code><strong>type</strong> Person = <strong>auto class<br> </strong>&nbsp; 
	name: string;<br>&nbsp; age: integer;<br><strong>end;</strong></code></p>
	<p><code><strong>var </strong>p: Person; // p хранит значение nil, память 
	под объект не выделена<br>p := new Person('Иванов',20); // конструктор 
	выделяет память под объект и записывает ссылку на него в переменную p </code>&nbsp;</p>
</blockquote>
<h2>Особенности PascalABC.NET</h2>
<p>Строки в <strong>PascalABC.NET</strong> инициализируются по умолчанию не 
значением nil, а пустой строкой.</p>
<h2>Присваивание</h2>
<p>При присваивании переменных размерного типа копируется значение этого типа. </p>
<blockquote>
	<p><code><strong>type </strong>Point3 = <strong>record</strong><br> &nbsp; 
	x,y,z: real;<br><strong>end;</strong></code></p>
	<p><code><strong>var </strong>p1,p2: Point3;<br>p1.x := 1; p1.y := 2; p1.z 
	:= 3; <br>p2 := p1;&nbsp; // копируются все поля<br>Print(p2); // (1,2,3)<br>
	p1.x := 4; p1.y := 5; p1.z := 6;<br>Print(p2); // (1,2,3) - p2 не меняется, 
	т.к. занимает на стеке другую память</code></p>
</blockquote>
<p>При присваивании переменных ссылочного типа копируется ссылка, в итоге после присваивания обе ссылки ссылаются на один объект в 
динамической памяти:</p>
<blockquote>
	<p><code><strong>type </strong>Point3 = <strong>auto class</strong> <br> &nbsp; 
	x,y,z: real;<br><strong>end;</strong></code></p>
	<p><code><strong>var </strong>p1,p2: Point3; // переменные хранят нулевую 
	ссылку nil<br>p1 := new Point3(1,2,3);<br>p2 := p1;&nbsp; // копируется 
	ссылка, после чего p2 ссылается на тот же объект, что и p1<br>Print(p2); // 
	(1,2,3)<br>p1.x := 4; p1.y := 5; p1.z := 6;<br>Print(p2); // (4,5,6) - 
	объект поменялся, p2 ссылается на тот же объект, что и p1</code></p>
</blockquote>
<p>Статические массивы, множества и размерные строки при присваивании ведут себя 
как размерные типы. Так, при присваивании одного статического массива другому копируются 
все элементы: </p>
<blockquote>
	<p><code><strong>var </strong>a,a1: <strong>array</strong> [1..1000000]
	<strong>of</strong> integer; <br>a1 := a; // копируются все 1000000 
	элементов (долго)</code></p>
</blockquote>
<h2>Сравнение на равенство</h2>
<p>Сравнение на равенство и на неравенство объектов размерного типа сравнивает их значения. В 
частности, две переменные типа запись равны если равны все поля этих записей.</p>
<blockquote>
	<p><code><strong>type </strong>PersonRec = <strong>record</strong><br>&nbsp; 
	name: string;<br>&nbsp; age: integer;<br><strong>end;<br>var </strong>p,p1: 
	PersonRec;<br>p.name := 'Иванов'; p.age := 20;<br>p1.name := 'Иванов'; 
	p1.age := 20;<br>writeln(p1 = p); // True</code></p>
</blockquote>
<p>Две переменные ссылочного типа по умолчанию равны если они 
ссылаются на один и тот же объект.</p>
<blockquote>
	<p><code><strong>type </strong>Person = <strong>auto class<br> </strong>&nbsp; 
	name: string;<br>&nbsp; age: integer;<br><strong>end</strong>;<strong><br>var </strong>p := new Person('Иванов',20); <br><strong>var
	</strong>p1 := new Person('Иванов',20); <br>writeln(p1 = p); // False</code>&nbsp;</p>
</blockquote>
<p>Однако операцию сравнения можно <a href="../Classes/operoverloading.html">
перегрузить</a>. Например, для строк и кортежей сравнение на равенство переопределено 
так, что сравниваются не ссылки, а значения.</p>
<h2>Передача в подпрограммы</h2>
<p>При передаче размерных типов по значению происходит копирование значения 
фактического параметра в переменную-формальный параметр. Если размерный тип 
имеет большой размер, это может занимать продолжительное время, поэтому 
размерный тип в этом случае передаётся по ссылке на константу:</p>
<blockquote>
	<p><code><strong>type </strong>Point3 = <strong>record</strong><br> &nbsp; 
	x,y,z: real;<br><strong>end;</strong></code></p>
	<p><code><strong>procedure</strong> 
	PrintPoint(<strong>const</strong> p: Point3);<br><strong>begin</strong><br>&nbsp; Print(p.x,p.y,p.z)<br><strong>end</strong>;</code></p>
</blockquote>
<p>Ссылочные типы передаются в подпрограмму, как правило, по значению. При 
передаче таких параметров происходит копирование ссылки, в результате формальный 
и фактический параметр будут ссылаться на один объект.</p>
<blockquote>
	<p><code><strong>procedure</strong> 
	Change666(a: <strong>array of</strong> integer);<br><strong>begin</strong><br>&nbsp;
	a[0] := 666;<br><strong>end</strong>;</code></p>
</blockquote>
<p>При этом в результате изменения формального параметра внутри подпрограммы 
меняется и содержимое соответствующего фактического параметра при вызове 
подпрограммы.</p>
<p>Ссылочные типы передаются в подпрограмму по ссылке только в случае если сама 
ссылка меняется внутри подпрограммы:</p>
<blockquote>
	<p><code><strong>procedure</strong> 
	CreateA(<strong>var</strong> a: <strong>array of</strong> integer);<br><strong>begin</strong><br>&nbsp;
	a := new integer[10];<br><strong>end</strong>;</code></p>
</blockquote>
<p>Статические массивы, размерные строки и множества при передаче в подпрограммы 
ведут себя как размерные типы. Например, неэффективно пытаться передать в 
подпрограмму статический массив по значению, поскольку происходит копирование 
большого объёма данных. Поэтому статические массивы всегда передаются по ссылке:</p>
<blockquote>
	<p><code><strong>type</strong> Arr = <strong>array</strong> [1..100] <strong>
	of</strong> integer;</code></p>
	<p><code><strong>procedure</strong> 
	PrintArray(<strong>const</strong> a: Arr; n: integer);<br><strong>begin</strong><br>&nbsp;
	<strong>for</strong> <strong>var</strong> i:=1 <strong>to</strong> 
	n <strong>do</strong><br>&nbsp;&nbsp;&nbsp; Print(a[i])<br><strong>end</strong>;</code></p>
</blockquote>
<h2>Управление памятью</h2>
<p>Размерные типы распределяются на программном стеке, поэтому не нуждаются в 
специальном управлении памятью. Под глобальные размерные переменные память 
распределена всё время работы программы. Под локальные размерные переменные 
память выделяется в момент вызова подпрограммы, а освобождается в момент 
завершения работы этой подпрограммы.</p>
<p><a href="../MemoryManagement/index_memory.html">Управление памятью для ссылочных типов</a> осуществляется автоматически 
сборщиком мусора. Сборщик мусора запускается в неопределенный момент времени 
когда управляемой памяти перестаёт хватать. Он возвращает в пул неиспользуемой 
памяти те объекты, на которые больше никто не ссылается, после чего 
дефрагментирует оставшуюся память, в результате чего динамическая память всегда 
дефрагментирована и ее выделение при вызове конструктора происходит практически 
мгновенно.</p>
<p>Статические массивы, размерные строки, множества и файлы с точки зрения 
распределения памяти относятся к ссылочным и память, занимаемая значениями этого 
типа, также управляется сборщиком мусора.</p>
</body>

</html>