<html>

<head>
<object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e">
<param name="Keyword" value="set">
<param name="Keyword" value="HashSet">
<param name="Keyword" value="SortedSet">
<param name="Keyword" value="of">
</object>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<title></title>
<link rel="StyleSheet" href="../../default.css">
</head>

<body>
<H1>Множества</H1>
<p>Множество представляет собой набор элементов одного 
типа. Элементы множества считаются неупорядоченными; 
каждый элемент может входить во множество не более одного раза. </p>
<p>В PascalABC.NET имеются <strong>встроенные множества</strong> и множества 
библиотеки .NET: HashSet&lt;T&gt; (неупорядоченное, скорость операций вставки, 
удаления, принадлежности - O(1)) и SortedSet&lt;T&gt; (упорядоченное, скорость 
операций вставки, удаления, принадлежности - O(log(n))).</p>
<p>Тип
встроенного множества 
описывается следующим образом:</p>
<blockquote>
	<p><code><b>set of </b></code><code class="codeit">базовый тип</code></p>
</blockquote>
<p>В качестве базового может быть <b><font color="#FF0000"><i>любой</i></font></b> тип, 
в том числе строковый и классовый. Исключение составляют типы указателей.</p>
<p>Например:</p>
<blockquote>
	<p><code><b>type</b> <br>
&nbsp; ByteSet = <b>set</b> <b>of</b> byte;<br>
&nbsp; StringSet = <b>set</b> <b>of</b> 
	string;<br>
&nbsp; Digits = <b>set</b> <b>of</b> '0'..'9';<br>
&nbsp; SeasonSet = <b>set</b> <b>of </b>(Winter,Spring,Summer,Autumn);<br>
&nbsp; PersonSet = <b>set of</b> Person;&nbsp; </code></p>
</blockquote>
<p>Элементы базового типа сравниваются на равенство следующим образом: у простых 
типов, строк и указателей сравниваются значения, у структурированных и у классов 
- значения всех элементов или полей. Однако, если поля относятся к ссылочному 
типу, то сравниваются только их адреса (неглубокое сравнение). </p>
<p>Чтобы сконструировать значение типа встроенное множество, используется так называемый конструктор 
множества, имеющий вид:</p>
<blockquote>
	<p><code>[</code><code class="codeit">список значений</code><code>]</code></p>
</blockquote>
<p>где в списке могут перечисляться через запятую либо  
выражения базового типа, либо (для порядковых типов) их диапазоны в виде <code>a..b</code>, 
где <code>a</code> и <code>b</code> 
- выражения базового типа. Например:</p>
<blockquote>
	<p><code><b>var</b> <br>
	&nbsp; bs: ByteSet := [1,3,5,20..25];<br>
	&nbsp; fios: StringSet := ['Иванов','Петров','Сидорова'];</code></p>
</blockquote>
<p>Значения в списке могут отсутствовать, тогда множество является пустым:</p>
<blockquote>
	<p><code>bs:=[];</code></p>
</blockquote>
<p>Пустое множество-константа <code>[]</code> совместимо по присваиванию с множеством любого типа. 
Однако тип пустого множества-константы не выводится автоматически: </p>
<blockquote>
	<p><code><strong>var</strong> bs:=[]; // Ошибка!</code></p>
</blockquote>
<p>Множество, задаваемое конструктором множества, может иметь элементы различных 
типов, например:</p>
<blockquote>
	<p><code>[1..4,5.5,'c','xyz',Winter..Autumn]</code></p>
</blockquote>
<p>В этом случае вычисляется наиболее общий тип, и он объявляется базовым типом 
множества. Например:</p>
<blockquote>
	<p><code>[1..4,5.5] // <strong>set of</strong> real<br>['1','abc'] //
	<strong>set of</strong> string<br>[1,'1'] // <strong>set of</strong> object</code></p>
</blockquote>
<p>Для множеств имеет место структурная эквивалентность типов. </p>
<p>Множества целых и множества на базе типа и его диапазонного подтипа или на 
базе двух диапазонных типов одного базового типа неявно преобразуются друг к 
другу. Если при присваивании s := s1 &nbsp;во множестве s1 
содержатся элементы, которые не входят в диапазон значений базового типа для 
множества s, то они отсекаются.</p>
<p>Например:</p>
<blockquote>
	<p><code><b>var</b> st: <b>set</b> <b>of</b> 3..9;<br>
	...<br>
	st := [1..5,8,10,12]; // в st попадут значения 
	[3..5,8]</code></p>
</blockquote>
<p>Операция <code><b>in</b></code> проверяет 
принадлежность элемента множеству:</p>
<blockquote>
	<p><code><b>if</b> Wed <b>in</b> bestdays <b>then</b> ...</code></p>
</blockquote>
<p>Для множеств определены 
операции <code>+</code> (объединение), <code>-</code> 
(разность), <code>*</code> (пересечение),
= (равенство), <code>&lt;&gt;</code> 
(неравенство), &lt;= (нестрогое вложение), &lt; (строгое вложение), &gt;= (нестрого 
содержит) и &gt; (строго содержит). </p>
<p>Процедура <code>Write</code> при выводе множества выводит все его элементы. 
Например,</p>
<blockquote>
	<p><code>Write(['Иванов','Петров','Сидорова']);</code></p>
</blockquote>
<p>выведет <code>['Иванов','Петров','Сидорова']</code>, при этом 
данные, если это возможно, будут отсортированы по возрастанию.</p>
<p>Для перебора всех элементов множества можно использовать цикл <code><b>
foreach</b></code>, данные перебираются в некотором внутреннем 
порядке:</p>
<blockquote>
	<p><code><b>foreach</b> <strong>var</strong> s <b>in</b> fios <b>do</b><br>
&nbsp; Write(s,' ');</code></p>
</blockquote>
<p>Для добавления элемента <code>x</code> к множеству <code>s</code> 
используется конструкция <code>s += [x]</code> или стандартная процедура
<code>Include</code>: <code>Include(s,x)</code>. Для удаления элемента <code>x</code> 
из множества <code>s</code> используется конструкция <code>s -= [x]</code> 
или стандартная процедура <code>Exclude</code>: <code>Exclude(s,x)</code>.</p>
</body>

</html>
