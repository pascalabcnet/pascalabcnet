<HTML><HEAD><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e">
<param name="Keyword" value="Between">
<param name="Keyword" value="IndicesOf">
<param name="Keyword" value="InRange">
<param name="Keyword" value="Inverse">
<param name="Keyword" value="IsInteger">
<param name="Keyword" value="IsMatch">
<param name="Keyword" value="IsReal">
<param name="Keyword" value="Left">
<param name="Keyword" value="Matches">
<param name="Keyword" value="MatchValue">
<param name="Keyword" value="MatchValues">
<param name="Keyword" value="RandomElement">
<param name="Keyword" value="ReadInteger">
<param name="Keyword" value="ReadReal">
<param name="Keyword" value="ReadWord">
<param name="Keyword" value="RegexReplace">
<param name="Keyword" value="Remove">
<param name="Keyword" value="Replace">
<param name="Keyword" value="Right">
<param name="Keyword" value="Slice">
<param name="Keyword" value="ToBigInteger">
<param name="Keyword" value="ToInteger">
<param name="Keyword" value="ToIntegers">
<param name="Keyword" value="ToLines">
<param name="Keyword" value="ToReal">
<param name="Keyword" value="ToReals">
<param name="Keyword" value="ToWords">
<param name="Keyword" value="TryToInteger">
<param name="Keyword" value="TryToReal"></object>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><link rel="StyleSheet" href="../../../default.css">
</HEAD><body><H1>Методы расширения типа string</H1>
<table border=0 cellpadding=5><tr><td><code><b>function</b> Between(Self: string; a, b: string): boolean;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Возвращает True если строка находится между двумя другими (лексикографическое сравнение)</td></tr>
<tr><td><code><b>function</b> IndicesOf(Self, SubS: string; overlay: boolean := False): <b>sequence </b>  <b>of</b> integer;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Возвращает последовательность индексов вхождений подстроки в основную строкуПараметр overlay определяет, разрешены ли перекрытия вхождений подстрок</td></tr>
<tr><td><code><b>function</b> InRange(Self: string; a, b: string): boolean;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Возвращает True если строка находится в диапазоне [a,b] (лексикографическое сравнение)</td></tr>
<tr><td><code><b>function</b> Inverse(Self: string): string;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Возвращает инверсию строки</td></tr>
<tr><td><code><b>function</b> IsInteger(Self: string): boolean;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Возвращает True если строку можно преобразовать в целое</td></tr>
<tr><td><code><b>function</b> IsMatch(Self: string; reg: string; options: RegexOptions := RegexOptions.None): boolean;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Удовлетворяет ли строка регулярному выражению</td></tr>
<tr><td><code><b>function</b> IsReal(Self: string): boolean;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Возвращает True если строку можно преобразовать в вещественное</td></tr>
<tr><td><code><b>function</b> Left(Self: string; length: integer): string;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Возвращает подстроку, полученную вырезанием из строки length самых левых символов</td></tr>
<tr><td><code><b>function</b> Matches(Self: string; reg: string; options: RegexOptions := RegexOptions.None): <b>sequence </b>  <b>of</b> Match;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ищет в указанной строке все вхождения регулярного выражения и возвращает их в виде последовательности элементов типа Match</td></tr>
<tr><td><code><b>function</b> MatchValue(Self: string; reg: string; options: RegexOptions := RegexOptions.None): string;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ищет в указанной строке первое вхождение регулярного выражения и возвращает его в виде строки</td></tr>
<tr><td><code><b>function</b> MatchValues(Self: string; reg: string; options: RegexOptions := RegexOptions.None): <b>sequence </b>  <b>of</b> string;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ищет в указанной строке все вхождения регулярного выражения и возвращает их в виде последовательности строк</td></tr>
<tr><td><code><b>function</b> RandomElement(Self: string): char;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Возвращает случайный символ строки</td></tr>
<tr><td><code><b>function</b> ReadInteger(Self: string; <b>var</b> from: integer): integer;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Считывает целое из строки начиная с позиции from и устанавливает from за считанным значением</td></tr>
<tr><td><code><b>function</b> ReadReal(Self: string; <b>var</b> from: integer): real;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Считывает вещественное из строки начиная с позиции from и устанавливает from за считанным значением</td></tr>
<tr><td><code><b>function</b> ReadWord(Self: string; <b>var</b> from: integer): string;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Считывает слово из строки начиная с позиции from и устанавливает from за считанным значением</td></tr>
<tr><td><code><b>function</b> RegexReplace(Self: string; reg, repl: string; options: RegexOptions := RegexOptions.None): string;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Заменяет в указанной строке все вхождения регулярного выражения указанной строкой замены и возвращает преобразованную строку</td></tr>
<tr><td><code><b>function</b> RegexReplace(Self: string; reg: string; repl: Match-&gt;string; options: RegexOptions := RegexOptions.None): string;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Заменяет в указанной строке все вхождения регулярного выражения указанным преобразованием замены и возвращает преобразованную строку</td></tr>
<tr><td><code><b>function</b> Remove(Self: string; <b>params</b> targets: <b>array</b>  <b>of</b> string): string;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Удаляет в строке все вхождения указанных строк</td></tr>
<tr><td><code><b>function</b> Replace(Self: string; oldStr,newStr: string; count: integer): string;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Заменяет count вхождений подстроки oldStr на подстроку newStr в исходной строке</td></tr>
<tr><td><code><b>function</b> Right(Self: string; length: integer): string;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Возвращает подстроку, полученную вырезанием из строки length самых правых символов</td></tr>
<tr><td><code><b>function</b> Slice(Self: string; from, step: integer): string;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Возвращает срез строки от индекса from с шагом step</td></tr>
<tr><td><code><b>function</b> Slice(Self: string; from, step, count: integer): string;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Возвращает срез строки от индекса from с шагом step длины не более count</td></tr>
<tr><td><code><b>function</b> ToBigInteger(Self: string): BigInteger;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Преобразует строку в BigInteger</td></tr>
<tr><td><code><b>function</b> ToInteger(Self: string): integer;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Преобразует строку в целое</td></tr>
<tr><td><code><b>function</b> ToInteger(Self: string; defaultvalue: integer): integer;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Преобразует строку в целоеПри невозможности преобразования возвращается defaultvalue</td></tr>
<tr><td><code><b>function</b> ToIntegers(Self: string): <b>array</b>  <b>of</b> integer;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Преобразует строку в массив целых</td></tr>
<tr><td><code><b>function</b> ToIntegers(Self: string; N: integer): <b>array</b>  <b>of</b> integer;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Считывает из строки массив из N целых</td></tr>
<tr><td><code><b>function</b> ToLines(Self: string): <b>array</b>  <b>of</b> string;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Преобразует многострочную строку в массив строк</td></tr>
<tr><td><code><b>function</b> ToReal(Self: string): real;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Преобразует строку в вещественное</td></tr>
<tr><td><code><b>function</b> ToReal(Self: string; nfi: NumberFormatInfo): real;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Преобразует строку в вещественное</td></tr>
<tr><td><code><b>function</b> ToReal(Self: string; DecimalSeparator: string): real;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Преобразует строку в вещественное</td></tr>
<tr><td><code><b>function</b> ToReal(Self: string; defaultvalue: real): real;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Преобразует строку в вещественноеПри невозможности преобразования возвращается defaultvalue</td></tr>
<tr><td><code><b>function</b> ToReals(Self: string): <b>array</b>  <b>of</b> real;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Преобразует строку в массив вещественных</td></tr>
<tr><td><code><b>function</b> ToReals(Self: string; nfi: NumberFormatInfo): <b>array</b>  <b>of</b> real;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Преобразует строку в массив вещественных</td></tr>
<tr><td><code><b>function</b> ToReals(Self: string; DecimalSeparator: string): <b>array</b>  <b>of</b> real;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Преобразует строку в массив вещественных</td></tr>
<tr><td><code><b>function</b> ToWords(Self: string; <b>params</b> delim: <b>array</b>  <b>of</b> char): <b>array</b>  <b>of</b> string;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Преобразует строку в массив слов</td></tr>
<tr><td><code><b>function</b> ToWords(Self: string; delims: string := ' '): <b>array</b>  <b>of</b> string;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Преобразует строку в массив слов, используя в качестве разделителей символы из строки delims</td></tr>
<tr><td><code><b>function</b> TryToInteger(Self: string; <b>var</b> value: integer): boolean;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Преобразует строку в целое и записывает его в value.При невозможности преобразования возвращается False</td></tr>
<tr><td><code><b>function</b> TryToReal(Self: string; <b>var</b> value: real): boolean;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Преобразует строку в вещественное и записывает его в value.При невозможности преобразования возвращается False</td></tr>
</table>
</body></HTML>