<html>

<head>
<object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e">
        <param name="Keyword" value="PNode">
        <param name="Keyword" value="TNode">
        <param name="Keyword" value="Node">
        <param name="Keyword" value="Task">
        <param name="Keyword" value="GetB">
        <param name="Keyword" value="GetC">
        <param name="Keyword" value="GetN">
        <param name="Keyword" value="GetR">
        <param name="Keyword" value="GetS">
        <param name="Keyword" value="GetP">
        <param name="Keyword" value="PutB">
        <param name="Keyword" value="PutC">
        <param name="Keyword" value="PutN">
        <param name="Keyword" value="PutR">
        <param name="Keyword" value="PutS">
        <param name="Keyword" value="PutP">
        <param name="Keyword" value="GetBoolean">
        <param name="Keyword" value="GetChar">
        <param name="Keyword" value="GetInt">
        <param name="Keyword" value="GetReal">
        <param name="Keyword" value="GetString">
        <param name="Keyword" value="GetNode">
        <param name="Keyword" value="Put">
        <param name="Keyword" value="Show">
        <param name="Keyword" value="ShowLine">
        <param name="Keyword" value="SetPrecision">
        <param name="Keyword" value="HideTask">
</object>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<title></title>
<link rel="StyleSheet" href="../../default.css">
</head>

<body>
<h1>Модуль PT4</h1>
<hr>
<p>Описанные в данном разделе типы и процедуры
будут доступны в программе, если к ней с помощью оператора <code><b>uses</b></code>
подключен модуль <code>PT4</code> (см. <a href="..\CheckedTasks\checkedtasks1.htm">пример</a> программы, использующей задачник
<b>Programming Taskbook</b>).

<a name="node"></a><h2>Дополнительные типы данных PNode и TNode</h2>
<hr noshade size="1">
<blockquote>
<code><b>type</b><br>
&nbsp;  PNode = ^TNode;<br>
&nbsp;  TNode = <b>record</b><br>
&nbsp;&nbsp;    Data: integer;<br>
&nbsp;&nbsp;    Next: PNode;<br>
&nbsp;&nbsp;    Prev: PNode;<br>
&nbsp;&nbsp;    Left: PNode;<br>
&nbsp;&nbsp;    Right: PNode;<br>
&nbsp;&nbsp;    Parent: PNode;<br>
&nbsp;  <b>end</b>;
</code></blockquote>

<p>Типы <code>PNode</code> и <code>TNode</code> используются в заданиях групп Dynamic и Tree. В заданиях на стеки и очереди
(Dynamic1&#150;Dynamic28) при работе с записями типа <code>TNode</code> используются только поля <code>Data</code> и <code>Next</code>;
в заданиях на двусвязные списки (Dynamic29&#150;Dynamic80) используются поля <code>Data</code>, <code>Next</code> и <code>Prev</code>.
В большинстве заданий на бинарные деревья (группа Tree) используются поля <code>Data</code>, <code>Left</code> и <code>Right</code>;
в заданиях на обработку бинарных деревьев с обратной связью (Tree48&#150;Tree56 и Tree70&#150;Tree71) дополнительно используется
поле <code>Parent</code>.
</p>
<p>Все исходные и результирующие данные-указатели в заданиях имеют тип <code>PNode</code>;
их ввод и вывод должен осуществляться с помощью процедур <code>GetP</code> и <code>PutP</code> (в системе <b>PascalABC.NET</b>
указатели, как и другие данные,
можно получать из задачника и передавать ему с помощью стандартных процедур ввода-вывода <code>read</code>
и <code>write</code>).
</p>
<p>В программе учащегося не следует повторно описывать типы <code>PNode</code> и <code>TNode</code>.
</p>


<h2>Инициализация задания, ввод&#150;вывод данных</h2>
<a name="task"></a><hr noshade size="1">
<blockquote>
<code><b>procedure</b> Task(Name: <b>string</b>);
</code></blockquote>
<p>Процедура инициализирует задание с именем <code>Name</code>. Она должна
вызываться в начале программы, выполняющей это задание (до вызова 
процедур ввода-вывода). Если в программе, подключившей
модуль <code>PT4</code>, не указана процедура <code>Task</code>, то при запуске программы
будет выведено окно с сообщением &laquo;<i>Не вызвана процедура Task с
именем задания</i>&raquo;.</p>
<p>
Имя задания <code>Name</code> должно включать имя темы и порядковый
номер в пределах темы (например, <code>'Begin3'</code>). Регистр букв в имени темы
может быть произвольным. Если указана неверная тема задания, то 
программа выведет сообщение об ошибке, в котором будут 
перечислены названия всех имеющихся тем. Если указан 
недопустимый номер задания, то программа выведет сообщение, в 
котором будет указан диапазон допустимых номеров для данной темы. 
Если после имени задания в параметре <code>Name</code> указан символ <code>?</code>
(например, <code>'Begin1?'</code>), то программа будет работать в
<a href="Demo.html"><i>демонстрационном режиме</i></a>.
</p>
<p>Начиная с версии 4.8, процедура <code>Task</code> может также использоваться для
генерации и вывода на экран html-страницы с текстом задания или группы заданий.
Для этого необходимо указать в качестве параметра <code>Name</code> имя конкретного задания или группы
заданий и символ <code>#</code>, например, <code>'Begin3#'</code> или
<code>'Begin#'</code>. Дополнительные сведения о генерации html-страниц с описаниями заданий приводятся
в разделе, посвященном демонстрационному режиму задачника.
</p>


<p>Если при первом вызове процедуры <code>Task</code> в параметре не указывается символ <code>#</code>, то
все последующие вызовы процедуры <code>Task</code> игнорируются. Если при первом вызове процедуры
<code>Task</code> в параметре указывается символ <code>#</code>,
то игнорируются все последующие вызовы процедуры <code>Task</code>, не содержащие этот символ.
С помощью нескольких вызовов процедуры <code>Task</code>, содержащей в параметре символ <code>#</code>, можно обеспечить
генерацию html-страницы с описанием нескольких групп заданий, причем в каждой группе при этом можно отображать только
некоторые задания.
</p>

<hr noshade size="1">
<blockquote>
<code>
<b>procedure</b> GetB(<b>var</b> X: boolean);<br>
<b>procedure</b> GetC(<b>var</b> X: char);<br>
<b>procedure</b> GetN(<b>var</b> X: integer);<br>
<b>procedure</b> GetR(<b>var</b> X: real);<br>
<b>procedure</b> GetS(<b>var</b> X: string);<br>
<b>procedure</b> GetP(<b>var</b> X: PNode);<br>
</code></blockquote>
<p>
Процедуры обеспечивают ввод исходных данных в программу,
выполняющую учебное задание. Они должны вызываться после вызова 
процедуры <code>Task</code>;
в случае их вызова до вызова процедуры <code>Task</code> при запуске программы
будет выведено сообщение об ошибке &laquo;<i>В начале программы не
вызвана процедура Task с именем задания</i>&raquo;.</p>

<p>Используемая процедура ввода должна соответствовать типу
очередного элемента исходных данных; в противном случае выводится 
сообщение об ошибке &laquo;<i>Неверно указан тип при вводе исходных
данных</i>&raquo; (такое сообщение будет выведено, например, если очередной
элемент данных является символом, а для его ввода используется 
процедура <code>GetN</code>).</p>
<p>При попытке ввести больше исходных данных, чем это
предусмотрено в задании, выводится сообщение об ошибке &laquo;<i>Попытка
ввести лишние исходные данные</i>&raquo;. Если исходные данные,
необходимые для решения задания, введены не полностью, то 
выводится сообщение &laquo;<i>Введены не все требуемые исходные данные</i>&raquo;.</p>
<p>При использовании задачника в системе <b>PascalABC.NET</b> вместо процедур группы <code>Get</code>
можно использовать обычные процедуры ввода <code>read</code>.

<hr noshade size="1">
<blockquote>
<code>
<b>procedure</b> PutB(X: boolean);<br>
<b>procedure</b> PutC(X: char);<br>
<b>procedure</b> PutN(X: integer);<br>
<b>procedure</b> PutR(X: real);<br>
<b>procedure</b> PutS(X: string);<br>
<b>procedure</b> PutP(X: PNode);<br>
</code></blockquote>
<p>
Процедуры обеспечивают вывод на экран результирующих
данных, найденных программой, и их сравнение с <i>контрольными
данными</i> (то есть с правильным решением). Как и процедуры группы
<code>Get</code>, эти процедуры должны вызываться после вызова процедуры <code>Task</code>;
в противном случае при запуске программы будет выведено сообщение 
об ошибке «<i>В начале программы не вызвана процедура Task
с именем задания</i>».</p>
<p>В отличие от процедур группы <code>Get</code>, в качестве параметра процедур
группы <code>Put</code> можно указывать не только переменные, но и <i>выражения</i> (в
частности, <i>константы</i> соответствующего типа). Используемая
процедура должна соответствовать типу очередного элемента 
результирующих данных, в противном случае выводится сообщение об 
ошибке «<i>Неверно указан тип при выводе результатов</i>».</p>
<p>Как и в случае процедур группы <code>Get</code>, при вызовах процедур
группы <code>Put</code> программа осуществляет контроль за соответствием
количества требуемых и выведенных результирующих данных. Если 
программа выведет недостаточное или избыточное количество 
результирующих данных, то после проверки этих данных появится 
сообщение «<i>Выведены не все результирующие данные</i>» или,
соответственно, «<i>Попытка вывести лишние результирующие данные</i>».
<p>При использовании задачника в системе <b>PascalABC.NET</b> вместо процедур группы <code>Put</code>
можно использовать обычные процедуры вывода <code>write</code>.
<hr noshade size="1">
<blockquote>
<code>
<b>procedure</b> Dispose(<b>var</b> P: PNode);
</code></blockquote>
<p>
Данная процедура переопределяет стандартную процедуру <code>Dispose</code> для того, чтобы
контролировать действия учащегося по освобождению памяти при выполнении заданий групп Dynamic и Tree.</p>


<h2>Класс Node и альтернативный ввод&#150;вывод в стиле .NET</h2>

<p>В варианте задачника <b>Programming Taskbook</b>, включенном в систему <b>PascalABC.NET</b>, предусмотрен
альтернативный способ организации ввода-вывода, характерный не для традиционного Паскаля,
а для языков платформы .NET. Наличие двух способов ввода-вывода обусловлено тем обстоятельством, что
система <b>PascalABC.NET</b> позволяет разрабатывать программы как в стиле, характерном для
традиционного Паскаля, так и в .NET-стиле, ориентированном на использование стандартных средств платформы
.NET, в том числе ее библиотеки классов.
</p>
<p>Кроме новых средств ввода-вывода в варианте задачника для системы <b>PascalABC.NET</b> предусмотрен
класс <code>Node</code>, который следует использовать вместо типов <code>PNode</code> и <code>TNode</code> при
выполнении заданий на динамические структуры &laquo;в объектном стиле&raquo;. Заметим, что в этом случае
необходимо пользоваться группами ObjDyn и ObjTree, в которых (в отличие от групп Dynamic и Tree)
применяется &laquo;объектная&raquo; терминология, ориентированная на применение классов платформы .NET.
</p>

<hr noshade size="1">

<blockquote>
<code><b>type</b><br>
&nbsp;  Node = <b>class</b>(IDisposable)<br>
&nbsp;&nbsp;. . .<br>
&nbsp;&nbsp;<b>public</b><br>
&nbsp;&nbsp;// <i>Конструкторы:</i><br>
&nbsp; &nbsp;  <b>constructor</b> Create;<br>
&nbsp; &nbsp;  <b>constructor</b> Create(aData: integer);<br>
&nbsp; &nbsp;  <b>constructor</b> Create(aData: integer; aNext: Node);<br>
&nbsp; &nbsp;  <b>constructor</b> Create(aData: integer; aNext, aPrev: Node);<br>
&nbsp; &nbsp;  <b>constructor</b> Create(aLeft, aRight: Node; aData: integer);<br>
&nbsp; &nbsp;  <b>constructor</b> Create(aLeft, aRight: Node; aData: integer; aParent: Node);<br>
&nbsp;&nbsp;// <i>Свойства (доступны для чтения и записи):</i><br>
&nbsp; &nbsp;  <b>property</b> Data: integer;<br>
&nbsp; &nbsp;  <b>property</b> Next: Node;<br>
&nbsp; &nbsp;  <b>property</b> Prev: Node;<br>
&nbsp; &nbsp;  <b>property</b> Left: Node;<br>
&nbsp; &nbsp;  <b>property</b> Right: Node;<br>
&nbsp; &nbsp;  <b>property</b> Parent: Node;<br>
&nbsp;&nbsp;// <i>Метод, освобождающий ресурсы, используемые объектом Node:</i><br>
&nbsp; &nbsp;  <b>procedure</b> Dispose;<br>
&nbsp;  <b>end</b>;
</code></blockquote>

<p>Класс <code>Node</code> используется в заданиях групп ObjDyn и ObjTree. В заданиях на
стеки и очереди (ObjDyn1&#150;ObjDyn28) при работе с объектами типа <code>Node</code>
используются только свойства <code>Data</code> и <code>Next</code>; в заданиях на двусвязные списки
(ObjDyn29&#150;ObjDyn80) используются свойства <code>Data</code>, <code>Next</code> и <code>Prev</code>. В большинстве заданий на
бинарные деревья (группа ObjTree) используются свойства <code>Data</code>, <code>Left</code> и <code>Right</code>;
в заданиях на обработку бинарных деревьев с обратной связью
(ObjTree48&#150;ObjTree56 и ObjTree70&#150;ObjTree71) дополнительно используется свойство <code>Parent</code>.
</p>
<p>Варианты конструктора класса <code>Node</code> позволяют задавать значения требуемых свойств при создании
объекта; прочие свойства инициализируются нулевыми значениями
(числом&nbsp;0 для свойства <code>Data</code>, нулевой ссылкой <code>nil</code> для остальных свойств).
</p>
<p>Следует обратить внимание на то, что данный класс реализует интерфейс
<code>IDisposable</code>, поэтому при завершении работы с объектом типа <code>Node</code> требуется вызвать
его метод <code>Dispose</code>, освобождающий <i>неуправляемые ресурсы</i>, выделенные для этого
объекта (исключение делается только для тех объектов, которые передаются обратно
задачнику в качестве результирующих данных). Если в задании требуется вызвать
метод <code>Dispose</code> для некоторых объектов, но этот вызов не выполняется, то при запуске
программы выводится сообщение об ошибке &laquo;<i>Не вызван метод Dispose для
объекта типа Node</i>&raquo;.
</p>
<p>Все исходные и результирующие данные-ссылки в заданиях группы ObjDyn и ObjTree
имеют тип <code>Node</code>; их ввод и вывод должен осуществляться с помощью функции
<code>GetNode</code> и процедуры <code>Put</code>, описанных ниже.
</p>

<hr noshade size="1">
<blockquote>
<code>
<b>function</b> GetBoolean: boolean;<br>
<b>function</b> GetChar: char;<br>
<b>function</b> GetInt: integer;<br>
<b>function</b> GetNode: Node;<br>
<b>function</b> GetReal: real;<br>
<b>function</b> GetString: string;<br>
</code></blockquote>

<p>Функции обеспечивают ввод исходных данных в программу,
выполняющую учебное задание, причем ввод организуется в стиле,
характерном для платформы .NET (поскольку
в стандартной библиотеке .NET ввод данных <i>всегда</i> выполняется с помощью функций).
Эти функции должны вызываться после вызова процедуры <code>Task</code>;
в случае их вызова до вызова процедуры <code>Task</code> при запуске программы будет выведено
сообщение об ошибке &laquo;<i>В начале программы не вызвана процедура Task с
именем задания</i>&raquo;.
</p>
<p>Используемая функция ввода должна соответствовать типу очередного элемента
исходных данных; в противном случае выводится сообщение об ошибке
&laquo;<i>Неверно указан тип при вводе исходных данных</i>&raquo; (такое сообщение
будет выведено, например, если очередной элемент данных является символом, а для
его ввода используется функция <code>GetInt</code>).
</p>
<p>При попытке ввести больше исходных данных, чем это предусмотрено в
задании, выводится сообщение об ошибке &laquo;<i>Попытка ввести лишние исходные
данные</i>&raquo;. Если исходные данные, необходимые для решения задания, введены
не полностью, то выводится сообщение &laquo;<i>Введены не все требуемые исходные
данные</i>&raquo;.
</p>
<hr noshade size="1">
<blockquote>
<code>
<b>procedure</b> Put(<b>params</b> A: <b>array of</b> object);
</code></blockquote>
<p>Процедура <code>Put</code> обеспечивает вывод на экран результирующих данных, найденных
программой, и их сравнение с <i>контрольными данными</i> (то есть с правильным
решением). Как и описанные выше функции группы <code>Get</code>, процедура <code>Put</code> должна вызываться после вызова
процедуры <code>Task</code>; в противном случае при запуске программы будет выведено сообщение
об ошибке &laquo;<i>В начале программы не вызвана процедура Task с именем
задания</i>&raquo;.
</p>
<p>Благодаря использованию параметра-массива, снабженного атрибутом <code><b>params</b></code>,
при вызове процедуры <code>Put</code> можно указывать <i>произвольное</i> число параметров. Параметры
могут иметь тип <code>boolean</code>, <code>integer</code>, <code>real</code>, <code>char</code>, <code>string</code>, <code>Node</code>.
В качестве параметров процедуры <code>Put</code>
можно указывать не только переменные, но и <i>выражения</i> (в частности, <i>константы</i>
соответствующего типа, а также <i>нулевую ссылку</i> <code>nil</code>. Заметим, что нулевые ссылки, как и объекты типа <code>Node</code>, требуется
выводить только в заданиях групп ObjDyn и ObjTree. Если в списке параметров указываются
параметры недопустимого типа, то при выполнении программы выводится
сообщение об ошибке &laquo;<i>В методе Put указан параметр недопустимого
типа</i>&raquo;.
</p>
<p>Тип параметра должен не только быть допустимым, но и соответствовать типу
очередного элемента результирующих данных; в противном случае выводится
сообщение об ошибке &laquo;<i>Неверно указан тип при выводе результатов</i>&raquo;.
</p>
<p>Как и в случае функций группы <code>Get</code>, при вызовах процедуры <code>Put</code> программа
осуществляет контроль за соответствием количества требуемых и выведенных
результирующих данных. Если программа выведет недостаточное или избыточное
количество результирующих данных, то после проверки этих данных появится
сообщение &laquo;<i>Выведены не все результирующие данные</i>&raquo; или,
соответственно, &laquo;<i>Попытка вывести лишние результирующие данные</i>&raquo;.
</p>

<a name="debug"></a><h2>Вывод отладочной информации
</h2>
<p>Описываемые далее отладочные средства появились в версии 4.9 задачника Programming Taskbook.
С их помощью можно выводить отладочную информацию
непосредственно в окно задачника (в специальный <a href="debug.html"><i>раздел отладки</i></a>).</p>

<a name="show"></a>
<hr noshade size="1">
<blockquote>
<code><b>procedure</b> Show(S: string);
</code></blockquote>
<p>Отображает текстовую строку <code>S</code> в разделе отладки окна задачника.
</p>
<p>Если текущая экранная строка в разделе отладки уже содержит некоторый текст, то
строка <code>S</code> снабжается начальным пробелом и приписывается к этому тексту,
за исключением случая, когда при таком приписывании размер
полученного текста превысит ширину области данных (равную 80&nbsp;символам).
В последнем случае вывод строки <code>S</code> осуществляется с начала
следующей экранной строки; если же и в этой ситуации строка <code>S</code> превысит
ширину области данных, то строка <code>S</code> будет выведена на нескольких
экранных строках, причем разрывы текста будут выполняться по
пробельным символам строки <code>S</code>, а при отсутствии пробелов &#151; при
достижении очередного фрагмента строки длины, равной 80.
</p>
<p>Строка <code>S</code> может содержать явные команды перехода на новую
экранную строку. В качестве таких команд можно использовать или
символ с кодом 13 (&laquo;возврат каретки&raquo;), или символ с кодом 10 (&laquo;переход на новую
строку&raquo;), или их комбинацию в
указанном порядке (<code>#13#10</code>).
</p>

<a name="shownumber"></a>
<hr noshade size="1">
<blockquote>
<code><b>procedure</b> Show(<b>[</b>S: string;<b>]</b> A: integer<b>[</b>; W: integer<b>]</b>);<br>
<b>procedure</b> Show(<b>[</b>S: string;<b>]</b> A: real<b>[</b>; W: integer<b>]</b>);
</code></blockquote>
<p>Перегруженные варианты процедуры Show, предназначенные для вывода числовых отладочных данных.
Использование этих вариантов позволяет максимально упростить действия
учащегося, связанные с выводом числовых данных, поскольку избавляет
его от необходимости применять стандартные средства языка Pascal,
предназначенные для преобразования чисел в их строковые
представления.
</p>
<p>При вызове приведенных вариантов можно не указывать один или оба параметра,
заключенные в квадратные скобки.
</p>
<p>Строковый параметр <code>S</code> определяет необязательный комментарий,
который указывается перед выводимым числом; если параметр <code>S</code>
отсутствует, то комментарий полагается равным пустой строке.
</p>
<p>Числовой параметр <code>A</code> определяет выводимое число.
</p>
<p>Необязательный целочисленный параметр <code>W</code> определяет
<i>ширину поля вывода</i> (т.&nbsp;е. количество экранных
позиций, отводимое для вывода числа). Если указанной ширины <code>W</code> поля вывода недостаточно, то
значение параметра <code>W</code> игнорируется; в этом случае (а также в случае, если параметр <code>W</code> отсутствует)
используется ширина поля вывода, минимально необходимая для
отображения данного числа. Если число не занимает всего поля вывода, то
оно дополняется слева пробелами (т.&nbsp;е. выравнивается по
<i>правой</i> границе поля вывода). В качестве десятичного разделителя
для чисел с дробной частью используется <i>точка</i>.
</p>
<p>Вещественные числа по умолчанию выводятся в формате с
фиксированной точкой и двумя дробными знаками. Изменить формат
вывода вещественных чисел можно с помощью вспомогательной
процедуры <code>SetPrecision</code>, описываемой далее.
</p>

<a name="showline"></a>
<hr noshade size="1">
<blockquote>
<code><b>procedure</b> ShowLine(<b>[</b>S: string<b>]</b>);<br>
<b>procedure</b> ShowLine(<b>[</b>S: string;<b>]</b> A: integer<b>[</b>; W: integer<b>]</b>);<br>
<b>procedure</b> ShowLine(<b>[</b>S: string;<b>]</b> A: real<b>[</b>; W: integer<b>]</b>);<br>
</code></blockquote>
<p>Модификации ранее описанных процедур <code>Show</code>; после вывода указанных данных в раздел отладки
дополнительно осуществляют автоматический переход на следующую экранную строку.
Смысл параметров &#151; тот же, что и для соответствующих вариантов процедуры <code>Show</code>.
Параметры, указанные в квадратных скобках, могут отсутствовать.
Если процедура <code>ShowLine</code> вызывается без параметров, то она
просто обеспечивает переход на новую экранную строку в разделе отладки.
</p>

<a name="hidetask"></a>
<hr noshade size="1">
<blockquote>
<code><b>procedure</b> HideTask;
</code></blockquote>
<p>Вызов данной процедуры обеспечивает автоматическое скрытие всех разделов окна
задачника, кроме раздела отладки. Если раздел отладки в окне задачника
не отображается (в частности, если программа запущена в
демонстрационном режиме), то вызов процедуры <code>HideTask</code> игнорируется.
Игнорируются также все повторные вызовы данной процедуры.
</p>
<p>Скрыть/восстановить основные разделы окна
задачника после его отображения на экране можно также с помощью клавиши
пробела или соответствующей команды контекстного меню раздела
отладки.
</p>



<a name="setprecision"></a>
<hr noshade size="1">
<blockquote>
<code><b>procedure</b> SetPrecision(N: integer);
</code></blockquote>

<p>Процедура предназначена для настройки формата вывода
<i>вещественных</i> отладочных данных. Если параметр <code>N</code> положителен, то он
определяет количество выводимых дробных разрядов; при этом число
выводится в формате с фиксированной точкой. Если параметр <code>N</code> равен
нулю, то число выводится в формате с
плавающей точкой (экспоненциальном формате); при этом число
дробных знаков для экспоненциального формата
определяется шириной поля вывода (т.&nbsp;е. параметром <code>W</code> процедуры
<code>Show</code> или <code>ShowLine</code>). При отрицательных значениях параметра <code>N</code> выполняется та же
настройка, что и при <code>N&nbsp;=&nbsp;0</code>.
</p>
<p>Действие текущей настройки числового формата, определенной
процедурой <code>SetPrecision</code>, продолжается до очередного вызова этой
процедуры. До первого вызова процедуры <code>SetPrecision</code> вещественные
числа выводятся в формате с фиксированной точкой и двумя дробными
знаками.
</p>

<h2>Особенности модуля PT4Exam</h2>
<p>При выполнении заданий групп ExamBegin и ExamTaskC, связанных с ЕГЭ по информатике,
к программам вместо модуля PT4 подключается модуль <code>PT4Exam</code>. В этом модуле реализована единственная дополнительная
процедура <a href="#task"><code>Task</code></a>, обеспечивающая инициализацию задания с указанным
именем. Все действия по вводу-выводу должны выполняться с использование стандартных
процедур языка Pascal. Отладочные средства модуля <code>PT4</code> в модуле <code>PT4Exam</code> также недоступны,
однако имеется возможность выводить дополнительные данные можно непосредственно в раздел результатов
(хотя при этом решение будет считаться ошибочным).
</p>
<p>Описанные выше ограничения модуля <code>PT4Exam</code> позволяют максимально приблизить полученное
решение к виду, требуемому на экзамене (программа содержит всего две дополнительные конструкции:
директиву подключения модуля <code>PT4Exam</code> и оператор вызова процедуры <code>Task</code>, инициализирующей требуемое задание).
</p>
</body>
</html>

