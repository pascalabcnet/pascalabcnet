%PREFIX%=SEMANTICERROR_

NAME_CANNOT_HAVE_GENERIC_PARAMETERS_{0}=Имя {0} не может иметь обобщенные параметры
AUTO_CLASS_MUST_NOT_HAVE_POINTERS=Авто класс не может иметь поля, являющиеся указателями
AUTO_CLASS_MUST_NOT_HAVE_PARENTS=Авто класс не может иметь предков или реализовывать интерфейсы
UNDEFINED_NAME_REFERENCE_{0}=Неизвестное имя '{0}'
TWO_TYPE_CONVERTIONS_POSSIBLE_FIRST_TYPE_{0}_SECOND_TYE_{1}=Возможны два преобразования типа: к типу {0} и к типу {1}
CAN_NOT_CONVERT_TYPES_FROM_{0}_TO_{1}=Нельзя преобразовать тип {0} к {1}
NO_FUNCION_WITH_THIS_NAME=Нет функции с таким именем
INVALID_FUNCTION_PARAMETERS_NUM=Неверное число параметров функции
INVALID_PROCEDURE_PARAMETERS_NUM=Неверное число параметров процедуры
NO_FUNCTION_WITH_SAME_PARAMETERS_NUM=Нет перегруженной подпрограммы с таким количеством параметров
INVALID_FUNCTION_ARGUMENTS=Неправильный тип параметров подпрограммы
NO_OVERLOADED_FUNCTION_WITH_SAME_ARGUMENTS=Нет перегруженной подпрограммы с такими типами параметров
SEVERAL_FUNCTIONS_CAN_BE_CALLED=Несколько подпрограмм могут быть вызваны
FUNCTION_NAME_USED_TO_DEFINE_ANOTHER_KIND_OF_OBJECT=Имя функции используется для определения другого типа объекта (не функции)
FUNCTION_DUPLICATE_DEFINITION=Повторное объявление 
NAME_REDEFINITION_{0}=Повторно объявленный идентификатор {0}
POSSIBLE_TWO_TYPE_CONVERTIONS=Возможны два преобразования типов
THIS_IS_NOT_FUNCTION_NAME=Это не имя подпрограммы
EXPECTED_ANOTHER_KIND_OF_OBJECT=Ожидался другой тип объекта
OPERATOR_{0}_CAN_NOT_APPLIED_TO_TYPE_{1}=Операция {0} не может быть применена к типу {1}
TWO_OPERATORS_CAN_BE_CALLED_{0}_AND_{1}=Две операции могут быть вызваны: {0} и {1}
CLASS_CAN_NOT_BE_DEFINED_IN_TYPE_OR_FUNCTION=Класс не может быть определен в типе или подпрограмме
ONLY_ONE_PARAMETER_NAME_WITH_DEFAULT_VALUE_ALLOWED=Допустим только один параметр со значением по умолчанию
NEED_DEFAULT_VALUE_FOR_PARAMETER=Этому параметру необходимо значение по умолчанию
DUPLICATE_ATTRIBUTE_APPLICATION=Двухкратное применение атрибута
VAR_PARAMETER_CAN_NOT_HAVE_DEFAULT_VALUE=Параметр, передаваемый по ссылке, не может иметь значение по умолчанию
DUPLICATE_FUNCTION_DEFINITION=Повторное объявление подпрограммы
THIS_EXPRESSION_CAN_NOT_BE_PASSED_BY_ADDRESS=Данный объект не может быть передан как var-параметр
MEMBER_{0}_IS_NOT_DECLARED_IN_TYPE_{1}={0} не объявлен в типе {1}
MEMBER_{0}_IS_NOT_DECLARED_IN_NAMESPACE_{1}={0} не объявлен в пространстве имен {1}
CAN_NOT_CALL_STATIC_MEMBER_{0}_WITH_EXPRESSION=Нельзя вызвать статический метод {0} с выражением
CAN_NOT_CALL_NON_STATIC_MEMBER_{0}_WITH_TYPE_{1}=Mетод {0} не является статическим для типа {1}
CAN_NOT_REFERENCE_TO_STATIC_FIELD_{0}_WITH_EXPRESSION=Нельзя обратиться к статическому полю {0} через объект
CAN_NOT_REFERENCE_TO_NONSTATIC_FIELD_{0}_WITH_TYPE=Нельзя обратиться к экземплярному полю {0} через тип
FUNCTION_EXPECTED_PROCEDURE_{0}_MEET=Ожидалась функция, встречена процедура {0}
ONLY_PROCEDURE_NAME_ALLOWED_IN_CLASS_FUNCTION_DEFINITION=Только имя процедуры допустимо в объявлении метода класса
BREAK_STATEMENT_WITHOUT_COMPREHENSIVE_CYCLE=break вне цикла
CONTINUE_STATEMENT_WITHOUT_COMPREHENSIVE_CYCLE=continue вне цикла
FOR_LOOP_CONTROL_MUST_BE_SIMPLE_LOCAL_VARIABLE=Переменная цикла for должна описываться в том же блоке, что и цикл for
ORDINAL_TYPE_EXPECTED=Ожидался порядковый тип
ORDINAL_OR_STRING_TYPE_EXPECTED=Ожидался порядковый или строковый тип
CAN_NOT_REFERENCE_TO_NONSTATIC_PROPERTY_{0}_WITH_TYPE=Нельзя обратиться к свойству {0} через тип
CAN_NOT_REFERENCE_TO_STATIC_PROPERTY_{0}_WITH_EXPRESSION=Нельзя обратиться к статическому свойству через объект
THIS_PROPERTY_{0}_CAN_NOT_BE_READED=Свойство {0} не имеет метода для чтения
THIS_PROPERTY_{0}_CAN_NOT_BE_WRITED=Свойство {0} не имеет метода для записи
PROPERTY_{0}_AND_READ_ACCESSOR_{1}_PARAMETERS_COUNT_CONVERGENCE=Несоответствие числа параметров свойства {0} и метода {1} для чтения
PROPERTY_{0}_AND_WRITE_ACCESSOR_{1}_PARAMETERS_COUNT_CONVERGENCE=Несоответствие числа параметров свойства {0} и метода {1} для записи
PROPERTY_{0}_AND_WRITE_ACCESSOR_{1}_PARAMS_TYPE_CONVERGENCE=Несоответствие типа параметра свойства {0} и метода {1} для записи
PROPERTY_{0}_AND_READ_ACCESSOR_{1}_PARAMS_TYPE_CONVERGENCE=Несоответствие типа параметра свойства {0} и метода {1} для чтения
PROPERTY_{0}_AND_READ_ACCESSOR_{1}_RETURN_VALUE_TYPE_CONVERGENCE=Несоответствие типа свойства и возвращаемого значения метода {1} для чтения
PROPERTY_READ_ACCESSOR_CAN_NOT_BE_PROCEDURE=Метод для чтения свойства не может быть процедурой
PROPERTY_{0}_AND_WRITE_ACCESSOR_LAST_PARAMETER_TYPE_CONVERGENCE=Несоответствие типа свойства {0} и типа последнего параметра метода для записи
PROPERTY_WRITE_ACCESSOR_CAN_NOT_BE_FUNCTION=Метод для чтения не может быть функцией
PROPERTY_{0}_REFERENCE_WITH_INVALID_PARAMS_COUNT=Неправильное число параметров при обращении к свойству {0}
NO_DEFAULT_PROPERTY_TO_TYPE_{0}=Нет индексного свойства по умолчанию для типа {0}
DUPLICATE_DEFAULT_PROPERTY_IN_CLASS=Два индексных свойства по умолчанию в классе
DEFAULT_PROPERTY_MUST_BE_INDEXED=Свойство по умолчанию должно быть индексным
FORWARD_DEFINITION_WITH_FUNCTION_BODY=Предварительное описание подпрограммы не должно иметь тела
FUNCTION_WITHOUT_BODY_MUST_HAVE_FORWARD_ATTRIBUTE=Подпрограмма без тела должна иметь атрибут forward
DIFFERENT_PARAMETER_NAME_IN_FUNCTION_DEFINITION_{0}_AND_PREDEFINITION_{1}=Различные имена параметров в описании подпрограммы {0} и ее предописании {1}
FUNCTION_DEFINITION_HAVE_DIFFERENT_PARAMS_WITH_PREDEFINITION=Параметры в описании подпрограммы отличаются от параметров в ее предописании
FUNCTION_PREDEFINITION_AND_DEFINITION_HAVE_DIFFERENT_RESULT_TYPES=Описание и предописание функции имеют разные типы возвращаемого значения
FUNCTION_PREDEFINITION_WITHOUT_DEFINITION=Предописание функции без описания
DIVISION_BY_ZERO_CONSTANT=Деление на константу 0
TYPE_NAME_EXPECTED=Ожидалось имя типа
ONLY_COMMON_TYPE_METHOD_DEFINITION_ALLOWED=Недопустимо определение метода класса, не описанного в программе
CONSTANT_EXPRESSION_EXPECTED=Ожидалось константное выражение
EXCEPTION_TYPE_MUST_BE_SYSTEM_EXCEPTION_OR_DERIVED_FROM_EXCEPTION=Тип исключения должен быть System.Exception или его потомком
STATIC_KEYWORD_ALLOWED_ONLY_WITH_METHOD=Ключевое слово 'class' допустимо только для метода класса
CAN_NOT_BE_VIRTUAL_STATIC_METHOD=Статический метод не может быть виртуальным 
ONLY_CONSTRUCTOR_OF_TYPE_ALLOWED=Допустимо определение конструктора только для класса
CONSTRUCTOR_MUST_BE_REALIZED_WITH_CONSTRUCTOR_KEYWORD=Конструктор должен быть определен с ключевым словом constructor
FUNCTION_{0}_ALREADY_HAVE_A_BODY=Подпрограмма {0} уже имеет тело
NO_METHOD_TO_OVERRIDE=Нет метода для переопределения
CASE_CONSTANT_VARIANT_COINCIDE_WITH_ANOTHER=Совпадение двух констант в операторе case
CASE_CONSTANT_VARIANT_COINCIDE_WITH_DIAPASON=Константа попадает в один из диапазонов оператора case
CASE_DIAPASON_VARIANT_INTERSECTION=Пересечение диапазонов оператора case
CAN_NOT_INCREMENT_ORDINAL_TYPE_VALUE=Невозможно увеличить значение перечислимого типа (возможно, происходит выход за верхнюю границу типа)
CAN_NOT_DECREMENT_ORDINAL_TYPE_VALUE=Невозможно уменьшить значение перечислимого типа (возможно, происходит выход за нижнюю границу типа)
EXPECTED_DELEGATE=Ожидалось имя процедуры или функции
EXPECTED_STATIC_METHOD=Ожидался классовый метод
EXPECTED_NON_STATIC_METHOD=Ожидался экземплярный метод
CAN_NOT_EXPLICITLY_CONVERT_TYPE_{0}_TO_TYPE_{1}=Невозможно явно преобразовать тип {0} к типу {1}
ONLY_ONE_PARAMETER_OF_TYPE_CONVERSION_ALLOWED=У операции преобразования типов допустим только один параметр 
REAL_TYPE_IN_DOUBLE_COLON_EXPRESSION_EXPECTED=Данный формат вывода может быть применен только к вещественному типу
ONLY_ONE_PARAMS_PARAMETER_ALLOWED=Допустим только один параметр с ключевым словом params
ONLY_UNSIZED_ARRAY_PARAMS_PARAMETER_ALLOWED=Только динамический массив может описываться с ключевым словом params
{0}_DIMENSIONAL_ARRAY_CAN_NOT_HAVE_{1}_AND_MORE_INDEXING=Неверное количество индексов. Должно быть {0} 
TUPLE_CAN_HAVE_ONLY_ONE_INDEX=Кортеж может иметь только один индекс 
TUPLE_INDEX_OUT_OF_RANGE_{0}=Индекс кортежа должен быть ≥0 и ≤{0}
TUPLE_INDEX_MUST_BE_INTEGER_CONSTANT=Индекс кортежа должен быть целой константой
INHERITED_EXPECTED_IN_CLASS=Ключевое слово inherited должно быть в методе класса
NO_BASE_CLASS_DEFINED_BUT_INHERITED_MEET=Ключевое слово inherited в методе класса, который не имеет предка
NO_METHOD_{0}_IN_CLASS_{1}=Нет метода {0} в классе {1}
OVERLOAD_OPERATOR_CAN_NOT_BE_PROCEDURE=Перегруженная операция не может быть процедурой
OVERLOADED_OPERATOR_MUST_BE_STATIC_FUNCTION=Перегруженная операция должна быть статической функцией
NOT_SUPPORTED_BY_THIS_VERSION_OF_COMPILER=Данная конструкция не поддерживается текущей версией компилятора
NEGATIVE_ARRAY_LENGTH_({0})_NOT_ALLOWED=Отрицательная длина массива ({0}) не допустима
INCOMPATIBLE_ARRAY_BOUNDS_TYPES=Несовместимые типы границ диапазона массива
CAN_NOT_APPLY_SETLENGTH_TO_THIS_OPERAND_TYPE=Не могу вызвать SetLength для операнда данного типа
FUNCTION_NEED_RETURN_TYPE=Необходимо указать возвращаемое значение для функции
