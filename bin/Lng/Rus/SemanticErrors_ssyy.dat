%PREFIX%=SEMANTICERROR_
TEMPLATE_ARGUMENTS_COUNT_MISMATCH=Неправильное число параметров шаблона
{0}_IS_NOT_TEMPLATE_CLASS={0} не является именем шаблонного класса
TEMPLATE_PARAMETER_{0}_REDEFINITION=Повторное описание параметра {0}
INHERITED_CONSTRUCTOR_CALL_MUST_BE_FIRST=Вызов конструктора предка должен быть первым в теле конструктора
INHERITED_CONSTRUCTOR_CALL_EXPECTED=Необходимо вызвать конструктор предка
INVALID_INTERFACE_MEMBER=В интерфейсе могут присутствовать только заголовки функций, процедур и свойства
{0}_IS_NOT_INTERFACE={0} не является интерфейсом
INTERFACE_FUNCTION_WITH_BODY=Нельзя определять тело функции или процедуры интерфейса
CONSTRUCTOR_IN_INTERFACE=Интерфейс не может содержать конструкторы
INTERFACE_{0}_CONSTRUCTOR_CALL={0} является интерфейсом, невозможно создать его экземпляр
CLASS_{0}_DOES_NOT_IMPLEMENT_MEMBER_{2}_OF_INTERFACE_{1}=Класс {0} не реализует метод {2} интерфейса {1}
MEMBER_{2}_OF_CLASS_{0}_FROM_INTERFACE_{1}_MUST_BE_PUBLIC_AND_NON_STATIC=Функция класса {0}, реализующая метод {2} интерфейса {1}, должна быть нестатической с уровнем доступа public 
ATTRIBUTES_IN_INTERFACE_MEMBER=Данный аттрибуты недопустим в интерфейсе
MODIFER_BLOCK_{0}_CALL=Член {0} закрыт своим модификатором видимости
LEFT_RANGE_GREATER_THEN_RIGHT=Нижняя граница превосходит верхнюю
ACCESS_MODIFER_IN_INTERFACE=Модификаторы видимости недопустимы внутри интерфейса
INTERFACE_FORWARD_DECLARATION=Предописания интерфейсов недопустимы
FORWARD_DECLARATION_{0}_AS_BASE_TYPE=Предописание {0} не может быть использовано в качестве базового типа
FORWARD_DECLARATION_OF_{0}_MISMATCH_DECLARATION=Предописание типа {0} не соответствует его описанию
NO_TYPE_{0}_DEFINITION=Отсутствует описание типа {0}
VIRTUAL_METHOD_IN_RECORD=Виртуальные методы в записях недопустимы
LABEL_CAN_NOT_BE_DECLARED_HERE=Метка не может быть определена в этом месте программы
IDENT_{0}_IS_NOT_LABEL={0} не является меткой
LABEL_{0}_REDEFINED=Повторное определение метки {0}
NO_LABEL_{0}_DEFINITION=Метка {0} не установлена
BLOCKED_LABEL_{0}_GOTO=Переход внутрь составного оператора на метку {0} невозможен
CONSTRUCTOR_NOT_IN_CLASS=Конструктор может быть описан только внутри класса
DESTRUCTOR_NOT_IN_CLASS=Деструктор может быть описан только внутри класса
ASSIGN_TO_EVENT=Оператор := не применим к событиям; используйте += и -=
DESTRUCTOR_IN_INTERFACE=Деструкторы не могут присутствовать в интерфейсе
CAN_NOT_CALL_CONSTRUCTOR_AS_PROCEDURE=Нельзя вызвать конструктор через объект
CANNOT_USE_POINTER_AS_GENERIC_ARGUMENT=Тип-указатель не может выступать в качестве параметра управляемого шаблона
PARAMETER_{0}_MUST_HAVE_DEFAULT_CONSTRUCTOR=Невозможно инстанцировать, так как у типа {0} нет конструктора без параметров с уровнем доступа public
PARAMETER_{0}_MUST_BE_REFERENCE_TYPE=Невозможно инстанцировать, так как тип {0} не является ссылочным (классом)
PARAMETER_{0}_MUST_BE_VALUE_TYPE=Невозможно инстанцировать, так как тип {0} не является размерным
PARAMETER_{0}_MUST_BE_DERIVED_FROM_{1}=Невозможно инстанцировать, так как тип {0} не наследован от {1}
PARAMETER_{0}_MUST_IMPLEMENT_INTERFACE_{1}=Невозможно инстанцировать, так как тип {0} не реализует интерфейс {1}
NO_MAIN_FUNCTION=Отсутствует функция main()
FUNCTION_SHOULD_RETURN_VALUE=Функция должна вернуть значение
FUNCTION_SHOULD_NOT_RETURN_VALUE=Функция не должна возвращать значение
EXPECTED_TYPE_{0}=Ожидался тип {0}
CAN_NOT_WRITE_REFERENCE_DATA_TO_BINARY_FILE=Невозможно записать данные ссылочного типа в бинарный файл
CAN_NOT_READ_REFERENCE_DATA_FROM_BINARY_FILE=Невозможно считать данные ссылочного типа из бинарного файла
WHERE_SECTION_ALLOWED_ONLY_IN_GENERICS=Секция where допустима только в generic-типах и generic-подпрограммах
TEMPLATE_PARAMS_EXPECTED=В шаблонном типе необходим список шаблонных параметров
CAN_NOT_GENERATE_ACCESSOR_{0}=Невозможно сгенерировать аккессор, так как имя {0} уже занято
EXPECTED_DERIVED_CLASSES=Ожидался класс-потомок или класс-предок
SPECIFICATORS_FOR_{0}_ALREADY_EXIST=Спецификаторы для параметра {0} уже объявлены
SPECIFICATOR_MUST_BE_TYPE_REFERENCE=Спецификатор должен быть ссылкой на тип
PARENT_SPECIFICATOR_MUST_BE_FIRST=Спецификатор предка должен быть первым в списке
CLASS_OR_RECORD_SPECIFICATOR_MUST_BE_FIRST=Спецификатор class/record должен быть первым в списке
CONSTRUCTOR_SPECIFICATOR_MUST_BE_LAST=Спецификатор constructor должен быть последним в списке
OBJECT_CAN_NOT_BE_USED_AS_PARENT_SPECIFICATOR=Тип object не может быть использован для указания предка шаблонного параметра
TYPE_{0}_DERIVED_FROM_ITSELF=Тип {0} наследуется циклически от самого себя
AMBIGUITY_BETWEEN_NAMES_{0}_AND_{1}=Двусмысленность между именами {0} и {1}
POINTERS_OF_GENERIC_PARAMETERS_NOT_ALLOWED=Указатели на параметр generic-типа недопустимы
OPERATOR_AS_CAN_NOT_BE_USED_WITH_GENERIC_PARAMETER_{0}_WITHOUT_CLASS_CONSTRAINT=Операция as не может быть применена к generic-параметру {0}, не имеющему спецификатора "class"
FORWARD_DECLARATION_{0}_AS_IMPLEMENTING_INTERFACE=Предописание {0} не может быть использовано как реализуемый интерфейс
FORWARD_TEMPLATE_{0}_DECLARATION_MISMATCH_DECLARATION=Предописание шаблонного типа {0} не соответствует его описанию
GENERIC_TYPE_NOT_ALLOWED_HERE=Описывать generic-тип можно только в секции описаний type
STATIC_CONSTRUCTOR_MUST_BE_PARAMETERLESS=Статический конструктор должен быть без параметров
CONSTRUCTOR_CAN_NOT_BE_VIRTUAL=Конструктор не может быть виртуальным
CANNOT_USE_DIAPASON_AS_GENERIC_ARGUMENT=Диапазонный тип не может выступать в качестве параметра управляемого шаблона
CANNOT_USE_BOUNDED_ARRAY_AS_GENERIC_ARGUMENT=Тип статического массива не может выступать в качестве параметра управляемого шаблона
CANNOT_USE_TYPED_FILE_AS_GENERIC_ARGUMENT=Тип типизированного файла не может выступать в качестве параметра управляемого шаблона
INDEX_PROPERTY_ACCESSOR_CAN_NOT_BE_VARIABLE=Акцессор индексного свойства не может быть определен через поле
ACCESSOR_NAME_EXPECTED=Необходимо указать имя акцессора
PROPERTY_TYPE_MISMATCH_ACCESSOR_FIELD_TYPE=Тип свойства не совпадает с типом поля для акцессора
ERROR_LOADING_RESOURCE_FILE_{0}=Ошибка при подключении ресурсного файла {0}
SAVE_ASSEMBLY_ERROR_{0}=Ошибка при сохранении сборки: {0}
NO_FUNCTIONS_{0}_CAN_BE_USED_WITH_THIS_SPECIFICATION=Нет функций {0}, которые можно было бы использовать с указанной спецификацией
PROPERTY_IN_LEFT_PART_PLUS_MINUS_ASSIGN=Свойство не может использоваться в левой части обобщенного оператора присваивания
DEFAULT_VALUE_MUST_BE_ONLY_IN_FIRST_DECLARATION=Значение по умолчанию следует указывать только при первом объявлении подпрограммы
STRUCT_TYPE_DEFINITION_IN_FORMAL_PARAM=Тип параметра или возвращаемого значения не может быть описанием записи или описанием массива с границами
TYPE_OF_ONE_OR_MORE_OPERATOR_PARAMETERS_MUST_BE_{0}=Хотя бы один параметр должен быть типа {0}
PARAMS_IN_OPERATOR=В операторах запрещены params-параметры 
OPERATOR_{0}_PARAMETERS_COUNT_MUST_EQUAL_{1}=Количество параметров операции {0} должно равняться {1}
ONLY_LAST_PARAMETER_CAN_BE_PARAMS=Только последний параметр может быть params-параметром
FUNCTION_WITH_PARAMS_PARAMETER_CAN_NOT_HAVE_DEFAULT_PARAMETERS=В подпрограмме с params-параметром недопустимы значения по умолчанию
CAN_NOT_ASSIGN_TO_LEFT_PART=Невозможно присвоить выражению в левой части оператора присваивания
CAN_NOT_ASSIGN_TO_CONSTANT_OBJECT=Невозможно присвоить константному объекту
NO_OVERLOAD_FUNCTION_{0}_USEFUL_FOR_ACCESSOR=Среди перегруженных методов {0} нет пригодного для акцессора
ACCESSOR_CAN_BE_FIELD_OR_METHOD_ONLY=В качестве акцессора можно указывать только метод или поле класса
CAN_NOT_DEFINE_METHOD_OF_COMPILED_TYPE=Недопустимы описания методов для типа из внешней сборки
NO_DEFAULT_PROPERTY_TO_FUNCTION_TYPE=Нет индексного свойства по умолчанию для функционального типа
TYPE_{0}_HAS_{1}_GENERIC_PARAMETERS=Количество шаблонных параметров типа {0} должно равняться {1}
TRIANGLE_BRACKETS_NOT_AWAITED=Угловые скобки не должны использоваться с данным выражением
TRIANGLE_BRACKETS_NOT_ALLOWED_WITH_COMMON_FUNCTIONS=Спецификация при помощи угловых скобок недопустима для обычных функций (допустима для generic-функций)
FUNCTION_{0}_DEPEND_FROM_{1}_TYPE_PARAMS=Число типов-параметров в спецификации generic-подпрограммы {0} должно быть равно {1}
WHERE_SECTION_MUST_BE_ONLY_IN_FIRST_DECLARATION=Секцию where следует указывать только в предописании (предописание найдено)
CAN_NOT_INHERIT_FROM_GENERIC_PARAMETER=Нельзя наследовать от generic-параметра
GENERIC_FUNCTION_{0}_CAN_NOT_BE_CALLED_WITH_THESE_PARAMETERS=Generic-функция {0} не может быть вызвана с данным набором фактических параметров
CAN_NOT_DEDUCE_TYPE_PARAMS_FROM_CALL_{0}=Невозможно вывести типы-параметры generic-подпрограммы {0} (укажите типы-параметры явно)
CAN_NOT_CALL_ANY_GENERIC_FUNCTION_{0}_WITH_THESE_PARAMETERS=С данным списком формальных параметров невозможно вызвать ни одну из перегруженных generic-подпрограмм {0}
OPERATOR_SIZEOF_CAN_NOT_BE_USED_WITH_GENERIC_TYPE=Операция sizeof не применима к generic-типам
CAN_NOT_INHERIT_FROM_VALUE_TYPE=Нельзя явно наследовать от System.ValueType (от него неявно наследуются все размерные типы)
CAN_NOT_INHERIT_FROM_POINTER=Нельзя наследовать от типа-указателя
CAN_NOT_INHERIT_FROM_FUNCTION_TYPE=Нельзя наследовать от функционального типа
CAN_NOT_INHERIT_FROM_DELEGATE_TYPE=Нельзя явно наследовать от типов System.Delegate и System.MulticastDelegate (они неявно используются при работе с делегатами)
INTERFACE_{0}_ALREADY_ADDED_TO_IMPLEMENTING_LIST=Интерфейс {0} уже добавлен в список реализуемых интерфейсов
CAN_NOT_CONVERT_TYPE_{0}_TO_INTERFACE_{1}=Невозможно преобразовать выражение типа {0} к не реализуемому этим типом интерфейсу {1}
CLASS_FUNCTION_ATTRIBUTE_MISMATCH=Аттрибутом class следует снабдить как объявление, так и описание статической функции
COULD_NOT_DEFINE_GENERIC_FUNCTION_OF_COMPILED_TYPE=Невозможно определить generic-функцию для типа из внешней сборки
PARAMETER_{0}_MUST_BE_NAMED_{1}=Шаблонный параметр номер {0} должен быть назван {1}
TEMPLATES_AND_GENERICS_ARE_INCOMPATIBLE=Недопустимо совмещение управляемых и неуправляемых шаблонов
TEMPLATE_CAN_BE_CLASS_ONLY=Только класс, запись или интерфейс может быть шаблонным типом
CANNOT_USE_SHORT_STRING_AS_GENERIC_ARGUMENT=Тип коротких строк не может выступать в качестве параметра управляемого шаблона
TYPE_REFERENCE_EXPECTED=Ожидалось имя типа
DELEGATE_CAN_NOT_USE_COMPREHENSIVE_GENERIC_PARAMETER=При описании делегата нельзя использовать тип-параметр объемлющего generic-шаблона 
CAN_NOT_DEFINE_METHOD_OF_TEMPLATE_TYPE_SYNONYM=Недопустимо описывать метод для синонима шаблонного типа
ENUM_CAN_NOT_BE_USED_AS_PARENT_SPECIFICATOR=Специальный тип System.Enum не может быть использован для указания предка шаблонного параметра
CONSTRUCTOR_CAN_NOT_BE_GENERIC=Конструктор не может быть шаблонным
GENERIC_DELEGATE_INNER_FUNCTION=Недопустимо описывать тип шаблонного делегата внутри подпрограммы
GENERIC_NESTED_FUNCTIONS_NOT_ALLOWED=Вложенные generic-подпрограммы запрещены
NESTED_FUNCTIONS_IN_GENERIC_FUNCTIONS_NOT_ALLOWED=Вложенные подпрограммы запрещены внутри generic-подпрограмм
GENERIC_TYPE_{0}_NEEDS_{1}_GENERIC_PARAMETERS=Количество шаблонных параметров типа {0} должно быть равно {1}
EXPRESSION_IS_NOT_ADDRESSED=Это выражение не может стоять в левой части оператора присваивания или передаваться как var-параметр в подпрограмму

