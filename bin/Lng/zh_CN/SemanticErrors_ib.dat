%PREFIX%=SEMANTICERROR_
CIRCULARITY_IN_RECORD=在结构布局中循环
CAN_NOT_EXECUTE_FOREACH_BY_EXPR_OF_TYPE_{0}='foreach' 或 'yield sequence' 语句不能对 '{0}' 类型的表达式进行操作
FOREACH_LOOP_CONTROL_MUST_BE_SIMPLE_LOCAL_VARIABLE=循环变量必须是简单局部变量
TYPES_OF_VAR_AND_ELEMENTS_IN_FOREACH_MUST_BE_EQUAL_{0}_{1}=foreach 中变量的类型 {0} 必须等于可迭代集合中元素的类型 {1}
CLASS_{0}_DOES_NOT_IMPLEMENT_MEMBER_{2}_OF_CLASS_{1}=类 '{0}' 未实现类 '{2}' 的继承抽象成员 '{2}'
RECORD_{0}_DOES_NOT_IMPLEMENT_MEMBER_{2}_OF_CLASS_{1}=记录 '{0}' 未实现记录 '{1}' 的继承抽象成员 '{2}'
RAISE_WITHOUT_PARAMETERS_MUST_BE_IN_CATCH_BLOCK=没有参数的 raise 语句不允许在 except 子句之外
NIL_WITH_VALUE_TYPES_NOT_ALLOWED=无法将 nil 类型转换为值类型
POINTERS_OF_REF_TYPES_NOT_ALLOWED=不允许指向引用类型的指针
DIRECTIVE_{0}_NOT_ALLOWED=修饰符 '{0}' 在此上下文中无效
BLOCK_VARIABLES_CANNOT_HAVE_NAMES_UPPER_SCOPE=不能在此范围内声明局部变量，因为它会给其他变量赋予不同的含义，而其他变量已经在父范围中用于表示其他内容
INVALID_PARAMETER_COUNT_IN_INDEXER=索引数量错误
TYPE_CAN_NOT_HAVE_THIS_SIZE_{0}=字体大小错误 '{0}'
CONSTRUCTOR_CAN_NOT_BE_OVERRIDE=构造函数不能被覆盖
CANNOT_ASSIGN_TO_READONLY_FIELD=只读字段不能分配给
CANNOT_ASSIGN_TO_READONLY_PROPERTY=无法将只读属性分配给
DESTRUCTOR_CANNOT_HAVE_PARAMETERS=析构函数不能有参数
USING_MODIFIERS{0}_{1}_TOGETHER_NOT_ALLOWED=修饰符 '{0}' 与修饰符 '{1}' 有冲突
CONST_PARAMETERS_CANNOT_HAVE_DEFAULT_VALUE=常量参数不能有默认值
FORMAT_EXPRESSION_CAN_USE_ONLY_IN_THESE_PROCEDURES=格式表达式只能用于 write, writeln è str 的调用
BAD_CONSTRUCTED_FORMAT_EXPRESSION=构造不当的格式表达式 
NIL_IN_SET_CONSTRUCTOR_NOT_ALLOWED=集合构造函数中不能使用 nil
POINTERS_IN_SETS_NOT_ALLOWED=集合不能包含指针
VOID_NOT_VALID=在此上下文中不能使用 'System.Void' 类型
EXPECTED_TYPE=预期类型
INTERFACE_CANNOT_BE_SEALED=接口不能密封
INTERFACE_CANNOT_BE_AUTO=接口不能有 'auto' 属性
RANGE_TOO_LARGE=范围太大
CANNOT_EVALUATE_SIZE=无法评估类型 {0} 的大小
CANNOT_CALL_NEW_BECAUSE_OF_UNDEFINED_SIZE=无法调用 '新建' ，因为该结构没有预定义大小
CANNOT_BE_ABSTRACT_STATIC_METHOD=抽象方法不能是静态的
ABSTRACT_METHOD_IN_RECORD=抽象方法在记录中无效
ABSTRACT_METHOD_WITH_BODY=抽象方法不能有主体
ABSTRACT_METHOD_IN_SEALED_CLASS=抽象方法在密封类中无效
ABSTRACT_CONSTRUCTOR_{0}_CALL=无法创建抽象类 '{0}' 的实例
CONSTRUCTOR_CANNOT_BE_ABSTRACT=构造函数不能是抽象的
CANNOT_ASSIGN_TO_LOOP_VARIABLE=无法更改循环变量的值
CANNOT_CALL_ABSTRACT_METHOD=不能调用抽象基成员
NIL_IN_THIS_CONTEXT_NOT_ALLOWED=在这种情况下不能使用 Nil
ACCESSOR_{0}_MUST_BE_STATIC=访问器 '{0}' 必须是静态的
ACCESSOR_{0}_CANNOT_BE_STATIC=访问器 '{0}' 必须是非静态的
EVENT_MUST_HAVE_TYPE=预期的事件类型
EVENT_TYPE_MUST_BE_DELEGATE=事件必须是委托类型
EVENT_{0}_MUST_BE_IN_LEFT_PART=事件 '{0}' 只能出现在 += 或 -= 的左侧
CLASS_CONSTANT_CAN_HAVE_ONLY_PRIMITIVE_VALUE=类常量只能有原始值
CIRCULARITY_IN_POINTER=指针式圆度
UNEXPECTED_EXPRESSION_IN_WITH=这种类型的表达式不能在 with 子句中
TYPE_{0}_NOT_VALID=在此上下文中不能使用类型 '{0}'
NO_DEFAULT_CONSTRUCTOR_INT_TYPE_{0}=类 '{0}' 没有默认构造函数
LABELED_DECLARATION_NOT_ALLOWED=无法在变量定义上设置标签
NAME_IN_BASE_CLASS_MUST_BE_METHOD=找不到基类中具有相同参数的虚方法
NO_CONSTRUCTOR_IN_BASE_CLASS_WITH_SAME_PARAMETERS=在基类中找不到具有相同参数的构造函数
INVALID_ARRAY_REPRESENTATION=无效的索引器表示
{0}_PARAMETERS_EXPECTED=需要 {0} 个参数
RANK_MISMATCH_IN_INITILIALIZER=数组初始值设定项维度和数组类型不匹配
RETURN_VALUE_SHOULD_HAVE_TYPE_{0}=返回值或参数的类型应为 '{0}'
CIRCURAL_TYPE_CONVERSION_DEFINITION=用户定义的运算符不能采用封闭类型的对象并转换为封闭类型的对象
THIS_EXPRESSION_CAN_NOT_BE_PASSED_BY_CONST=此表达式不能作为常量参数传递
EXTENSION_METHOD_FOR_INTERFACE=无法声明接口的扩展方法
EXTENSION_METHOD_FOR_GENERIC_INSTANCES=无法声明泛型实例的扩展方法
EXTENSION_CONSTRUCTOR_NOT_ALLOWED=无法声明扩展构造函数
CLASS_MEMBER_{0}_EXPECTED='{0}' 必须是方法或构造函数
DESTRUCTOR_MUST_HAVE_NAME=析构函数必须有名字
STRING_CONSTANT_EXPECTED=应为字符串常量
STRING_CONSTANT_OR_IDENTIFIER_EXPECTED=应为字符串常量或标识符
FUNCTION_MUST_HAVE_DLLIMPORT_ATTRIBUTE=预期 DllImport 属性
EXPECTED_ATTRIBUTE_INITIALIZER=期望属性初始值设定项
CLASS_{0}_NOT_ATTRIBUTE=类 '{0}' 不是属性
ATTRIBUTE_{0}_NOT_APPLICABLE_TO_DELEGATE=属性 {0} 不适用于功能类型
ATTRIBUTE_{0}_NOT_APPLICABLE_TO_INTERFACE=属性 {0} 不适用于接口
ATTRIBUTE_{0}_NOT_APPLICABLE_TO_ENUM=属性 {0} 不适用于枚举
ATTRIBUTE_{0}_NOT_APPLICABLE_TO_CLASS=属性 {0} 不适用于类别
ATTRIBUTE_{0}_NOT_APPLICABLE_TO_STRUCT=属性 {0} 不适用于记录
ATTRIBUTE_{0}_NOT_APPLICABLE_TO_FIELD=属性 {0} 不适用于字段
ATTRIBUTE_{0}_NOT_APPLICABLE_TO_METHOD=属性 {0} 不适用于方法
ATTRIBUTE_{0}_NOT_APPLICABLE_TO_CONSTRUCTOR=属性 {0} 不适用于构造器
ATTRIBUTE_{0}_NOT_APPLICABLE_TO_PROPERTY=属性 {0} 不适用于属性
ATTRIBUTE_{0}_NOT_APPLICABLE_TO_EVENT=属性 {0} 不适用于事件
ATTRIBUTE_{0}_NOT_APPLICABLE_TO_PARAMETER=属性 {0} 不适用于参数
ATTRIBUTE_{0}_NOT_APPLICABLE_TO_ASSEMBLY=属性 {0} 不适用于程序集（单元）
INDEX_PROPERTY_INITIALIZING_NOT_VALID=索引属性初始化是不允许的
ATTRIBUTES_APPLICABLE_ONLY_TO_THESE_TYPES=属性仅适用于记录、类、接口、委托和枚举
DUPLICATE_ATTRIBUTE_{0}_APPLICATION=属性 {0} 不能适用两次
ATTRIBUTES_FOR_NESTED_FUNCTIONS_NOT_ALLOWED=嵌套子程序的属性是不允许的
DLLIMPORT_ATTRIBUTE_CANNOT_BE_APPLIED_TO_METHOD=方法不允许使用 DllImport 属性（仅适用于外部子程序）
EXPECTED_EXTERNAL_STATEMENT=外部预期
FUNCTION_MUST_HAVE_ONLY_EXTERNAL_STATEMENT=具有 DllImport 属性的外部子程序后的单元名称是非法的
FIELD_MUST_HAVE_FIELD_OFFSET_ATTRIBUTE=字段必须具有属性 FieldOffset
ALL_ENUM_CONSTANTS_NEEDED=必须显式声明枚举常量值
OUT_OF_RANGE=超出范围
EXPECTED_ASSEMBLY_NAME=应为程序集名称
EVENT_MUST_BE_IN_CLASS_OR_NAMESPACE=事件必须仅在类或单元中声明
RECORD_CONST_NOT_ALLOWED_{0}=不兼容的类型 '{0}' 和记录
ONLY_CLASS_CAN_BE_PARTIAL=partial 仅适用于类
OPERATORS_SHOULD_HAVE_{0}_PARAMETERS=预期有 {0} 个参数
OPERATOR_SHOULD_HAVE_1_PARAMETER=预期有 1 个参数
OPERATOR_SHOULD_HAVE_2_PARAMETERS=预期有 2 个参数
OPERATORS_SHOULD_HAVE_1_OR_2_PARAMETERS=预期有 1 个或 2 个参数
LEAST_ONE_PARAMETER_TYPE_SHOULD_EQ_DECLARING_TYPE_{0}=至少一个参数的类型应为 {0}
EXTENSION_ATTRIBUTE_ONLY_FOR_NAMESPACE_FUNCTIONS_ALLOWED=extensionmethod 属性只能应用于全局函数
EXTENSION_METHODS_MUST_HAVE_LEAST_ONE_PARAMETER=预期名称为 'self' 的参数
FIRST_PARAMETER_SHOULDBE_ONLY_VALUE_PARAMETER=扩展方法的第一个参数不允许使用 var
FIRST_PARAMETER_MUST_HAVE_NAME_SELF=预期名称为 'self' 的参数
EXTENSION_METHODS_FOR_CONSTRUCTED_TYPES_NOT_ALLOWED=无法扩展此类型
EXTENSION_METHODS_IN_INTERFACE_PART_NOT_ALLOWED=无法在单元的接口部分声明扩展方法
OPERATOR_SHOULD_BE_EXTENSION_METHOD=运算符应该是扩展方法
UNABLE_TO_CONVERT_FUNCTIONAL_TYPE_TO_PROCEDURAL_TYPE=无法将功能类型转换为过程类型
ILLEGAL_PARAMETERS_IN_LAMBDA=lambda 中的非法参数
ILLEGAL_LAMBDA_VARIABLE_TYPE=非法的 lambda 变量类型
ILLEGAL_LAMBDA_PARAMETERS_NUMBER=非法的 lambda 参数数量
IMPOSSIBLE_TO_INFER_TYPES_IN_LAMBDA=无法推断 lambda 中的类型
ANONYMOUS_DELEGATE_IN_INTERFACE_NOT_ALLOWED=不允许在接口中使用匿名委托。 显式声明委托类型。
PARAMETER_REFERENCE_IN_DEFAULT_PARAMETER_NOT_ALLOWED=不允许在默认参数值中引用参数
CANNOT_EVALUATE_FUNCTION_TYPE=无法推断函数的返回类型
TYPE_NAME_EXPECTED=应输入名称
EXPLICIT_IMPLEMENTATION_EXPECTED=预期方法实施
ANONYMOUS_FUNCTION_TYPE_WITH_GENERICS=匿名委托不能使用泛型参数
CLASS_NOT_IMPLEMENT_THIS_INTERFACE=类没有实现这个接口
INTERFACE_EXPECTED=预期界面
IMPLICIT_EXPLICIT_OPERATOR_EXTENSION_ONLY_FOR_COMPILED_CLASSES_ALLOWED=只能为来自另一个 .NET 程序集的类扩展隐式和显式运算符
EXTENSIONMETHOD_KEYWORD_NOT_ALLOWED=在此上下文中不允许使用扩展方法
CANNOT_EXTEND_STANDARD_OPERATORS_FOR_DELEGATE=不能为委托扩展运算符 +、+=、-、-=
FORWARD_EXTENSION_METHODS_NOT_ALLOWED=forward 属性不能应用于扩展方法
WHERE_SECTION_NOT_ALLOWED=无法将 'where' 应用于预定义类
GENERIC_PARAMETERS_MISMATCH=通用参数不匹配
EXPECTED_TYPE_AFTER_NEW=在预期的 'new' 之后键入
USE_ANONYMOUS_FUNCTION_TYPE_WITH_GENERICS=在通用子例程中使用匿名委托。 在过程外定义一个泛型委托，并用函数的泛型参数实例化它
WITH_AND_LAMBDAS_NOT_ALLOWED=不能在同一个函数中使用 'with' 和 lambda
GOTO_AND_LAMBDAS_NOT_ALLOWED=不能在同一个函数中使用 'goto' 和 lambda
NO_PROPERTY_TO_OVERRIDE=没有可覆盖的属性
TYPE_PREDEFINITION_NOT_ALLOWED=命名空间中的类型预定义
NAMESPACE_SHOULD_CONTAINS_ONLY_TYPES=预期的类、记录、枚举类型或功能类型
NAMESPACE_REDECLARATION=命名空间不能与单元名称或 .NET 命名空间相同
OVERRIDE_NOT_ALLOWED_FOR_SHORT_FUNCTIONS=不能在没有明确定义返回类型的情况下在短函数中使用覆盖
RETURN_VALUE_IMPLICIT_EXPLICIT_EXPECTED=不能在没有显式定义返回类型的情况下声明隐式和显式运算符
RETURN_TYPE_UNDEFINED_{0}=函数 {0} 的返回类型未定义且无法推导。 显式声明返回类型。
OPERATOR_RETURN_TYPE_UNDEFINED_{0}=运算符 {0} 的返回类型未定义且无法推导。 显式声明返回类型。
STRUCT_TYPE_DEFINITION_IN_AUTO_CLASS=自动类中的字段类型不能是记录或数组定义
EXTERNAL_METHOD_SHOULD_BE_STATIC=外部方法应该是静态的
ABSTRACT_CLASS_CANNOT_BE_SEALED=抽象类不能密封
ABSTRACT_CLASS_CANNOT_BE_SEALED_BECAUSE_METHOD_NOT_IMPLEMENTED=类 {0} 是抽象的，不能密封，因为方法 {1} 未实现
ABSTRACT_CLASS_CANNOT_BE_SEALED_BECAUSE_PROPERTIE_NOT_IMPLEMENTED=类 {0} 是抽象的，不能密封，因为属性 {1} 未实现
ABSTRACT_CLASS_CANNOT_BE_SEALED_BECAUSE_ABSTRACT_PROPERTIE=类 {0} 是抽象的，不能密封，因为属性 {1} 是抽象的
EXPRESSION_EXPECTED=预期的表达式
CLASS_ATTRIBUTE_NOT_ALLOWED_IN_CLASS_PREDEFINTIONS=不能在类预定义中声明类属性
GENERIC_RECORDS_CANNOT_HAVE_EXPLICIT_LAYOUT=通用记录不能具有属性 LayoutKind.&Explicit
ATTRIBUTE_CANNOT_BE_GENERIC=属性不能通用
EXTERNAL_METHOD_CANNOT_BE_DECLARED_IN_GENERIC_TYPE=外部方法不能在泛型中声明
EXTERNAL_METHOD_CANNOT_BE_GENERIC=外部方法不能通用
WHERE_SPECIFIER_MISMATCH=where 说明符与基类的 where 说明符相矛盾
ATTRIBUTE_{0}_NOT_ALLOWED=此上下文中不允许属性 {0}
ABSTRACT_PROPERTIES_CANNOT_HAVE_IMPLEMENTATION=抽象属性不能有实现
ONLY_CLASS_CAN_BE_STATIC=只有类可以是静态的
STATIC_CLASS_CANNOT_BE_GENERIC=静态类不能泛型
STATIC_CLASS_CANNOT_HAVE_PARENT=静态类不能派生自其他类或实现接口
STATIC_CLASSES_CANNOT_NON_STATIC_MEMBERS=静态类只能有静态成员
VARIABLES_OF_STATIC_CLASS_NOT_ALLOWED=不能声明类型为静态类的变量、参数、字段
STATIC_CONSTRUCTOR_CALL=不能实例化静态类
USING_STATIC_CLASS_NOT_VALID=在此上下文中不允许使用静态类
INTERFACE_PROPERTIES_CANNOT_BE_STATIC=接口属性不能是静态的
ARRAY_RANK_CANNOT_BE_GREATER_32=多维未调整大小数组的秩不能大于 32
CANNOT_GET_POINTER_TO_DISPOSE=无法获得指向内部过程 Dispose 的指针
USING_{0}_NOT_ALLOWED_IN_THIS_CONTEXT=在此上下文中不允许使用 {0}
OPERATORS_IN_INTERFACES_NOT_ALLOWED=接口不能包含运算符
STATIC_CLASS_CAN_NOT_BE_USED_AS_PARENT_SPECIFICATOR=静态类不能作为泛型约束
ENUM_MUST_HAVE_SEQUENCED_VALUES=枚举必须有顺序值
EXTERNAL_METHOD_CANNOT_BE_NESTED=嵌套函数不能是外部的
CANNOT_USE_RESERVED_ACCESSOR_NAMES=不能使用为属性访问器保留的名称声明类成员
PARTIAL_CLASS_ATTRIBUTES_MISMATCH=部分类属性不匹配
PARTIAL_CLASS_PARENTS_MISMATCH=部分声明不得指定不同的基类
PARAMETER_{0}_HAS_TYPE_{1}_FROM_UNIT_{2}=参数 {0} 具有来自单元 {2} 的类型 {1}。 将单元 {2} 添加到使用部分。
PARTIAL_CLASS_PREDEFINITION_NOT_ALLOWED=不允许预定义部分类
AMBIGUOUS_DELEGATES=检测到不明确的代表
EXPECTED_INTERFACE=预期的界面
EXPECTED_PROPERTY=预期的属性
NON_PUBLIC_RECORD_CONSTRUCTORS_NOT_ALLOWED=记录不能有非公共的默认构造函数
EXIT_BREAK_CONTINUE_IN_FINALLY_BLOCK=finally 中不允许退出、中断和继续
ANONYMOUS_DELEGATES_WITH_GENERIC_PARAMS_NOT_ALLOWED=无法推断具有泛型参数的匿名委托的类型。 显式声明变量类型。
CANNOT_IMPLEMENT_METHODS_IN_OTHER_MODULE=Can not implement methods in other module
DLLNAME_CANNOT_BE_EMPTY=Library name cannot be empty
%PREFIX%=COMPILATIONERROR_
UNIT_MODULE_EXPECTED_LIBRARY_FOUND=需要单元，找到库
ASSEMBLY_{0}_READING_ERROR=读取程序集 '{0}' 时出错
INVALID_ASSEMBLY_PATH=程序集路径包含无效字符
INCLUDE_NAMESPACE_IN_UNIT=不能在单元中使用 includenamespace
NAMESPACE_MODULE_EXPECTED=期望的命名空间