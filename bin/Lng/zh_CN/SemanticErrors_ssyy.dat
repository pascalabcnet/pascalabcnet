%PREFIX%=SEMANTICERROR_
TEMPLATE_ARGUMENTS_COUNT_MISMATCH=模板参数数量不匹配
{0}_IS_NOT_TEMPLATE_CLASS=非模板类型 '{0}' 不能与类型参数一起使用
TEMPLATE_PARAMETER_{0}_REDEFINITION=重复类型参数 '{0}'
INHERITED_CONSTRUCTOR_CALL_MUST_BE_FIRST=继承的构造函数调用必须首先在构造函数体中
INHERITED_CONSTRUCTOR_CALL_EXPECTED=预期继承的构造函数调用
IN_AUTOGENERATED_DEFAULT_CONSTRUCTOR_THE_DEFAULT_CONSTRUCTOR_OF_BASE_CLASS_CANNOT_BE_CALLED_BECAUSE_IS_ABSENT_OR_PRIVATE=在自动生成的默认构造函数中，无法调用基类的默认构造函数，因为它不存在或为私有
INVALID_INTERFACE_MEMBER=接口成员不能有定义
{0}_IS_NOT_INTERFACE='{0}' 不是界面
INTERFACE_FUNCTION_WITH_BODY=接口成员不能有定义
CONSTRUCTOR_IN_INTERFACE=接口不能包含构造函数
INTERFACE_{0}_CONSTRUCTOR_CALL=无法创建接口 '{0}' 的实例
CLASS_{0}_DOES_NOT_IMPLEMENT_MEMBER_{2}_OF_INTERFACE_{1}=类 '{0}' 未实现接口 '{1}' 的成员 '{2}'
MEMBER_{2}_OF_CLASS_{0}_FROM_INTERFACE_{1}_MUST_BE_PUBLIC_AND_NON_STATIC='{0}' 未实现接口成员 '{2}'。 该方法是静态的、非公共的或具有错误的返回类型
PROPERTY_{2}_OF_CLASS_{0}_FROM_INTERFACE_{1}_MUST_BE_PUBLIC_AND_NON_STATIC='{0}' 未实现接口成员 '{2}'。 该方法是静态的、非公共的或具有错误的返回类型
ATTRIBUTES_IN_INTERFACE_MEMBER=该属性对接口成员无效
MODIFER_BLOCK_{0}_CALL='{0}' 因其保护级别而无法访问
LEFT_RANGE_GREATER_THEN_RIGHT=左侧范围大于右侧
ACCESS_MODIFER_IN_INTERFACE=访问修饰符对接口成员无效
INTERFACE_FORWARD_DECLARATION=接口前向声明无效
FORWARD_DECLARATION_{0}_AS_BASE_TYPE=必须在此处解析类 '{0}'的前向声明才能将该类用作祖先
FORWARD_DECLARATION_OF_{0}_MISMATCH_DECLARATION=类型 '{0}' 的前向声明与声明不匹配
NO_TYPE_{0}_DEFINITION=没有类型 '{0}' 的定义
VIRTUAL_METHOD_IN_RECORD=记录中的虚拟方法无效
LABEL_CAN_NOT_BE_DECLARED_HERE=标签不能在这里声明
IDENT_{0}_IS_NOT_LABEL='{0}' 不是标签
LABEL_{0}_REDEFINED=标签重新定义
NO_LABEL_{0}_DEFINITION=没有名称为 '{0}' 的标签
BLOCKED_LABEL_{0}_GOTO=过程之间不允许使用 Goto 语句
CONSTRUCTOR_NOT_IN_CLASS=构造函数只能在类中定义
DESTRUCTOR_NOT_IN_CLASS=析构函数只能在类中定义
ASSIGN_TO_EVENT=Operator := 不能应用于事件； 使用 += 和 -=
DESTRUCTOR_IN_INTERFACE=接口不能包含析构函数
CAN_NOT_CALL_CONSTRUCTOR_AS_PROCEDURE=不能将构造函数作为过程调用
CANNOT_USE_POINTER_AS_GENERIC_ARGUMENT=不能使用指针类型作为泛型参数
PARAMETER_{0}_MUST_HAVE_DEFAULT_CONSTRUCTOR='{0}' 必须具有公共默认构造函数
PARAMETER_{0}_MUST_NOT_BE_ABSTRACT=类型 {0} 不能是抽象的
PARAMETER_{0}_MUST_BE_REFERENCE_TYPE='{0}' 必须是引用类型
PARAMETER_{0}_MUST_BE_VALUE_TYPE='{0}'必须是值类型
PARAMETER_{0}_MUST_BE_DERIVED_FROM_{1}=类型 '{0}' 不能用作类型参数，因为没有从 '{0}' 到 '{1}' 的隐式引用转换
PARAMETER_{0}_MUST_IMPLEMENT_INTERFACE_{1}=类型 '{0}' 能用作类型参数，因为 '{0}' 未实现接口 '{1}'
NO_MAIN_FUNCTION=main() 未找到
FUNCTION_SHOULD_RETURN_VALUE=函数应该返回一个值
FUNCTION_SHOULD_NOT_RETURN_VALUE=函数不应返回值
EXPECTED_TYPE_{0}=需要输入 '{0}'
CAN_NOT_WRITE_REFERENCE_DATA_TO_BINARY_FILE=无法在二进制文件中写入引用类型的数据
CAN_NOT_READ_REFERENCE_DATA_FROM_BINARY_FILE=无法从二进制文件中读取引用类型的数据
WHERE_SECTION_ALLOWED_ONLY_IN_GENERICS=非通用声明不允许约束
TEMPLATE_PARAMS_EXPECTED=模板类型必须有模板参数
CAN_NOT_GENERATE_ACCESSOR_{0}=无法生成访问器，因为名称 '{0}' 已被占用
EXPECTED_DERIVED_CLASSES=预期的父级或子级
SPECIFICATORS_FOR_{0}_ALREADY_EXIST=已经为类型参数 '{0}' 指定了约束子句。 类型参数的所有约束必须在单个 where 子句中指定
SPECIFICATOR_MUST_BE_TYPE_REFERENCE=约束必须是类型引用
PARENT_SPECIFICATOR_MUST_BE_FIRST=父约束必须是第一个指定的约束
CLASS_OR_RECORD_SPECIFICATOR_MUST_BE_FIRST=类/记录约束必须是第一个指定的约束
CONSTRUCTOR_SPECIFICATOR_MUST_BE_LAST=构造函数约束必须是最后指定的约束
OBJECT_CAN_NOT_BE_USED_AS_PARENT_SPECIFICATOR=约束不能是特殊类 'object'
RECORD_CAN_NOT_BE_USED_AS_PARENT_SPECIFICATOR=约束不能被记录
TYPE_{0}_DERIVED_FROM_ITSELF=循环基类依赖
AMBIGUITY_BETWEEN_NAMES_{0}_AND_{1}=名称 {0} 和 {1} 之间的歧义
POINTERS_OF_GENERIC_PARAMETERS_NOT_ALLOWED=无法声明指向泛型参数的指针
OPERATOR_AS_CAN_NOT_BE_USED_WITH_GENERIC_PARAMETER_{0}_WITHOUT_CLASS_CONSTRAINT=运算符无法应用于通用参数 '{0}'，等待 'class' 约束
FORWARD_DECLARATION_{0}_AS_IMPLEMENTING_INTERFACE=前向声明 '{0}' 不能用作实现接口
FORWARD_TEMPLATE_{0}_DECLARATION_MISMATCH_DECLARATION=前向模板声明 '{0}' 与声明不匹配
GENERIC_TYPE_NOT_ALLOWED_HERE=通用类型声明在此上下文中无效
STATIC_CONSTRUCTOR_MUST_BE_PARAMETERLESS=静态构造函数必须是无参数的
CONSTRUCTOR_CAN_NOT_BE_VIRTUAL=构造函数不能为虚
CANNOT_USE_DIAPASON_AS_GENERIC_ARGUMENT=不能将子范围类型用作通用参数
CANNOT_USE_BOUNDED_ARRAY_AS_GENERIC_ARGUMENT=不能使用有界数组类型作为泛型参数
CANNOT_USE_TYPED_FILE_AS_GENERIC_ARGUMENT=不能将类型化文件用作通用参数
INDEX_PROPERTY_ACCESSOR_CAN_NOT_BE_VARIABLE=索引属性访问器必须是方法
ACCESSOR_NAME_EXPECTED=预期访问者名称
PROPERTY_TYPE_MISMATCH_ACCESSOR_FIELD_TYPE=属性类型与访问器类型不一致
ERROR_LOADING_RESOURCE_FILE_{0}=加载资源文件 '{0}' 时出错
SAVE_ASSEMBLY_ERROR_{0}=保存程序集时出错: {0}
NO_FUNCTIONS_{0}_CAN_BE_USED_WITH_THIS_SPECIFICATION=没有可与此规范一起使用的函数 '{0}'
PROPERTY_IN_LEFT_PART_PLUS_MINUS_ASSIGN=不能在此上下文中使用属性
DEFAULT_VALUE_MUST_BE_ONLY_IN_FIRST_DECLARATION=具有默认值的参数必须是第一个指定的
STRUCT_TYPE_DEFINITION_IN_FORMAL_PARAM=形参类型不能为记录或数组定义
TYPE_OF_ONE_OR_MORE_OPERATOR_PARAMETERS_MUST_BE_{0}=其中一个运算符参数必须具有 '{0}' 类型
PARAMS_IN_OPERATOR=params 参数在操作符中无效
OPERATOR_{0}_PARAMETERS_COUNT_MUST_EQUAL_{1}=重载运算符 '{0}' 采用 {1} 个参数
ONLY_LAST_PARAMETER_CAN_BE_PARAMS=params 参数必须是形式参数列表中的最后一个参数
FUNCTION_WITH_PARAMS_PARAMETER_CAN_NOT_HAVE_DEFAULT_PARAMETERS=带有 params 参数的函数不能有默认参数
CAN_NOT_ASSIGN_TO_LEFT_PART=无法分配给表达式的左侧部分
CAN_NOT_ASSIGN_TO_CONSTANT_OBJECT=无法分配给常量对象
NO_OVERLOAD_FUNCTION_{0}_USEFUL_FOR_ACCESSOR=没有适合访问器的重载函数 '{0}'
ACCESSOR_CAN_BE_FIELD_OR_METHOD_ONLY=访问器只能是字段或方法
CAN_NOT_DEFINE_METHOD_OF_COMPILED_TYPE=无法定义编译类型的方法
NO_DEFAULT_PROPERTY_TO_FUNCTION_TYPE=函数类型没有默认属性
TYPE_{0}_HAS_{1}_GENERIC_PARAMETERS=使用泛型类型 '{0}' 需要 '{1}' 类型参数
TRIANGLE_BRACKETS_NOT_AWAITED=此表达式不能与类型参数一起使用
TRIANGLE_BRACKETS_NOT_ALLOWED_WITH_COMMON_FUNCTIONS=非泛型方法不能与类型参数一起使用
FUNCTION_{0}_DEPEND_FROM_{1}_TYPE_PARAMS=通用子程序 '{0}' 中类型参数的数量必须是 {1}
WHERE_SECTION_MUST_BE_ONLY_IN_FIRST_DECLARATION=where-section 在此上下文中无效
CAN_NOT_INHERIT_FROM_GENERIC_PARAMETER=无法从泛型参数派生
TYPE_{0}_INHERITS_SELF=类型 '{0}' 继承自自身
GENERIC_FUNCTION_{0}_CAN_NOT_BE_CALLED_WITH_THESE_PARAMETERS=无法使用这些参数调用通用函数 '{0}'
CAN_NOT_DEDUCE_TYPE_PARAMS_FROM_CALL_{0}=无法从用法中推断出方法 '{0}' 的类型参数。 尝试明确指定类型参数
CAN_NOT_CALL_ANY_GENERIC_FUNCTION_{0}_WITH_THESE_PARAMETERS='{0}' 的最佳重载方法匹配包含一些无效参数
OPERATOR_SIZEOF_CAN_NOT_BE_USED_WITH_GENERIC_TYPE=运算符 sizeof 不能应用于泛型
CAN_NOT_INHERIT_FROM_VALUE_TYPE=无法派生自特殊类 'System.ValueType'
CAN_NOT_INHERIT_FROM_POINTER=无法从指针导出
CAN_NOT_INHERIT_FROM_FUNCTION_TYPE=无法从函数类型派生
CAN_NOT_INHERIT_FROM_DELEGATE_TYPE=从 'System.Delegate' 和 'System.MulticastDelegate' 无法派生
INTERFACE_{0}_ALREADY_ADDED_TO_IMPLEMENTING_LIST='{0}' 已在接口列表中列出
CAN_NOT_CONVERT_TYPE_{0}_TO_INTERFACE_{1}=无法将类型 '{0}' 转换为接口 '{1}'
CLASS_FUNCTION_ATTRIBUTE_MISMATCH=需要一个类说明符
COULD_NOT_DEFINE_GENERIC_FUNCTION_OF_COMPILED_TYPE=无法定义编译类型的泛型方法
PARAMETER_{0}_MUST_BE_NAMED_{1}=编号为 {0} 的模板参数必须具有名称 '{1}'
TEMPLATES_AND_GENERICS_ARE_INCOMPATIBLE=模板和泛型不兼容（使用泛型参数作为模板参数是无效的）
TEMPLATE_CAN_BE_CLASS_ONLY=仅类、记录或接口可以是模板
CANNOT_USE_SHORT_STRING_AS_GENERIC_ARGUMENT=短字符串不能用作通用参数
TYPE_REFERENCE_EXPECTED=应输入名称
DELEGATE_CAN_NOT_USE_COMPREHENSIVE_GENERIC_PARAMETER=描述委托时，不能使用封闭的泛型类型参数
CAN_NOT_DEFINE_METHOD_OF_TEMPLATE_TYPE_SYNONYM=不允许为泛型类型同义词声明方法
ENUM_CAN_NOT_BE_USED_AS_PARENT_SPECIFICATOR=System.Enum 不能用作通用参数的父级
CONSTRUCTOR_CAN_NOT_BE_GENERIC=构造函数不能泛型
GENERIC_DELEGATE_INNER_FUNCTION=在子例程中定义泛型委托的类型是不可接受的
GENERIC_NESTED_FUNCTIONS_NOT_ALLOWED=不允许嵌套泛型
NESTED_FUNCTIONS_IN_GENERIC_FUNCTIONS_NOT_ALLOWED=泛型中的嵌套函数是不允许的
GENERIC_TYPE_{0}_NEEDS_{1}_GENERIC_PARAMETERS=通用类型 {0} 需要 {1} 个通用参数
EXPRESSION_IS_NOT_ADDRESSED=表达式不是左值
TYPE_REFERENCE_EXPECTED=应为 Tupe 名称
DELEGATE_CAN_NOT_USE_COMPREHENSIVE_GENERIC_PARAMETER=委托不能使用外部泛型参数
CAN_NOT_DEFINE_METHOD_OF_TEMPLATE_TYPE_SYNONYM=为泛型类型同义词定义方法是不可接受的
ENUM_CAN_NOT_BE_USED_AS_PARENT_SPECIFICATOR=System.Enum 不能用作泛型参数的父级
CONSTRUCTOR_CAN_NOT_BE_GENERIC=构造函数不能泛型
GENERIC_DELEGATE_INNER_FUNCTION=不能在子例程内定义通用委托
GENERIC_NESTED_FUNCTIONS_NOT_ALLOWED=不允许嵌套泛型
NESTED_FUNCTIONS_IN_GENERIC_FUNCTIONS_NOT_ALLOWED=不允许在遗传子例程中嵌套子例程
NESTED_RECORDS_IN_GENERIC_FUNCTIONS_NOT_ALLOWED=不允许在通用子程序中定义记录类型
GENERIC_TYPE_{0}_NEEDS_{1}_GENERIC_PARAMETERS=通用类型 {0} 需要 {1} 个通用参数
EXPRESSION_IS_NOT_ADDRESSED=表达式不是左值
