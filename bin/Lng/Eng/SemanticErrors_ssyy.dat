%PREFIX%=SEMANTICERROR_
TEMPLATE_ARGUMENTS_COUNT_MISMATCH=Mismatched number of template arguments
{0}_IS_NOT_TEMPLATE_CLASS=The non-template type '{0}' cannot be used with type arguments
TEMPLATE_PARAMETER_{0}_REDEFINITION=Duplicate type parameter '{0}'
INHERITED_CONSTRUCTOR_CALL_MUST_BE_FIRST=Inherited constructor call must be first in constructor body
INHERITED_CONSTRUCTOR_CALL_EXPECTED=Inherited constructor call expected
IN_AUTOGENERATED_DEFAULT_CONSTRUCTOR_THE_DEFAULT_CONSTRUCTOR_OF_BASE_CLASS_CANNOT_BE_CALLED_BECAUSE_IS_ABSENT_OR_PRIVATE=In autogenerated default constructor the default constructor of base class cannot be called because it is absent or private
INVALID_INTERFACE_MEMBER=Interface members cannot have definitions
{0}_IS_NOT_INTERFACE='{0}' is not interface
INTERFACE_FUNCTION_WITH_BODY=Interface members cannot have a definition
CONSTRUCTOR_IN_INTERFACE=Interfaces cannot contain constructors
INTERFACE_{0}_CONSTRUCTOR_CALL=Cannot create an instance of the interface '{0}'
CLASS_{0}_DOES_NOT_IMPLEMENT_MEMBER_{2}_OF_INTERFACE_{1}=Class '{0}' doesn't implement member '{2}' of interface '{1}'
MEMBER_{2}_OF_CLASS_{0}_FROM_INTERFACE_{1}_MUST_BE_PUBLIC_AND_NON_STATIC='{0}' does not implement interface member '{2}'. The method is static, not public, or has the wrong return type 
PROPERTY_{2}_OF_CLASS_{0}_FROM_INTERFACE_{1}_MUST_BE_PUBLIC_AND_NON_STATIC='{0}' does not implement interface member '{2}'. The method is static, not public, or has the wrong return type
ATTRIBUTES_IN_INTERFACE_MEMBER=This attribute is not valid for interface members
MODIFER_BLOCK_{0}_CALL='{0}' is inaccessible due to its protection level
LEFT_RANGE_GREATER_THEN_RIGHT=Left range is greater than right
ACCESS_MODIFER_IN_INTERFACE=Access modifiers are not valid for interface members
INTERFACE_FORWARD_DECLARATION=Interface forward declaration is not valid
FORWARD_DECLARATION_{0}_AS_BASE_TYPE=Forward declaration of class '{0}' must be resolved here to use the class as ancestor
FORWARD_DECLARATION_OF_{0}_MISMATCH_DECLARATION=Forward declaration of type '{0}' doesn't match declaration
NO_TYPE_{0}_DEFINITION=No definition for type '{0}'
VIRTUAL_METHOD_IN_RECORD=Virtual methods in records are not valid
LABEL_CAN_NOT_BE_DECLARED_HERE=Labels can not be declared here
IDENT_{0}_IS_NOT_LABEL='{0}' is not a label
LABEL_{0}_REDEFINED=Label redefinition
NO_LABEL_{0}_DEFINITION=No label with name '{0}'
BLOCKED_LABEL_{0}_GOTO=Goto statements aren't allowed between procedures
CONSTRUCTOR_NOT_IN_CLASS=Constructors can be defined only in class
DESTRUCTOR_NOT_IN_CLASS=Destructors can be defined only in class
ASSIGN_TO_EVENT=Operator := cannot be applied to events; use += and -=
DESTRUCTOR_IN_INTERFACE=Interfaces cannot contain destructors
CAN_NOT_CALL_CONSTRUCTOR_AS_PROCEDURE=Cannot call constructor as a procedure
CANNOT_USE_POINTER_AS_GENERIC_ARGUMENT=Cannot use pointer type as generic argument
PARAMETER_{0}_MUST_HAVE_DEFAULT_CONSTRUCTOR='{0}' must have public default constructor
PARAMETER_{0}_MUST_NOT_BE_ABSTRACT=Type {0} cannot be abstract
PARAMETER_{0}_MUST_BE_REFERENCE_TYPE='{0}' must be reference type
PARAMETER_{0}_MUST_BE_VALUE_TYPE='{0}' must be value type
PARAMETER_{0}_MUST_BE_DERIVED_FROM_{1}=The type '{0}' cannot be used as type parameter, because there is no implicit reference conversion from '{0}' to '{1}'
PARAMETER_{0}_MUST_IMPLEMENT_INTERFACE_{1}=The type '{0}' cannot be used as type parameter, because '{0}' doesn't implement interface '{1}'
NO_MAIN_FUNCTION=main() not found
FUNCTION_SHOULD_RETURN_VALUE=Function should return a value
FUNCTION_SHOULD_NOT_RETURN_VALUE=Function should not return a value
EXPECTED_TYPE_{0}=Type '{0}' expected
CAN_NOT_WRITE_REFERENCE_DATA_TO_BINARY_FILE=Cannot write the data of reference type in binary file
CAN_NOT_READ_REFERENCE_DATA_FROM_BINARY_FILE=Cannot read the data of reference type from binary file
WHERE_SECTION_ALLOWED_ONLY_IN_GENERICS=Constraints are not allowed on non-generic declarations
TEMPLATE_PARAMS_EXPECTED=Template type must have template arguments
CAN_NOT_GENERATE_ACCESSOR_{0}=Cannot generate accessor because name '{0}' is already occupied
EXPECTED_DERIVED_CLASSES=Ancestor or descendant expected
SPECIFICATORS_FOR_{0}_ALREADY_EXIST=A constraint clause has already been specified for type parameter '{0}'. All of the constraints for a type parameter must be specified in a single where clause
SPECIFICATOR_MUST_BE_TYPE_REFERENCE=Constraint must be type reference
PARENT_SPECIFICATOR_MUST_BE_FIRST=The parent constraint must be the first constrained specified
CLASS_OR_RECORD_SPECIFICATOR_MUST_BE_FIRST=The class/record constraint must be the first constrained specified
CONSTRUCTOR_SPECIFICATOR_MUST_BE_LAST=The constructor constraint must be the last constrained specified
OBJECT_CAN_NOT_BE_USED_AS_PARENT_SPECIFICATOR=Constraint cannot be special class 'object'
RECORD_CAN_NOT_BE_USED_AS_PARENT_SPECIFICATOR=Constraint cannot be record
TYPE_{0}_DERIVED_FROM_ITSELF=Circular base class dependency
AMBIGUITY_BETWEEN_NAMES_{0}_AND_{1}=Двусмысленность между именами {0} и {1}
POINTERS_OF_GENERIC_PARAMETERS_NOT_ALLOWED=Cannot declare a pointer to generic parameter
OPERATOR_AS_CAN_NOT_BE_USED_WITH_GENERIC_PARAMETER_{0}_WITHOUT_CLASS_CONSTRAINT=Operator as cannot be applied to generic parameter '{0}', 'class' constraint awaited
FORWARD_DECLARATION_{0}_AS_IMPLEMENTING_INTERFACE=Forward declaration '{0}' cannot be used as implementing interface
FORWARD_TEMPLATE_{0}_DECLARATION_MISMATCH_DECLARATION=Forward template declaration '{0}' doesn't match declaration
GENERIC_TYPE_NOT_ALLOWED_HERE=Generic type declaration is not valid in this context
STATIC_CONSTRUCTOR_MUST_BE_PARAMETERLESS=A static constructor must be parameterless
CONSTRUCTOR_CAN_NOT_BE_VIRTUAL=Constructor can not be virtual
CANNOT_USE_DIAPASON_AS_GENERIC_ARGUMENT=Cannot use subrange type as generic argument 
CANNOT_USE_BOUNDED_ARRAY_AS_GENERIC_ARGUMENT=Cannot use bounded array type as generic argument
CANNOT_USE_TYPED_FILE_AS_GENERIC_ARGUMENT=Cannot use typed file as generic argument
INDEX_PROPERTY_ACCESSOR_CAN_NOT_BE_VARIABLE=Index property accessor must be method
ACCESSOR_NAME_EXPECTED=Accessor name expected
PROPERTY_TYPE_MISMATCH_ACCESSOR_FIELD_TYPE=Property type doesn't coincide with type of accessor
ERROR_LOADING_RESOURCE_FILE_{0}=Error when loading resource file '{0}'
SAVE_ASSEMBLY_ERROR_{0}=Error when saving assembly: {0}
NO_FUNCTIONS_{0}_CAN_BE_USED_WITH_THIS_SPECIFICATION=There is no function '{0}', that can be used with this specification 
PROPERTY_IN_LEFT_PART_PLUS_MINUS_ASSIGN=Cannot use property in this context
DEFAULT_VALUE_MUST_BE_ONLY_IN_FIRST_DECLARATION=The parameter with default value must be the first specified 
STRUCT_TYPE_DEFINITION_IN_FORMAL_PARAM=Type of formal parameter cannot be record or array definition
TYPE_OF_ONE_OR_MORE_OPERATOR_PARAMETERS_MUST_BE_{0}=One of the operator parameters must have type '{0}'
PARAMS_IN_OPERATOR=A params parameters is not valid in operators
OPERATOR_{0}_PARAMETERS_COUNT_MUST_EQUAL_{1}=Overloaded operator '{0}' takes {1} parameters
ONLY_LAST_PARAMETER_CAN_BE_PARAMS=A params parameter must be the last parameter in a formal parameter list
FUNCTION_WITH_PARAMS_PARAMETER_CAN_NOT_HAVE_DEFAULT_PARAMETERS=A function with params parameter can not have default parameter
CAN_NOT_ASSIGN_TO_LEFT_PART=Cannot assign to left part of expression
CAN_NOT_ASSIGN_TO_CONSTANT_OBJECT=Cannot assign to constant object
NO_OVERLOAD_FUNCTION_{0}_USEFUL_FOR_ACCESSOR=Therer is no overloaded function '{0}' suitable for accessor
ACCESSOR_CAN_BE_FIELD_OR_METHOD_ONLY=An accessor can be only field or method
CAN_NOT_DEFINE_METHOD_OF_COMPILED_TYPE=Cannot define method of compiled type
NO_DEFAULT_PROPERTY_TO_FUNCTION_TYPE=No default property for function type
TYPE_{0}_HAS_{1}_GENERIC_PARAMETERS=Using the generic type '{0}' requires '{1}' type arguments
TRIANGLE_BRACKETS_NOT_AWAITED=This expression cannot be used with type arguments
TRIANGLE_BRACKETS_NOT_ALLOWED_WITH_COMMON_FUNCTIONS=Non-generic methods cannot be used with type arguments
FUNCTION_{0}_DEPEND_FROM_{1}_TYPE_PARAMS=The number of type parameters in generic subprogramm '{0}' must be {1} 
WHERE_SECTION_MUST_BE_ONLY_IN_FIRST_DECLARATION=where-section is not valid in this context
CAN_NOT_INHERIT_FROM_GENERIC_PARAMETER=Cannot derive from generic parameter
GENERIC_FUNCTION_{0}_CAN_NOT_BE_CALLED_WITH_THESE_PARAMETERS=Cannot call the generic function '{0}' with these arguments
CAN_NOT_DEDUCE_TYPE_PARAMS_FROM_CALL_{0}=The type arguments for method '{0}' cannot be inferred from the usage. Try specifying the type arguments explicitly
CAN_NOT_CALL_ANY_GENERIC_FUNCTION_{0}_WITH_THESE_PARAMETERS=The best overloaded method match for '{0}' has some invalid arguments
OPERATOR_SIZEOF_CAN_NOT_BE_USED_WITH_GENERIC_TYPE=Operator sizeof cannot be applied to generic type
CAN_NOT_INHERIT_FROM_VALUE_TYPE=Cannot derive from special class 'System.ValueType'
CAN_NOT_INHERIT_FROM_POINTER=Cannot derive from pointer
CAN_NOT_INHERIT_FROM_FUNCTION_TYPE=Cannot derive from function type
CAN_NOT_INHERIT_FROM_DELEGATE_TYPE=Cannot derive from 'System.Delegate' and 'System.MulticastDelegate'
INTERFACE_{0}_ALREADY_ADDED_TO_IMPLEMENTING_LIST='{0}' is already listed in interface list
CAN_NOT_CONVERT_TYPE_{0}_TO_INTERFACE_{1}=Cannot convert type '{0}' to interface '{1}'
CLASS_FUNCTION_ATTRIBUTE_MISMATCH=A class specifier expected
COULD_NOT_DEFINE_GENERIC_FUNCTION_OF_COMPILED_TYPE=Cannot define generic method of compiled type
PARAMETER_{0}_MUST_BE_NAMED_{1}=Template parameter with number {0} must have name '{1}'
TEMPLATES_AND_GENERICS_ARE_INCOMPATIBLE=Templates and generics are incompatible (using of generic parameter as template argument is not valid)
TEMPLATE_CAN_BE_CLASS_ONLY=Only class, record or interface can be template
CANNOT_USE_SHORT_STRING_AS_GENERIC_ARGUMENT=Short strings cannot be used as generic argument
TYPE_REFERENCE_EXPECTED=Type name expected
DELEGATE_CAN_NOT_USE_COMPREHENSIVE_GENERIC_PARAMETER=При описании делегата нельзя использовать тип-параметр объемлющего generic-шаблона 
CAN_NOT_DEFINE_METHOD_OF_TEMPLATE_TYPE_SYNONYM=Недопустимо описывать метод для синонима шаблонного типа
ENUM_CAN_NOT_BE_USED_AS_PARENT_SPECIFICATOR=System.Enum can not be used as parent for generic parameter
CONSTRUCTOR_CAN_NOT_BE_GENERIC=Constructor can not be generic
GENERIC_DELEGATE_INNER_FUNCTION=It is unacceptable to define type of a generic delegate in the subroutine
GENERIC_NESTED_FUNCTIONS_NOT_ALLOWED=Nested generics are not allowed
NESTED_FUNCTIONS_IN_GENERIC_FUNCTIONS_NOT_ALLOWED=Nested functions in generics are not allowed
GENERIC_TYPE_{0}_NEEDS_{1}_GENERIC_PARAMETERS=Generic type {0} needs {1} generic parameters
EXPRESSION_IS_NOT_ADDRESSED=expression is not lvalue
TYPE_REFERENCE_EXPECTED=Tupe name expected
DELEGATE_CAN_NOT_USE_COMPREHENSIVE_GENERIC_PARAMETER=Delegate can not use outer generic parameter
CAN_NOT_DEFINE_METHOD_OF_TEMPLATE_TYPE_SYNONYM=It is unacceptable to define method for generic type synonym 
ENUM_CAN_NOT_BE_USED_AS_PARENT_SPECIFICATOR=System.Enum can not be used as a parent for generic parameter
CONSTRUCTOR_CAN_NOT_BE_GENERIC=Constructor can not be generic
GENERIC_DELEGATE_INNER_FUNCTION=Generic delegate can not be defined inside a subroutine
GENERIC_NESTED_FUNCTIONS_NOT_ALLOWED=Nested generics are not allowed
NESTED_FUNCTIONS_IN_GENERIC_FUNCTIONS_NOT_ALLOWED=Nested subrotines inside generic subrotines are not allowed
NESTED_RECORDS_IN_GENERIC_FUNCTIONS_NOT_ALLOWED=Definition of record type inside generic subrotines is not allowed
GENERIC_TYPE_{0}_NEEDS_{1}_GENERIC_PARAMETERS=Generic type {0} needs {1} generic parameters
EXPRESSION_IS_NOT_ADDRESSED=This expression is not lvalue
