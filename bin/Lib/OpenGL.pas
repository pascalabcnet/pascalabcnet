
//*****************************************************************************************************\\
// Copyright (©) Cergey Latchenko ( github.com/SunSerega | forum.mmcs.sfedu.ru/u/sun_serega )
// This code is distributed under the Unlicense
// For details see LICENSE file or this:
// https://github.com/SunSerega/POCGL/blob/master/LICENSE
//*****************************************************************************************************\\
// Copyright (©) Сергей Латченко ( github.com/SunSerega | forum.mmcs.sfedu.ru/u/sun_serega )
// Этот код распространяется под Unlicense
// Для деталей смотрите в файл LICENSE или это:
// https://github.com/SunSerega/POCGL/blob/master/LICENSE
//*****************************************************************************************************\\

///
/// Код переведён отсюда:
/// https://github.com/KhronosGroup/OpenGL-Registry
/// (Основная часть не_расширений - \api\GL\ )
///
/// Спецификация (что то типа справки):
/// https://www.khronos.org/registry/OpenGL/specs/gl/glspec46.core.pdf
///
/// Если чего то не хватает - писать сюда:
/// https://github.com/SunSerega/POCGL/issues
///
unit OpenGL;

//ToDo матрицы в шейдерах передаются массивом столбцов
// - это может бить по производительности, потому что тут матрицы хранятся строками
// - разобраться - может там снова эта путаница и на самом деле в шейдере можно выбирать как хранится матрица
// - возможно придётся вывернуть все матрицы наизнанку... или добавить ещё типов матриц
//
// - ОБНОВЛЕНИЕ:
// - таки сделал пока что по столбцам, потому что увидел у 1 C++ библиотеки так
// - но всё же надо нормально разобраться самому
// - однако в конструктор значения передаются по строчкам, иначе надо вообще всё поменять

//ToDo в самом конце - сделать прогу чтоб посмотреть какие константы по 2 раза, а каких вообще нет

//ToDo Возможно *Name -ам сделать отдельные типы?

//ToDo проверить получение указателя на строчку матрицы

//ToDo проверить передачу external функции вместо лямбды

//ToDo SysInt - а это вообще работает так как я думаю?

//ToDo автоматический тестировщик
// - особенно для матриц надо...
// - и примеры тоже надо проверять после любых изменений

//ToDo .ToString всех энумов, которые может возвращать
// - тупо пройтись по всем энумам, посмотреть де они заюзаны
// - там куча всего сразу проверится

//ToDo issue компилятора:
// - #2029

uses System;
uses System.Runtime.InteropServices;

{$region Основные типы}

type
  
  GLsync                        = IntPtr;
  GLeglImageOES                 = IntPtr;
  
  QueryName                     = UInt32;
  BufferName                    = UInt32;
  ShaderName                    = UInt32;
  ProgramName                   = UInt32;
  ProgramPipelineName           = UInt32;
  TextureName                   = UInt32;
  SamplerName                   = UInt32;
  FramebufferName               = UInt32;
  RenderbufferName              = UInt32;
  VertexArrayName               = UInt32;
  TransformFeedbackName         = UInt32;
  
  GLContext                     = UInt32;
  GDI_DC                        = IntPtr;
  
  ShaderBinaryFormat            = UInt32;
  ProgramResourceIndex          = UInt32;
  ProgramBinaryFormat           = UInt32;
  
  GLhandleARB                   = UInt32;
  GLeglClientBufferEXT          = IntPtr;
  GLvdpauSurfaceNV              = IntPtr;
  
  
  
  // типы для совместимости с OpenCL
  ///--
  cl_context                    = IntPtr;
  ///--
  cl_event                      = IntPtr;
  
  
  
  OpenGLException = class(Exception)
    
    constructor(text: string) :=
    inherited Create($'Ошибка OpenGL: "{text}"');
    
  end;
  
{$endregion Основные типы}

{$region Энумы} type
  
  {$region case Result of}
  
  //R
  ErrorCode = record
    public val: UInt32;
    
    public const NO_ERROR =                                 0;
    public const FRAMEBUFFER_COMPLETE =                     $8CD5;
    
    public const INVALID_ENUM =                             $0500;
    public const INVALID_VALUE =                            $0501;
    public const INVALID_OPERATION =                        $0502;
    public const STACK_OVERFLOW =                           $0503;
    public const STACK_UNDERFLOW =                          $0504;
    public const OUT_OF_MEMORY =                            $0505;
    public const INVALID_FRAMEBUFFER_OPERATION =            $0506;
    public const CONTEXT_LOST =                             $0507;
    
    public const GUILTY_CONTEXT_RESET =                     $8253;
    public const INNOCENT_CONTEXT_RESET =                   $8254;
    public const UNKNOWN_CONTEXT_RESET =                    $8255;
    
    ///Устарело, в 3.1 уже не существует
    public const TABLE_TOO_LARGE =                          $8031;
    
    
    
    public function ToString: string; override;
    begin
      var res := typeof(ErrorCode).GetFields.Where(fi->fi.IsLiteral).FirstOrDefault(prop->integer(prop.GetValue(nil)) = self.val);
      Result := res=nil?
        $'ErrorCode[${self.val:X}]':
        res.Name.ToWords('_').Select(w->w[1].ToUpper+w.Substring(1).ToLower).JoinIntoString;
    end;
    
    public procedure RaiseIfError :=
    case val of
      NO_ERROR, FRAMEBUFFER_COMPLETE: ;
      else raise new OpenGLException(self.ToString);
    end;
    
  end;
  
  {$endregion case Result of}
  
  {$region 1 значение}
  
  {$region ...InfoType}
  
  //S
  RenderbufferInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property WIDTH:           RenderbufferInfoType read new RenderbufferInfoType($8D42);
    public static property HEIGHT:          RenderbufferInfoType read new RenderbufferInfoType($8D43);
    public static property INTERNAL_FORMAT: RenderbufferInfoType read new RenderbufferInfoType($8D44);
    public static property SAMPLES:         RenderbufferInfoType read new RenderbufferInfoType($8CAB);
    public static property RED_SIZE:        RenderbufferInfoType read new RenderbufferInfoType($8D50);
    public static property GREEN_SIZE:      RenderbufferInfoType read new RenderbufferInfoType($8D51);
    public static property BLUE_SIZE:       RenderbufferInfoType read new RenderbufferInfoType($8D52);
    public static property ALPHA_SIZE:      RenderbufferInfoType read new RenderbufferInfoType($8D53);
    public static property DEPTH_SIZE:      RenderbufferInfoType read new RenderbufferInfoType($8D54);
    public static property STENCIL_SIZE:    RenderbufferInfoType read new RenderbufferInfoType($8D55);
    
  end;
  
  //S
  ActiveSubroutineInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property UNIFORMS:              ActiveSubroutineInfoType read new ActiveSubroutineInfoType($8DE6);
    public static property UNIFORM_LOCATIONS:     ActiveSubroutineInfoType read new ActiveSubroutineInfoType($8E47);
    public static property GL_ACTIVE_SUBROUTINES: ActiveSubroutineInfoType read new ActiveSubroutineInfoType($8DE5);
    public static property UNIFORM_MAX_LENGTH:    ActiveSubroutineInfoType read new ActiveSubroutineInfoType($8E49);
    public static property MAX_LENGTH:            ActiveSubroutineInfoType read new ActiveSubroutineInfoType($8E48);
    
  end;
  
  //S
  ProgramPipelineInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ACTIVE_PROGRAM:          ProgramPipelineInfoType read new ProgramPipelineInfoType($8259);
    public static property VERTEX_SHADER:           ProgramPipelineInfoType read new ProgramPipelineInfoType($8B31);
    public static property TESS_CONTROL_SHADER:     ProgramPipelineInfoType read new ProgramPipelineInfoType($8E88);
    public static property TESS_EVALUATION_SHADER:  ProgramPipelineInfoType read new ProgramPipelineInfoType($8E87);
    public static property GEOMETRY_SHADER:         ProgramPipelineInfoType read new ProgramPipelineInfoType($8DD9);
    public static property FRAGMENT_SHADER:         ProgramPipelineInfoType read new ProgramPipelineInfoType($8B30);
    public static property COMPUTE_SHADER:          ProgramPipelineInfoType read new ProgramPipelineInfoType($91B9);
    public static property VALIDATE_STATUS:         ProgramPipelineInfoType read new ProgramPipelineInfoType($8B83);
    public static property INFO_LOG_LENGTH:         ProgramPipelineInfoType read new ProgramPipelineInfoType($8B84);
    
  end;
  
  //S
  ProgramInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property DELETE_STATUS:                         ProgramInfoType read new ProgramInfoType($8B80);
    public static property LINK_STATUS:                           ProgramInfoType read new ProgramInfoType($8B82);
    public static property VALIDATE_STATUS:                       ProgramInfoType read new ProgramInfoType($8B83);
    public static property INFO_LOG_LENGTH:                       ProgramInfoType read new ProgramInfoType($8B84);
    public static property ATTACHED_SHADERS:                      ProgramInfoType read new ProgramInfoType($8B85);
    public static property ACTIVE_ATTRIBUTES:                     ProgramInfoType read new ProgramInfoType($8B89);
    public static property ACTIVE_ATTRIBUTE_MAX_LENGTH:           ProgramInfoType read new ProgramInfoType($8B8A);
    public static property ACTIVE_UNIFORMS:                       ProgramInfoType read new ProgramInfoType($8B86);
    public static property ACTIVE_UNIFORM_MAX_LENGTH:             ProgramInfoType read new ProgramInfoType($8B87);
    public static property TRANSFORM_FEEDBACK_BUFFER_MODE:        ProgramInfoType read new ProgramInfoType($8C7F);
    public static property TRANSFORM_FEEDBACK_VARYINGS:           ProgramInfoType read new ProgramInfoType($8C83);
    public static property TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH: ProgramInfoType read new ProgramInfoType($8C76);
    public static property ACTIVE_UNIFORM_BLOCKS:                 ProgramInfoType read new ProgramInfoType($8A36);
    public static property ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH:  ProgramInfoType read new ProgramInfoType($8A35);
    public static property GEOMETRY_VERTICES_OUT:                 ProgramInfoType read new ProgramInfoType($8916);
    public static property GEOMETRY_INPUT_TYPE:                   ProgramInfoType read new ProgramInfoType($8917);
    public static property GEOMETRY_OUTPUT_TYPE:                  ProgramInfoType read new ProgramInfoType($8918);
    public static property GEOMETRY_SHADER_INVOCATIONS:           ProgramInfoType read new ProgramInfoType($887F);
    public static property TESS_CONTROL_OUTPUT_VERTICES:          ProgramInfoType read new ProgramInfoType($8E75);
    public static property TESS_GEN_MODE:                         ProgramInfoType read new ProgramInfoType($8E76);
    public static property TESS_GEN_SPACING:                      ProgramInfoType read new ProgramInfoType($8E77);
    public static property TESS_GEN_VERTEX_ORDER:                 ProgramInfoType read new ProgramInfoType($8E78);
    public static property TESS_GEN_POINT_MODE:                   ProgramInfoType read new ProgramInfoType($8E79);
    public static property COMPUTE_WORK_GROUP_SIZE:               ProgramInfoType read new ProgramInfoType($8267);
    public static property PROGRAM_SEPARABLE:                     ProgramInfoType read new ProgramInfoType($8258);
    public static property PROGRAM_BINARY_RETRIEVABLE_HINT:       ProgramInfoType read new ProgramInfoType($8257);
    public static property ACTIVE_ATOMIC_COUNTER_BUFFERS:         ProgramInfoType read new ProgramInfoType($92D9);
    
  end;
  
  //S
  ShaderInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SHADER_TYPE:           ShaderInfoType read new ShaderInfoType($8B4F);
    public static property DELETE_STATUS:         ShaderInfoType read new ShaderInfoType($8B80);
    public static property COMPILE_STATUS:        ShaderInfoType read new ShaderInfoType($8B81);
    public static property INFO_LOG_LENGTH:       ShaderInfoType read new ShaderInfoType($8B84);
    public static property SHADER_SOURCE_LENGTH:  ShaderInfoType read new ShaderInfoType($8B88);
    public static property SPIR_V_BINARY:         ShaderInfoType read new ShaderInfoType($9552);
    
  end;
  
  //S
  SyncObjInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property OBJECT_TYPE:     SyncObjInfoType read new SyncObjInfoType($9112);
    public static property SYNC_CONDITION:  SyncObjInfoType read new SyncObjInfoType($9113);
    public static property SYNC_STATUS:     SyncObjInfoType read new SyncObjInfoType($9114);
    public static property SYNC_FLAGS:      SyncObjInfoType read new SyncObjInfoType($9115);
    
  end;
  
  //S
  QueryTargetType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SAMPLES_PASSED:                        QueryTargetType read new QueryTargetType($8914);
    public static property ANY_SAMPLES_PASSED:                    QueryTargetType read new QueryTargetType($8C2F);
    public static property ANY_SAMPLES_PASSED_CONSERVATIVE:       QueryTargetType read new QueryTargetType($8D6A);
    public static property PRIMITIVES_GENERATED:                  QueryTargetType read new QueryTargetType($8C87);
    public static property TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: QueryTargetType read new QueryTargetType($8C88);
    public static property TIME_ELAPSED:                          QueryTargetType read new QueryTargetType($88BF);
    public static property TIMESTAMP:                             QueryTargetType read new QueryTargetType($8E28);
    
  end;
  
  //S
  GetQueryInfoName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property QUERY_COUNTER_BITS:  GetQueryInfoName read new GetQueryInfoName($8864);
    public static property CURRENT_QUERY:       GetQueryInfoName read new GetQueryInfoName($8865);
    
  end;
  
  //S
  GetQueryObjectInfoName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property RESULT:            GetQueryObjectInfoName read new GetQueryObjectInfoName($8866);
    public static property RESULT_AVAILABLE:  GetQueryObjectInfoName read new GetQueryObjectInfoName($8867);
    
  end;
  
  //S
  BufferInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SIZE:              BufferInfoType read new BufferInfoType($8764);
    public static property USAGE:             BufferInfoType read new BufferInfoType($8765);
    public static property ACCESS:            BufferInfoType read new BufferInfoType($88BB);
    public static property ACCESS_FLAGS:      BufferInfoType read new BufferInfoType($911F);
    public static property IMMUTABLE_STORAGE: BufferInfoType read new BufferInfoType($821F);
    public static property MAPPED:            BufferInfoType read new BufferInfoType($88BC);
    public static property MAP_LENGTH:        BufferInfoType read new BufferInfoType($9120);
    public static property MAP_OFFSET:        BufferInfoType read new BufferInfoType($9121);
    public static property STORAGE_FLAGS:     BufferInfoType read new BufferInfoType($8220);
    public static property MAP_POINTER:       BufferInfoType read new BufferInfoType($88BD);
    
  end;
  
  {$endregion ...InfoType}
  
  //S
  CompatibilityViewClassType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property C_128_BITS:        CompatibilityViewClassType read new CompatibilityViewClassType($82C4);
    public static property C_96_BITS:         CompatibilityViewClassType read new CompatibilityViewClassType($82C5);
    public static property C_64_BITS:         CompatibilityViewClassType read new CompatibilityViewClassType($82C6);
    public static property C_48_BITS:         CompatibilityViewClassType read new CompatibilityViewClassType($82C7);
    public static property C_32_BITS:         CompatibilityViewClassType read new CompatibilityViewClassType($82C8);
    public static property C_24_BITS:         CompatibilityViewClassType read new CompatibilityViewClassType($82C9);
    public static property C_16_BITS:         CompatibilityViewClassType read new CompatibilityViewClassType($82CA);
    public static property C_8_BITS:          CompatibilityViewClassType read new CompatibilityViewClassType($82CB);
    public static property C_S3TC_DXT1_RGB:   CompatibilityViewClassType read new CompatibilityViewClassType($82CC);
    public static property C_S3TC_DXT1_RGBA:  CompatibilityViewClassType read new CompatibilityViewClassType($82CD);
    public static property C_S3TC_DXT3_RGBA:  CompatibilityViewClassType read new CompatibilityViewClassType($82CE);
    public static property C_S3TC_DXT5_RGBA:  CompatibilityViewClassType read new CompatibilityViewClassType($82CF);
    public static property C_RGTC1_RED:       CompatibilityViewClassType read new CompatibilityViewClassType($82D0);
    public static property C_RGTC2_RG:        CompatibilityViewClassType read new CompatibilityViewClassType($82D1);
    public static property C_BPTC_UNORM:      CompatibilityViewClassType read new CompatibilityViewClassType($82D2);
    public static property C_BPTC_FLOAT:      CompatibilityViewClassType read new CompatibilityViewClassType($82D3);
    
  end;
  
  //S
  CompatibilityImageClassType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property C_4_X_32:      CompatibilityImageClassType read new CompatibilityImageClassType($82B9);
    public static property C_2_X_32:      CompatibilityImageClassType read new CompatibilityImageClassType($82BA);
    public static property C_1_X_32:      CompatibilityImageClassType read new CompatibilityImageClassType($82BB);
    public static property C_4_X_16:      CompatibilityImageClassType read new CompatibilityImageClassType($82BC);
    public static property C_2_X_16:      CompatibilityImageClassType read new CompatibilityImageClassType($82BD);
    public static property C_1_X_16:      CompatibilityImageClassType read new CompatibilityImageClassType($82BE);
    public static property C_4_X_8:       CompatibilityImageClassType read new CompatibilityImageClassType($82BF);
    public static property C_2_X_8:       CompatibilityImageClassType read new CompatibilityImageClassType($82C0);
    public static property C_1_X_8:       CompatibilityImageClassType read new CompatibilityImageClassType($82C1);
    public static property C_11_11_10:    CompatibilityImageClassType read new CompatibilityImageClassType($82C2);
    public static property C_10_10_10_2:  CompatibilityImageClassType read new CompatibilityImageClassType($82C3);
    
  end;
  
  //S
  ImageFormatCompatibilityMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property COMPATIBILITY1_BY_SIZE:  ImageFormatCompatibilityMode read new ImageFormatCompatibilityMode($90C8);
    public static property COMPATIBILITY2_BY_CLASS: ImageFormatCompatibilityMode read new ImageFormatCompatibilityMode($90C9);
    public static property NONE:                    ImageFormatCompatibilityMode read new ImageFormatCompatibilityMode($90C9);
    
  end;
  
  //S
  SupportLevel = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE:            SupportLevel read new SupportLevel(0);
    public static property FULL_SUPPORT:    SupportLevel read new SupportLevel($82B7);
    public static property CAVEAT_SUPPORT:  SupportLevel read new SupportLevel($82B8);
    
  end;
  
  //S
  GDI_LayerType = record
    public val: Byte;
    public constructor(val: Byte) := self.val := val;
    
    public static property MAIN_PLANE:      GDI_LayerType read new GDI_LayerType(0);
    public static property OVERLAY_PLANE:   GDI_LayerType read new GDI_LayerType(1);
    public static property UNDERLAY_PLANE:  GDI_LayerType read new GDI_LayerType(-1);
    
  end;
  
  //S
  GDI_PixelDataType = record
    public val: Byte;
    public constructor(val: Byte) := self.val := val;
    
    public static property RGBA:        GDI_PixelDataType read new GDI_PixelDataType(0);
    public static property COLORINDEX:  GDI_PixelDataType read new GDI_PixelDataType(1);
    
  end;
  
  //S
  CopyableImageBuffer = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property COLOR:   CopyableImageBuffer read new CopyableImageBuffer($1800);
    public static property DEPTH:   CopyableImageBuffer read new CopyableImageBuffer($1801);
    public static property STENCIL: CopyableImageBuffer read new CopyableImageBuffer($1802);
    
  end;
  
  //S
  VertexProvokingMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FIRST_VERTEX_CONVENTION: VertexProvokingMode read new VertexProvokingMode($8E4D);
    public static property LAST_VERTEX_CONVENTION:  VertexProvokingMode read new VertexProvokingMode($8E4E);
    
  end;
  
  //S
  SwizzleMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property RED:   SwizzleMode read new SwizzleMode($1903);
    public static property GREEN: SwizzleMode read new SwizzleMode($1904);
    public static property BLUE:  SwizzleMode read new SwizzleMode($1905);
    public static property ALPHA: SwizzleMode read new SwizzleMode($1906);
    public static property ZERO:  SwizzleMode read new SwizzleMode(0);
    public static property ONE:   SwizzleMode read new SwizzleMode(1);
    
  end;
  
  //S
  DepthStencilMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property DEPTH_COMPONENT: DepthStencilMode read new DepthStencilMode($1902);
    public static property STENCIL_INDEX:   DepthStencilMode read new DepthStencilMode($1901);
    
  end;
  
  //S
  PixelWrapMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property CLAMP_TO_EDGE:         PixelWrapMode read new PixelWrapMode($812F);
    public static property &REPEAT:               PixelWrapMode read new PixelWrapMode($2901);
    public static property CLAMP_TO_BORDER:       PixelWrapMode read new PixelWrapMode($812D);
    public static property MIRRORED_REPEAT:       PixelWrapMode read new PixelWrapMode($8370);
    public static property MIRROR_CLAMP_TO_EDGE:  PixelWrapMode read new PixelWrapMode($8743);
    
  end;
  
  //S
  TextureCompareMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE:                    TextureCompareMode read new TextureCompareMode(0);
    public static property COMPARE_REF_TO_TEXTURE:  TextureCompareMode read new TextureCompareMode($884E);
    
  end;
  
  //S
  ReservedTimeoutMode = record
    public val: uint64;
    public constructor(val: uint64) := self.val := val;
    
    public static property GL_TIMEOUT_IGNORED:  ReservedTimeoutMode read new ReservedTimeoutMode(uint64.MaxValue);
    
  end;
  
  //S
  InternalFormatInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property INTERNALFORMAT_SUPPORTED:                InternalFormatInfoType read new InternalFormatInfoType($826F);
    public static property INTERNALFORMAT_PREFERRED:                InternalFormatInfoType read new InternalFormatInfoType($8270);
    public static property INTERNALFORMAT_RED_SIZE:                 InternalFormatInfoType read new InternalFormatInfoType($8271);
    public static property INTERNALFORMAT_RED_TYPE:                 InternalFormatInfoType read new InternalFormatInfoType($8278);
    public static property MAX_WIDTH:                               InternalFormatInfoType read new InternalFormatInfoType($827E);
    public static property MAX_HEIGHT:                              InternalFormatInfoType read new InternalFormatInfoType($827F);
    public static property MAX_DEPTH:                               InternalFormatInfoType read new InternalFormatInfoType($8280);
    public static property MAX_LAYERS:                              InternalFormatInfoType read new InternalFormatInfoType($8281);
    public static property COLOR_COMPONENTS:                        InternalFormatInfoType read new InternalFormatInfoType($8283);
    public static property COLOR_RENDERABLE:                        InternalFormatInfoType read new InternalFormatInfoType($8286);
    public static property DEPTH_RENDERABLE:                        InternalFormatInfoType read new InternalFormatInfoType($8287);
    public static property STENCIL_RENDERABLE:                      InternalFormatInfoType read new InternalFormatInfoType($8288);
    public static property FRAMEBUFFER_RENDERABLE:                  InternalFormatInfoType read new InternalFormatInfoType($8289);
    public static property FRAMEBUFFER_RENDERABLE_LAYERED:          InternalFormatInfoType read new InternalFormatInfoType($828A);
    public static property FRAMEBUFFER_BLEND:                       InternalFormatInfoType read new InternalFormatInfoType($828B);
    public static property READ_PIXELS:                             InternalFormatInfoType read new InternalFormatInfoType($828C);
    public static property READ_PIXELS_FORMAT:                      InternalFormatInfoType read new InternalFormatInfoType($828D);
    public static property READ_PIXELS_TYPE:                        InternalFormatInfoType read new InternalFormatInfoType($828E);
    public static property GET_TEXTURE_IMAGE_FORMAT:                InternalFormatInfoType read new InternalFormatInfoType($8291);
    public static property GET_TEXTURE_IMAGE_TYPE:                  InternalFormatInfoType read new InternalFormatInfoType($8292);
    public static property TEXTURE_IMAGE_FORMAT:                    InternalFormatInfoType read new InternalFormatInfoType($828F);
    public static property TEXTURE_IMAGE_TYPE:                      InternalFormatInfoType read new InternalFormatInfoType($8290);
    public static property MIPMAP:                                  InternalFormatInfoType read new InternalFormatInfoType($8293);
    public static property GENERATE_MIPMAP:                         InternalFormatInfoType read new InternalFormatInfoType($8191);
    public static property AUTO_GENERATE_MIPMAP:                    InternalFormatInfoType read new InternalFormatInfoType($8295);
    public static property COLOR_ENCODING:                          InternalFormatInfoType read new InternalFormatInfoType($8296);
    public static property SRGB_READ:                               InternalFormatInfoType read new InternalFormatInfoType($8297);
    public static property SRGB_WRITE:                              InternalFormatInfoType read new InternalFormatInfoType($8298);
    public static property FILTER:                                  InternalFormatInfoType read new InternalFormatInfoType($829A);
    public static property VERTEX_TEXTURE:                          InternalFormatInfoType read new InternalFormatInfoType($829B);
    public static property TESS_CONTROL_TEXTURE:                    InternalFormatInfoType read new InternalFormatInfoType($829C);
    public static property TESS_EVALUATION_TEXTURE:                 InternalFormatInfoType read new InternalFormatInfoType($829D);
    public static property GEOMETRY_TEXTURE:                        InternalFormatInfoType read new InternalFormatInfoType($829E);
    public static property FRAGMENT_TEXTURE:                        InternalFormatInfoType read new InternalFormatInfoType($829F);
    public static property COMPUTE_TEXTURE:                         InternalFormatInfoType read new InternalFormatInfoType($82A0);
    public static property TEXTURE_SHADOW:                          InternalFormatInfoType read new InternalFormatInfoType($82A1);
    public static property TEXTURE_GATHER:                          InternalFormatInfoType read new InternalFormatInfoType($82A2);
    public static property TEXTURE_GATHER_SHADOW:                   InternalFormatInfoType read new InternalFormatInfoType($82A3);
    public static property SHADER_IMAGE_LOAD:                       InternalFormatInfoType read new InternalFormatInfoType($82A4);
    public static property SHADER_IMAGE_STORE:                      InternalFormatInfoType read new InternalFormatInfoType($82A5);
    public static property SHADER_IMAGE_ATOMIC:                     InternalFormatInfoType read new InternalFormatInfoType($82A6);
    public static property IMAGE_TEXEL_SIZE:                        InternalFormatInfoType read new InternalFormatInfoType($82A7);
    public static property IMAGE_COMPATIBILITY_CLASS:               InternalFormatInfoType read new InternalFormatInfoType($82A8);
    public static property IMAGE_PIXEL_FORMAT:                      InternalFormatInfoType read new InternalFormatInfoType($82A9);
    public static property IMAGE_PIXEL_TYPE:                        InternalFormatInfoType read new InternalFormatInfoType($82AA);
    public static property IMAGE_FORMAT_COMPATIBILITY_TYPE:         InternalFormatInfoType read new InternalFormatInfoType($90C7);
    public static property SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST:     InternalFormatInfoType read new InternalFormatInfoType($82AC);
    public static property SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST:   InternalFormatInfoType read new InternalFormatInfoType($82AD);
    public static property SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE:    InternalFormatInfoType read new InternalFormatInfoType($82AE);
    public static property SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE:  InternalFormatInfoType read new InternalFormatInfoType($82AF);
    public static property TEXTURE_COMPRESSED:                      InternalFormatInfoType read new InternalFormatInfoType($86A1);
    public static property TEXTURE_COMPRESSED_BLOCK_WIDTH:          InternalFormatInfoType read new InternalFormatInfoType($82B1);
    public static property TEXTURE_COMPRESSED_BLOCK_HEIGHT:         InternalFormatInfoType read new InternalFormatInfoType($82B2);
    public static property TEXTURE_COMPRESSED_BLOCK_SIZE:           InternalFormatInfoType read new InternalFormatInfoType($82B3);
    public static property CLEAR_BUFFER:                            InternalFormatInfoType read new InternalFormatInfoType($82B4);
    public static property TEXTURE_VIEW:                            InternalFormatInfoType read new InternalFormatInfoType($82B5);
    public static property VIEW_COMPATIBILITY_CLASS:                InternalFormatInfoType read new InternalFormatInfoType($82B6);
    public static property CLEAR_TEXTURE:                           InternalFormatInfoType read new InternalFormatInfoType($9365);
    
  end;
  
  //S
  TransformFeedbackInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BUFFER_BINDING:  TransformFeedbackInfoType read new TransformFeedbackInfoType($8C8F);
    public static property BUFFER_START:    TransformFeedbackInfoType read new TransformFeedbackInfoType($8C84);
    public static property BUFFER_SIZE:     TransformFeedbackInfoType read new TransformFeedbackInfoType($8C85);
    public static property PAUSED:          TransformFeedbackInfoType read new TransformFeedbackInfoType($8E23);
    public static property ACTIVE:          TransformFeedbackInfoType read new TransformFeedbackInfoType($8E24);
    
  end;
  
  //S
  HintValue = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FASTEST:   HintValue read new HintValue($1101);
    public static property NICEST:    HintValue read new HintValue($1102);
    public static property DONT_CARE: HintValue read new HintValue($1100);
    
  end;
  
  //S
  HintType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property LINE_SMOOTH_HINT:                HintType read new HintType($0C52);
    public static property POLYGON_SMOOTH_HINT:             HintType read new HintType($0C53);
    public static property TEXTURE_COMPRESSION_HINT:        HintType read new HintType($84EF);
    public static property FRAGMENT_SHADER_DERIVATIVE_HINT: HintType read new HintType($8B8B);
    
  end;
  
  //S
  ObjectType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BUFFER:              ObjectType read new ObjectType($82E0);
    public static property FRAMEBUFFER:         ObjectType read new ObjectType($8D40);
    public static property PROGRAM_PIPELINE:    ObjectType read new ObjectType($82E4);
    public static property &PROGRAM:            ObjectType read new ObjectType($82E2);
    public static property QUERY:               ObjectType read new ObjectType($82E3);
    public static property RENDERBUFFER:        ObjectType read new ObjectType($8D41);
    public static property SAMPLER:             ObjectType read new ObjectType($82E6);
    public static property SHADER:              ObjectType read new ObjectType($82E1);
    public static property TEXTURE:             ObjectType read new ObjectType($1702);
    public static property TRANSFORM_FEEDBACK:  ObjectType read new ObjectType($8E22);
    public static property VERTEX_ARRAY:        ObjectType read new ObjectType($8074);
    
  end;
  
  //S
  PixelMagFilterMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NEAREST: PixelMagFilterMode read new PixelMagFilterMode($2600);
    public static property LINEAR:  PixelMagFilterMode read new PixelMagFilterMode($2601);
    
  end;
  
  //S
  PixelMinFilterMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NEAREST:                 PixelMinFilterMode read new PixelMinFilterMode($2600);
    public static property LINEAR:                  PixelMinFilterMode read new PixelMinFilterMode($2601);
    public static property NEAREST_MIPMAP_NEAREST:  PixelMinFilterMode read new PixelMinFilterMode($2700);
    public static property NEAREST_MIPMAP_LINEAR:   PixelMinFilterMode read new PixelMinFilterMode($2702);
    public static property LINEAR_MIPMAP_NEAREST:   PixelMinFilterMode read new PixelMinFilterMode($2701);
    public static property LINEAR_MIPMAP_LINEAR:    PixelMinFilterMode read new PixelMinFilterMode($2703);
    
  end;
  
  //S
  ColorClampTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property GL_CLAMP_READ_COLOR: ColorClampTarget read new ColorClampTarget($891C);
    
  end;
  
  //S
  FrameBufferPart = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE:            FrameBufferPart read new FrameBufferPart(0);
    public static property FRONT_LEFT:      FrameBufferPart read new FrameBufferPart($0400);
    public static property FRONT_RIGHT:     FrameBufferPart read new FrameBufferPart($0401);
    public static property BACK_LEFT:       FrameBufferPart read new FrameBufferPart($0402);
    public static property BACK_RIGHT:      FrameBufferPart read new FrameBufferPart($0403);
    public static property FRONT:           FrameBufferPart read new FrameBufferPart($0404);
    public static property BACK:            FrameBufferPart read new FrameBufferPart($0405);
    public static property LEFT:            FrameBufferPart read new FrameBufferPart($0406);
    public static property RIGHT:           FrameBufferPart read new FrameBufferPart($0407);
    public static property FRONT_AND_BACK:  FrameBufferPart read new FrameBufferPart($0408);
    
  end;
  
  //S
  LogicOpCode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property CLEAR:         LogicOpCode read new LogicOpCode($1500);
    public static property &AND:          LogicOpCode read new LogicOpCode($1501);
    public static property AND_REVERSE:   LogicOpCode read new LogicOpCode($1502);
    public static property COPY:          LogicOpCode read new LogicOpCode($1503);
    public static property AND_INVERTED:  LogicOpCode read new LogicOpCode($1504);
    public static property NOOP:          LogicOpCode read new LogicOpCode($1505);
    public static property &XOR:          LogicOpCode read new LogicOpCode($1506);
    public static property &OR:           LogicOpCode read new LogicOpCode($1507);
    public static property NOR:           LogicOpCode read new LogicOpCode($1508);
    public static property EQUIV:         LogicOpCode read new LogicOpCode($1509);
    public static property INVERT:        LogicOpCode read new LogicOpCode($150A);
    public static property OR_REVERSE:    LogicOpCode read new LogicOpCode($150B);
    public static property COPY_INVERTED: LogicOpCode read new LogicOpCode($150C);
    public static property OR_INVERTED:   LogicOpCode read new LogicOpCode($150D);
    public static property NAND:          LogicOpCode read new LogicOpCode($150E);
    public static property &SET:          LogicOpCode read new LogicOpCode($150F);
    
  end;
  
  //S
  BlendFuncMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ZERO:                      BlendFuncMode read new BlendFuncMode(0);
    public static property ONE:                       BlendFuncMode read new BlendFuncMode(1);
    public static property SRC_COLOR:                 BlendFuncMode read new BlendFuncMode($0300);
    public static property ONE_MINUS_SRC_COLOR:       BlendFuncMode read new BlendFuncMode($0301);
    public static property DST_COLOR:                 BlendFuncMode read new BlendFuncMode($0306);
    public static property ONE_MINUS_DST_COLOR:       BlendFuncMode read new BlendFuncMode($0307);
    public static property SRC_ALPHA:                 BlendFuncMode read new BlendFuncMode($0302);
    public static property ONE_MINUS_SRC_ALPHA:       BlendFuncMode read new BlendFuncMode($0303);
    public static property DST_ALPHA:                 BlendFuncMode read new BlendFuncMode($0304);
    public static property ONE_MINUS_DST_ALPHA:       BlendFuncMode read new BlendFuncMode($0305);
    public static property CONSTANT_COLOR:            BlendFuncMode read new BlendFuncMode($8001);
    public static property ONE_MINUS_CONSTANT_COLOR:  BlendFuncMode read new BlendFuncMode($8002);
    public static property CONSTANT_ALPHA:            BlendFuncMode read new BlendFuncMode($8003);
    public static property ONE_MINUS_CONSTANT_ALPHA:  BlendFuncMode read new BlendFuncMode($8004);
    public static property SRC_ALPHA_SATURATE:        BlendFuncMode read new BlendFuncMode($0308);
    public static property SRC1_COLOR:                BlendFuncMode read new BlendFuncMode($88F9);
    public static property ONE_MINUS_SRC1_COLOR:      BlendFuncMode read new BlendFuncMode($88FA);
    public static property SRC1_ALPHA:                BlendFuncMode read new BlendFuncMode($8589);
    public static property ONE_MINUS_SRC1_ALPHA:      BlendFuncMode read new BlendFuncMode($88FB);
    
  end;
  
  //S
  BlendEquationMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FUNC_ADD:              BlendEquationMode read new BlendEquationMode($8006);
    public static property FUNC_SUBTRACT:         BlendEquationMode read new BlendEquationMode($800A);
    public static property FUNC_REVERSE_SUBTRACT: BlendEquationMode read new BlendEquationMode($800B);
    public static property MIN:                   BlendEquationMode read new BlendEquationMode($8007);
    public static property MAX:                   BlendEquationMode read new BlendEquationMode($8008);
    
  end;
  
  //S
  StencilOpFailMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property KEEP:      StencilOpFailMode read new StencilOpFailMode($1E00);
    public static property ZERO:      StencilOpFailMode read new StencilOpFailMode(0);
    public static property REPLACE:   StencilOpFailMode read new StencilOpFailMode($1E01);
    public static property INCR:      StencilOpFailMode read new StencilOpFailMode($1E02);
    public static property INCR_WRAP: StencilOpFailMode read new StencilOpFailMode($8507);
    public static property DECR:      StencilOpFailMode read new StencilOpFailMode($1E03);
    public static property DECR_WRAP: StencilOpFailMode read new StencilOpFailMode($8508);
    public static property INVERT:    StencilOpFailMode read new StencilOpFailMode($150A);
    
  end;
  
  //S
  ActivationFunc = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NEVER:     ActivationFunc read new ActivationFunc($0200);
    public static property LESS:      ActivationFunc read new ActivationFunc($0201);
    public static property LEQUAL:    ActivationFunc read new ActivationFunc($0203);
    public static property GREATER:   ActivationFunc read new ActivationFunc($0204);
    public static property GEQUAL:    ActivationFunc read new ActivationFunc($0206);
    public static property EQUAL:     ActivationFunc read new ActivationFunc($0202);
    public static property NOTEQUAL:  ActivationFunc read new ActivationFunc($0205);
    public static property ALWAYS:    ActivationFunc read new ActivationFunc($0207);
    
  end;
  
  //S
  PolygonRasterizationMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property POINT: PolygonRasterizationMode read new PolygonRasterizationMode($1B00);
    public static property LINE:  PolygonRasterizationMode read new PolygonRasterizationMode($1B01);
    public static property FILL:  PolygonRasterizationMode read new PolygonRasterizationMode($1B02);
    
  end;
  
  //S
  PolygonFace = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FRONT:           PolygonFace read new PolygonFace($0404);
    public static property BACK:            PolygonFace read new PolygonFace($0405);
    public static property FRONT_AND_BACK:  PolygonFace read new PolygonFace($0408);
    
  end;
  
  //S
  FrontFaceDirection = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property СW:  FrontFaceDirection read new FrontFaceDirection($0900);
    public static property СCW: FrontFaceDirection read new FrontFaceDirection($0901);
    
  end;
  
  //S
  PointInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FADE_THRESHOLD_SIZE: PointInfoType read new PointInfoType($8128);
    public static property SPRITE_COORD_ORIGIN: PointInfoType read new PointInfoType($8CA0);
    
  end;
  
  //S
  MultisampleInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property GL_SAMPLE_POSITION:  MultisampleInfoType read new MultisampleInfoType($8E50);
    
  end;
  
  //S
  ClipDepthMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NEGATIVE_ONE_TO_ONE: ClipDepthMode read new ClipDepthMode($935E);
    public static property ZERO_TO_ONE:         ClipDepthMode read new ClipDepthMode($935F);
    
  end;
  
  //S
  ClipOriginMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property LOWER_LEFT:  ClipOriginMode read new ClipOriginMode($8CA1);
    public static property UPPER_LEFT:  ClipOriginMode read new ClipOriginMode($8CA2);
    
  end;
  
  //S
  TransformFeedbackBindTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property GL_TRANSFORM_FEEDBACK: TransformFeedbackBindTarget read new TransformFeedbackBindTarget($8E22);
    
  end;
  
  //S
  TransformFeedbackBufferMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property INTERLEAVED_ATTRIBS: TransformFeedbackBufferMode read new TransformFeedbackBufferMode($8C8C);
    public static property SEPARATE_ATTRIBS:    TransformFeedbackBufferMode read new TransformFeedbackBufferMode($8C8D);
    
  end;
  
  //S
  ConditionalRenderingMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property WAIT:                        ConditionalRenderingMode read new ConditionalRenderingMode($8E13);
    public static property NO_WAIT:                     ConditionalRenderingMode read new ConditionalRenderingMode($8E14);
    public static property BY_REGION_WAIT:              ConditionalRenderingMode read new ConditionalRenderingMode($8E15);
    public static property BY_REGION_NO_WAIT:           ConditionalRenderingMode read new ConditionalRenderingMode($8E16);
    public static property WAIT_INVERTED:               ConditionalRenderingMode read new ConditionalRenderingMode($8E17);
    public static property NO_WAIT_INVERTED:            ConditionalRenderingMode read new ConditionalRenderingMode($8E18);
    public static property BY_REGION_WAIT_INVERTED:     ConditionalRenderingMode read new ConditionalRenderingMode($8E19);
    public static property BY_REGION_NO_WAIT_INVERTED:  ConditionalRenderingMode read new ConditionalRenderingMode($8E1A);
    
  end;
  
  //S
  VertexAttribInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ELEMENT_ARRAY_BUFFER_BINDING:        VertexAttribInfoType read new VertexAttribInfoType($8895);
    public static property VERTEX_ATTRIB_ARRAY_ENABLED:         VertexAttribInfoType read new VertexAttribInfoType($8622);
    public static property VERTEX_ATTRIB_ARRAY_SIZE:            VertexAttribInfoType read new VertexAttribInfoType($8623);
    public static property VERTEX_ATTRIB_ARRAY_STRIDE:          VertexAttribInfoType read new VertexAttribInfoType($8624);
    public static property VERTEX_ATTRIB_ARRAY_TYPE:            VertexAttribInfoType read new VertexAttribInfoType($8625);
    public static property VERTEX_ATTRIB_ARRAY_NORMALIZED:      VertexAttribInfoType read new VertexAttribInfoType($886A);
    public static property VERTEX_ATTRIB_ARRAY_INTEGER:         VertexAttribInfoType read new VertexAttribInfoType($88FD);
    public static property VERTEX_ATTRIB_ARRAY_LONG:            VertexAttribInfoType read new VertexAttribInfoType($874E);
    public static property VERTEX_ATTRIB_ARRAY_DIVISOR:         VertexAttribInfoType read new VertexAttribInfoType($88FE);
    public static property VERTEX_ATTRIB_RELATIVE_OFFSET:       VertexAttribInfoType read new VertexAttribInfoType($82D5);
    public static property VERTEX_BINDING_OFFSET:               VertexAttribInfoType read new VertexAttribInfoType($82D7);
    public static property VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:  VertexAttribInfoType read new VertexAttribInfoType($889F);
    public static property VERTEX_ATTRIB_BINDING:               VertexAttribInfoType read new VertexAttribInfoType($82D4);
    public static property CURRENT_VERTEX_ATTRIB:               VertexAttribInfoType read new VertexAttribInfoType($8626);
    
  end;
  
  //S
  PatchMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property VERTICES:            PatchMode read new PatchMode($8E72);
    public static property DEFAULT_INNER_LEVEL: PatchMode read new PatchMode($8E73);
    public static property DEFAULT_OUTER_LEVEL: PatchMode read new PatchMode($8E74);
    
  end;
  
  //S
  PrimitiveType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property POINTS:                    PrimitiveType read new PrimitiveType($0000);
    
    public static property LINES:                     PrimitiveType read new PrimitiveType($0001);
    public static property LINE_LOOP:                 PrimitiveType read new PrimitiveType($0002);
    public static property LINE_STRIP:                PrimitiveType read new PrimitiveType($0003);
    public static property LINES_ADJACENCY:           PrimitiveType read new PrimitiveType($000A);
    public static property LINE_STRIP_ADJACENCY:      PrimitiveType read new PrimitiveType($000B);
    
    public static property TRIANGLES:                 PrimitiveType read new PrimitiveType($0004);
    public static property TRIANGLE_STRIP:            PrimitiveType read new PrimitiveType($0005);
    public static property TRIANGLE_FAN:              PrimitiveType read new PrimitiveType($0006);
    public static property TRIANGLES_ADJACENCY:       PrimitiveType read new PrimitiveType($000C);
    public static property TRIANGLE_STRIP_ADJACENCY:  PrimitiveType read new PrimitiveType($000D);
    
    public static property PATCHES:                   PrimitiveType read new PrimitiveType($000E);
    
  end;
  
  //S
  FramebufferAttachmentInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property OBJECT_TYPE:           FramebufferAttachmentInfoType read new FramebufferAttachmentInfoType($8CD0); // FramebufferAttachmentObjectType
    
    // non- NONE
    public static property OBJECT_NAME:           FramebufferAttachmentInfoType read new FramebufferAttachmentInfoType($8CD1); // UInt32
    public static property RED_SIZE:              FramebufferAttachmentInfoType read new FramebufferAttachmentInfoType($8212); // Int32
    public static property GREEN_SIZE:            FramebufferAttachmentInfoType read new FramebufferAttachmentInfoType($8213); // Int32
    public static property BLUE_SIZE:             FramebufferAttachmentInfoType read new FramebufferAttachmentInfoType($8214); // Int32
    public static property ALPHA_SIZE:            FramebufferAttachmentInfoType read new FramebufferAttachmentInfoType($8215); // Int32
    public static property DEPTH_SIZE:            FramebufferAttachmentInfoType read new FramebufferAttachmentInfoType($8216); // Int32
    public static property STENCIL_SIZE:          FramebufferAttachmentInfoType read new FramebufferAttachmentInfoType($8217); // Int32
    public static property COMPONENT_TYPE:        FramebufferAttachmentInfoType read new FramebufferAttachmentInfoType($8211); // Int32
    public static property COLOR_ENCODING:        FramebufferAttachmentInfoType read new FramebufferAttachmentInfoType($8210); // Int32
    
    // TEXTURE
    public static property TEXTURE_LEVEL:         FramebufferAttachmentInfoType read new FramebufferAttachmentInfoType($8CD2); // Int32
    public static property TEXTURE_CUBE_MAP_FACE: FramebufferAttachmentInfoType read new FramebufferAttachmentInfoType($8CD3); // Int32
    public static property LAYERED:               FramebufferAttachmentInfoType read new FramebufferAttachmentInfoType($8DA7); // 32-битное boolean (Int32, 0=False, остальное=True)
    public static property TEXTURE_LAYER:         FramebufferAttachmentInfoType read new FramebufferAttachmentInfoType($8CD4); // Int32
    
  end;
  
  //S
  FramebufferInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property WIDTH:                   FramebufferInfoType read new FramebufferInfoType($9310);
    public static property HEIGHT:                  FramebufferInfoType read new FramebufferInfoType($9311);
    public static property LAYERS:                  FramebufferInfoType read new FramebufferInfoType($9312);
    public static property SAMPLES:                 FramebufferInfoType read new FramebufferInfoType($9313);
    public static property FIXED_SAMPLE_LOCATIONS:  FramebufferInfoType read new FramebufferInfoType($9314);
    
  end;
  
  //S
  FramebufferBindTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property READ_FRAMEBUFFER:  FramebufferBindTarget read new FramebufferBindTarget($8CA8);
    public static property DRAW_FRAMEBUFFER:  FramebufferBindTarget read new FramebufferBindTarget($8CA9);
    public static property FRAMEBUFFER:       FramebufferBindTarget read new FramebufferBindTarget($8D40);
    
  end;
  
  //S
  TextureCubeSide = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property POSITIVE_X:  TextureCubeSide read new TextureCubeSide($8515);
    public static property NEGATIVE_X:  TextureCubeSide read new TextureCubeSide($8516);
    public static property POSITIVE_Y:  TextureCubeSide read new TextureCubeSide($8517);
    public static property NEGATIVE_Y:  TextureCubeSide read new TextureCubeSide($8518);
    public static property POSITIVE_Z:  TextureCubeSide read new TextureCubeSide($8519);
    public static property NEGATIVE_Z:  TextureCubeSide read new TextureCubeSide($851A);
    
  end;
  
  //S
  RenderbufferBindTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property RENDERBUFFER: RenderbufferBindTarget read new RenderbufferBindTarget($8D41);
    
  end;
  
  //S
  AccessType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property READ_ONLY:   AccessType read new AccessType($88B8);
    public static property WRITE_ONLY:  AccessType read new AccessType($88B9);
    public static property READ_WRITE:  AccessType read new AccessType($88BA);
    
  end;
  
  //S
  TextureInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property DEPTH_STENCIL_TEXTURE_MODE:  TextureInfoType read new TextureInfoType($90EA);
    public static property BASE_LEVEL:                  TextureInfoType read new TextureInfoType($813C);
    public static property BORDER_COLOR:                TextureInfoType read new TextureInfoType($1004);
    public static property COMPARE_MODE:                TextureInfoType read new TextureInfoType($884C);
    public static property COMPARE_FUNC:                TextureInfoType read new TextureInfoType($884D);
    public static property LOD_BIAS:                    TextureInfoType read new TextureInfoType($8501);
    public static property MAG_FILTER:                  TextureInfoType read new TextureInfoType($2800);
    public static property MAX_ANISOTROPY:              TextureInfoType read new TextureInfoType($84FE);
    public static property MAX_LEVEL:                   TextureInfoType read new TextureInfoType($813D);
    public static property MAX_LOD:                     TextureInfoType read new TextureInfoType($813B);
    public static property MIN_FILTER:                  TextureInfoType read new TextureInfoType($2801);
    public static property MIN_LOD:                     TextureInfoType read new TextureInfoType($813A);
    public static property SWIZZLE_R:                   TextureInfoType read new TextureInfoType($8E42);
    public static property SWIZZLE_G:                   TextureInfoType read new TextureInfoType($8E43);
    public static property SWIZZLE_B:                   TextureInfoType read new TextureInfoType($8E44);
    public static property SWIZZLE_A:                   TextureInfoType read new TextureInfoType($8E45);
    public static property SWIZZLE_RGBA:                TextureInfoType read new TextureInfoType($8E46);
    public static property WRAP_S:                      TextureInfoType read new TextureInfoType($2802);
    public static property WRAP_T:                      TextureInfoType read new TextureInfoType($2803);
    public static property WRAP_R:                      TextureInfoType read new TextureInfoType($8072);
    
  end;
  
  //S
  PixelInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property UNPACK_SWAP_BYTES:               PixelInfoType read new PixelInfoType($0CF0);
    public static property UNPACK_LSB_FIRST:                PixelInfoType read new PixelInfoType($0CF1);
    public static property UNPACK_ROW_LENGTH:               PixelInfoType read new PixelInfoType($0CF2);
    public static property UNPACK_SKIP_ROWS:                PixelInfoType read new PixelInfoType($0CF3);
    public static property UNPACK_SKIP_PIXELS:              PixelInfoType read new PixelInfoType($0CF4);
    public static property UNPACK_ALIGNMENT:                PixelInfoType read new PixelInfoType($0CF5);
    public static property UNPACK_IMAGE_HEIGHT:             PixelInfoType read new PixelInfoType($806E);
    public static property UNPACK_SKIP_IMAGES:              PixelInfoType read new PixelInfoType($806D);
    public static property UNPACK_COMPRESSED_BLOCK_WIDTH:   PixelInfoType read new PixelInfoType($9127);
    public static property UNPACK_COMPRESSED_BLOCK_HEIGHT:  PixelInfoType read new PixelInfoType($9128);
    public static property UNPACK_COMPRESSED_BLOCK_DEPTH:   PixelInfoType read new PixelInfoType($9129);
    public static property UNPACK_COMPRESSED_BLOCK_SIZE:    PixelInfoType read new PixelInfoType($912A);
    public static property PACK_SWAP_BYTES:                 PixelInfoType read new PixelInfoType($0D00);
    public static property PACK_LSB_FIRST:                  PixelInfoType read new PixelInfoType($0D01);
    public static property PACK_ROW_LENGTH:                 PixelInfoType read new PixelInfoType($0D02);
    public static property PACK_SKIP_ROWS:                  PixelInfoType read new PixelInfoType($0D03);
    public static property PACK_SKIP_PIXELS:                PixelInfoType read new PixelInfoType($0D04);
    public static property PACK_ALIGNMENT:                  PixelInfoType read new PixelInfoType($0D05);
    public static property PACK_IMAGE_HEIGHT:               PixelInfoType read new PixelInfoType($806C);
    public static property PACK_SKIP_IMAGES:                PixelInfoType read new PixelInfoType($806B);
    public static property PACK_COMPRESSED_BLOCK_WIDTH:     PixelInfoType read new PixelInfoType($912B);
    public static property PACK_COMPRESSED_BLOCK_HEIGHT:    PixelInfoType read new PixelInfoType($912C);
    public static property PACK_COMPRESSED_BLOCK_DEPTH:     PixelInfoType read new PixelInfoType($912D);
    public static property PACK_COMPRESSED_BLOCK_SIZE:      PixelInfoType read new PixelInfoType($912E);
    
  end;
  
  //S
  TextureUnitId = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property Texture[i: integer]: TextureUnitId read new TextureUnitId($84C0+i);
    
  end;
  
  //S
  FramebufferAttachmentPoint = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    // custom framebuffer
    public static property COLOR_ATTACHMENT[i: integer]:  FramebufferAttachmentPoint read new FramebufferAttachmentPoint($8CE0+i);
    public static property DEPTH_ATTACHMENT:              FramebufferAttachmentPoint read new FramebufferAttachmentPoint($8D00);
    public static property STENCIL_ATTACHMENT:            FramebufferAttachmentPoint read new FramebufferAttachmentPoint($8D20);
    public static property DEPTH_STENCIL_ATTACHMENT:      FramebufferAttachmentPoint read new FramebufferAttachmentPoint($821A);
    
    // default framebuffer
    public static property FRONT:                         FramebufferAttachmentPoint read new FramebufferAttachmentPoint($0404);
    public static property FRONT_LEFT:                    FramebufferAttachmentPoint read new FramebufferAttachmentPoint($0400);
    public static property FRONT_RIGHT:                   FramebufferAttachmentPoint read new FramebufferAttachmentPoint($0401);
    public static property BACK:                          FramebufferAttachmentPoint read new FramebufferAttachmentPoint($0405);
    public static property BACK_LEFT:                     FramebufferAttachmentPoint read new FramebufferAttachmentPoint($0402);
    public static property BACK_RIGHT:                    FramebufferAttachmentPoint read new FramebufferAttachmentPoint($0403);
    public static property DEPTH:                         FramebufferAttachmentPoint read new FramebufferAttachmentPoint($1801);
    public static property STENCIL:                       FramebufferAttachmentPoint read new FramebufferAttachmentPoint($1802);
    
  end;
  
  //S
  TextureBindTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property T_1D:                          TextureBindTarget read new TextureBindTarget($0DE0);
    public static property T_2D:                          TextureBindTarget read new TextureBindTarget($0DE1);
    public static property T_3D:                          TextureBindTarget read new TextureBindTarget($806F);
    public static property T_1D_ARRAY:                    TextureBindTarget read new TextureBindTarget($8C18);
    public static property T_2D_ARRAY:                    TextureBindTarget read new TextureBindTarget($8C1A);
    public static property T_RECTANGLE:                   TextureBindTarget read new TextureBindTarget($84F5);
    public static property T_BUFFER:                      TextureBindTarget read new TextureBindTarget($8C2A);
    public static property T_CUBE_MAP:                    TextureBindTarget read new TextureBindTarget($8513);
    public static property T_CUBE_MAP_ARRAY:              TextureBindTarget read new TextureBindTarget($9009);
    public static property T_2D_MULTISAMPLE:              TextureBindTarget read new TextureBindTarget($9100);
    public static property PROXY_T_2D_MULTISAMPLE:        TextureBindTarget read new TextureBindTarget($9101);
    public static property T_2D_MULTISAMPLE_ARRAY:        TextureBindTarget read new TextureBindTarget($9102);
    public static property PROXY_T_2D_MULTISAMPLE_ARRAY:  TextureBindTarget read new TextureBindTarget($9103);
    
  end;
  
  //S
  ShaderPrecisionFormatType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property LOW_FLOAT:     ShaderPrecisionFormatType read new ShaderPrecisionFormatType($8DF0);
    public static property MEDIUM_FLOAT:  ShaderPrecisionFormatType read new ShaderPrecisionFormatType($8DF1);
    public static property HIGH_FLOAT:    ShaderPrecisionFormatType read new ShaderPrecisionFormatType($8DF2);
    public static property LOW_INT:       ShaderPrecisionFormatType read new ShaderPrecisionFormatType($8DF3);
    public static property MEDIUM_INT:    ShaderPrecisionFormatType read new ShaderPrecisionFormatType($8DF4);
    public static property HIGH_INT:      ShaderPrecisionFormatType read new ShaderPrecisionFormatType($8DF5);
    
  end;
  
  //S
  ProgramInterfaceProperty = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ACTIVE_VARIABLES:                      ProgramInterfaceProperty read new ProgramInterfaceProperty($9305);
    public static property BUFFER_BINDING:                        ProgramInterfaceProperty read new ProgramInterfaceProperty($9302);
    public static property NUM_ACTIVE_VARIABLES:                  ProgramInterfaceProperty read new ProgramInterfaceProperty($9304);
    public static property ARRAY_SIZE:                            ProgramInterfaceProperty read new ProgramInterfaceProperty($92FB);
    public static property ARRAY_STRIDE:                          ProgramInterfaceProperty read new ProgramInterfaceProperty($92FE);
    public static property BLOCK_INDEX:                           ProgramInterfaceProperty read new ProgramInterfaceProperty($92FD);
    public static property IS_ROW_MAJOR:                          ProgramInterfaceProperty read new ProgramInterfaceProperty($9300);
    public static property MATRIX_STRIDE:                         ProgramInterfaceProperty read new ProgramInterfaceProperty($92FF);
    public static property ATOMIC_COUNTER_BUFFER_INDEX:           ProgramInterfaceProperty read new ProgramInterfaceProperty($9301);
    public static property BUFFER_DATA_SIZE:                      ProgramInterfaceProperty read new ProgramInterfaceProperty($9303);
    public static property NUM_COMPATIBLE_SUBROUTINES:            ProgramInterfaceProperty read new ProgramInterfaceProperty($8E4A);
    public static property COMPATIBLE_SUBROUTINES:                ProgramInterfaceProperty read new ProgramInterfaceProperty($8E4B);
    public static property IS_PER_PATCH:                          ProgramInterfaceProperty read new ProgramInterfaceProperty($92E7);
    public static property LOCATION:                              ProgramInterfaceProperty read new ProgramInterfaceProperty($930E);
    public static property LOCATION_COMPONENT:                    ProgramInterfaceProperty read new ProgramInterfaceProperty($934A);
    public static property LOCATION_INDEX:                        ProgramInterfaceProperty read new ProgramInterfaceProperty($930F);
    public static property NAME_LENGTH:                           ProgramInterfaceProperty read new ProgramInterfaceProperty($92F9);
    public static property OFFSET:                                ProgramInterfaceProperty read new ProgramInterfaceProperty($92FC);
    public static property REFERENCED_BY_VERTEX_SHADER:           ProgramInterfaceProperty read new ProgramInterfaceProperty($9306);
    public static property REFERENCED_BY_TESS_CONTROL_SHADER:     ProgramInterfaceProperty read new ProgramInterfaceProperty($9307);
    public static property REFERENCED_BY_TESS_EVALUATION_SHADER:  ProgramInterfaceProperty read new ProgramInterfaceProperty($9308);
    public static property REFERENCED_BY_GEOMETRY_SHADER:         ProgramInterfaceProperty read new ProgramInterfaceProperty($9309);
    public static property REFERENCED_BY_FRAGMENT_SHADER:         ProgramInterfaceProperty read new ProgramInterfaceProperty($930A);
    public static property REFERENCED_BY_COMPUTE_SHADER:          ProgramInterfaceProperty read new ProgramInterfaceProperty($930B);
    public static property TRANSFORM_FEEDBACK_BUFFER_INDEX:       ProgramInterfaceProperty read new ProgramInterfaceProperty($934B);
    public static property TRANSFORM_FEEDBACK_BUFFER_STRIDE:      ProgramInterfaceProperty read new ProgramInterfaceProperty($934C);
    public static property TOP_LEVEL_ARRAY_SIZE:                  ProgramInterfaceProperty read new ProgramInterfaceProperty($930C);
    public static property TOP_LEVEL_ARRAY_STRIDE:                ProgramInterfaceProperty read new ProgramInterfaceProperty($930D);
    public static property &TYPE:                                 ProgramInterfaceProperty read new ProgramInterfaceProperty($92FA);
    
//    public static property TEXTURE_BUFFER:                         read new ProgramInterfaceProperty($8C2A); // типа существует, но это не точно
    
  end;
  
  //S
  ProgramInterfaceInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ACTIVE_RESOURCES:                ProgramInterfaceInfoType read new ProgramInterfaceInfoType($92F5);
    public static property MAX_NAME_LENGTH:                 ProgramInterfaceInfoType read new ProgramInterfaceInfoType($92F6);
    public static property MAX_NUM_ACTIVE_VARIABLES:        ProgramInterfaceInfoType read new ProgramInterfaceInfoType($92F7);
    public static property MAX_NUM_COMPATIBLE_SUBROUTINES:  ProgramInterfaceInfoType read new ProgramInterfaceInfoType($92F8);
    
  end;
  
  //S
  ProgramInterfaceType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property UNIFORM:                             ProgramInterfaceType read new ProgramInterfaceType($92E1);
    public static property UNIFORM_BLOCK:                       ProgramInterfaceType read new ProgramInterfaceType($92E2);
    public static property ATOMIC_COUNTER_BUFFER:               ProgramInterfaceType read new ProgramInterfaceType($92C0);
    public static property PROGRAM_INPUT:                       ProgramInterfaceType read new ProgramInterfaceType($92E3);
    public static property PROGRAM_OUTPUT:                      ProgramInterfaceType read new ProgramInterfaceType($92E4);
    public static property VERTEX_SUBROUTINE:                   ProgramInterfaceType read new ProgramInterfaceType($92E8);
    public static property TESS_CONTROL_SUBROUTINE:             ProgramInterfaceType read new ProgramInterfaceType($92E9);
    public static property TESS_EVALUATION_SUBROUTINE:          ProgramInterfaceType read new ProgramInterfaceType($92EA);
    public static property GEOMETRY_SUBROUTINE:                 ProgramInterfaceType read new ProgramInterfaceType($92EB);
    public static property FRAGMENT_SUBROUTINE:                 ProgramInterfaceType read new ProgramInterfaceType($92EC);
    public static property COMPUTE_SUBROUTINE:                  ProgramInterfaceType read new ProgramInterfaceType($92ED);
    public static property VERTEX_SUBROUTINE_UNIFORM:           ProgramInterfaceType read new ProgramInterfaceType($92EE);
    public static property TESS_CONTROL_SUBROUTINE_UNIFORM:     ProgramInterfaceType read new ProgramInterfaceType($92EF);
    public static property TESS_EVALUATION_SUBROUTINE_UNIFORM:  ProgramInterfaceType read new ProgramInterfaceType($92F0);
    public static property GEOMETRY_SUBROUTINE_UNIFORM:         ProgramInterfaceType read new ProgramInterfaceType($92F1);
    public static property FRAGMENT_SUBROUTINE_UNIFORM:         ProgramInterfaceType read new ProgramInterfaceType($92F2);
    public static property COMPUTE_SUBROUTINE_UNIFORM:          ProgramInterfaceType read new ProgramInterfaceType($92F3);
    public static property TRANSFORM_FEEDBACK_VARYING:          ProgramInterfaceType read new ProgramInterfaceType($92F4);
    public static property BUFFER_VARIABLE:                     ProgramInterfaceType read new ProgramInterfaceType($92E5);
    public static property SHADER_STORAGE_BLOCK:                ProgramInterfaceType read new ProgramInterfaceType($92E6);
    public static property TRANSFORM_FEEDBACK_BUFFER:           ProgramInterfaceType read new ProgramInterfaceType($8C8E);
    
  end;
  
  //S
  ProgramParameterType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SEPARABLE:               ProgramParameterType read new ProgramParameterType($8258);
    public static property BINARY_RETRIEVABLE_HINT: ProgramParameterType read new ProgramParameterType($8257);
    
  end;
  
  //S
  ShaderType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property VERTEX_SHADER:           ShaderType read new ShaderType($8B31);
    public static property TESS_CONTROL_SHADER:     ShaderType read new ShaderType($8E88);
    public static property TESS_EVALUATION_SHADER:  ShaderType read new ShaderType($8E87);
    public static property GEOMETRY_SHADER:         ShaderType read new ShaderType($8DD9);
    public static property FRAGMENT_SHADER:         ShaderType read new ShaderType($8B30);
    public static property COMPUTE_SHADER:          ShaderType read new ShaderType($91B9);
    
  end;
  
  //S
  SyncObjectType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property GL_SYNC_FENCE: SyncObjectType read new SyncObjectType($9116);
    
  end;
  
  //S
  FenceStatus = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property UNSIGNALED:  FenceStatus read new FenceStatus($9118);
    public static property SIGNALED:    FenceStatus read new FenceStatus($9119);
    
  end;
  
  //S
  FenceCondition = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property GL_SYNC_GPU_COMMANDS_COMPLETE: FenceCondition read new FenceCondition($9117);
    
  end;
  
  //S
  BufferBindType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ARRAY_BUFFER:              BufferBindType read new BufferBindType($8892);
    public static property ATOMIC_COUNTER_BUFFER:     BufferBindType read new BufferBindType($92C0);
    public static property COPY_READ_BUFFER:          BufferBindType read new BufferBindType($8F36);
    public static property COPY_WRITE_BUFFER:         BufferBindType read new BufferBindType($8F37);
    public static property DISPATCH_INDIRECT_BUFFER:  BufferBindType read new BufferBindType($90EE);
    public static property DRAW_INDIRECT_BUFFER:      BufferBindType read new BufferBindType($8F3F);
    public static property ELEMENT_ARRAY_BUFFER:      BufferBindType read new BufferBindType($8893);
    public static property PIXEL_PACK_BUFFER:         BufferBindType read new BufferBindType($88EB);
    public static property PIXEL_UNPACK_BUFFER:       BufferBindType read new BufferBindType($88EC);
    public static property QUERY_BUFFER:              BufferBindType read new BufferBindType($9192);
    public static property SHADER_STORAGE_BUFFER:     BufferBindType read new BufferBindType($90D2);
    public static property TEXTURE_BUFFER:            BufferBindType read new BufferBindType($8C2A);
    public static property TRANSFORM_FEEDBACK_BUFFER: BufferBindType read new BufferBindType($8C8E);
    public static property UNIFORM_BUFFER:            BufferBindType read new BufferBindType($8A11);
    
  end;
  
  //S
  CopyableImageType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ARRAY_BUFFER:              CopyableImageType read new CopyableImageType($8892);
    public static property ATOMIC_COUNTER_BUFFER:     CopyableImageType read new CopyableImageType($92C0);
    public static property COPY_READ_BUFFER:          CopyableImageType read new CopyableImageType($8F36);
    public static property COPY_WRITE_BUFFER:         CopyableImageType read new CopyableImageType($8F37);
    public static property DISPATCH_INDIRECT_BUFFER:  CopyableImageType read new CopyableImageType($90EE);
    public static property DRAW_INDIRECT_BUFFER:      CopyableImageType read new CopyableImageType($8F3F);
    public static property ELEMENT_ARRAY_BUFFER:      CopyableImageType read new CopyableImageType($8893);
    public static property PIXEL_PACK_BUFFER:         CopyableImageType read new CopyableImageType($88EB);
    public static property PIXEL_UNPACK_BUFFER:       CopyableImageType read new CopyableImageType($88EC);
    public static property QUERY_BUFFER:              CopyableImageType read new CopyableImageType($9192);
    public static property SHADER_STORAGE_BUFFER:     CopyableImageType read new CopyableImageType($90D2);
    public static property TEXTURE_BUFFER:            CopyableImageType read new CopyableImageType($8C2A);
    public static property TRANSFORM_FEEDBACK_BUFFER: CopyableImageType read new CopyableImageType($8C8E);
    public static property UNIFORM_BUFFER:            CopyableImageType read new CopyableImageType($8A11);
    
    public static property GL_RENDERBUFFER:           CopyableImageType read new CopyableImageType($8D41);
    
  end;
  
  //S
  BufferDataUsage = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property STREAM_DRAW:   BufferDataUsage read new BufferDataUsage($88E0);
    public static property STREAM_READ:   BufferDataUsage read new BufferDataUsage($88E1);
    public static property STREAM_COPY:   BufferDataUsage read new BufferDataUsage($88E2);
    public static property STATIC_DRAW:   BufferDataUsage read new BufferDataUsage($88E4);
    public static property STATIC_READ:   BufferDataUsage read new BufferDataUsage($88E5);
    public static property STATIC_COPY:   BufferDataUsage read new BufferDataUsage($88E6);
    public static property DYNAMIC_DRAW:  BufferDataUsage read new BufferDataUsage($88E8);
    public static property DYNAMIC_READ:  BufferDataUsage read new BufferDataUsage($88E9);
    public static property DYNAMIC_COPY:  BufferDataUsage read new BufferDataUsage($88EA);
    
  end;
  
  //S
  InternalDataFormat = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property R8:        InternalDataFormat read new InternalDataFormat($8229);
    public static property R8I:       InternalDataFormat read new InternalDataFormat($8231);
    public static property R8UI:      InternalDataFormat read new InternalDataFormat($8232);
    public static property R16:       InternalDataFormat read new InternalDataFormat($822A);
    public static property R16I:      InternalDataFormat read new InternalDataFormat($8233);
    public static property R16UI:     InternalDataFormat read new InternalDataFormat($8234);
    public static property R16F:      InternalDataFormat read new InternalDataFormat($822D);
    public static property R32I:      InternalDataFormat read new InternalDataFormat($8235);
    public static property R32UI:     InternalDataFormat read new InternalDataFormat($8236);
    public static property R32F:      InternalDataFormat read new InternalDataFormat($822E);
    
    public static property RG8:       InternalDataFormat read new InternalDataFormat($822B);
    public static property RG8I:      InternalDataFormat read new InternalDataFormat($8237);
    public static property RG8UI:     InternalDataFormat read new InternalDataFormat($8238);
    public static property RG16:      InternalDataFormat read new InternalDataFormat($822C);
    public static property RG16I:     InternalDataFormat read new InternalDataFormat($8239);
    public static property RG16UI:    InternalDataFormat read new InternalDataFormat($823A);
    public static property RG16F:     InternalDataFormat read new InternalDataFormat($822F);
    public static property RG32I:     InternalDataFormat read new InternalDataFormat($823B);
    public static property RG32UI:    InternalDataFormat read new InternalDataFormat($823C);
    public static property RG32F:     InternalDataFormat read new InternalDataFormat($8230);
    
    public static property RGB8:      InternalDataFormat read new InternalDataFormat($8051);
    public static property RGB8I:     InternalDataFormat read new InternalDataFormat($8D8F);
    public static property RGB8UI:    InternalDataFormat read new InternalDataFormat($8D7D);
    public static property RGB16:     InternalDataFormat read new InternalDataFormat($8054);
    public static property RGB16I:    InternalDataFormat read new InternalDataFormat($8D89);
    public static property RGB16UI:   InternalDataFormat read new InternalDataFormat($8D77);
    public static property RGB16F:    InternalDataFormat read new InternalDataFormat($881B);
    public static property RGB32I:    InternalDataFormat read new InternalDataFormat($8D83);
    public static property RGB32UI:   InternalDataFormat read new InternalDataFormat($8D71);
    public static property RGB32F:    InternalDataFormat read new InternalDataFormat($8815);
    
    public static property RGBA8:     InternalDataFormat read new InternalDataFormat($8058);
    public static property RGBA16:    InternalDataFormat read new InternalDataFormat($805B);
    public static property RGBA16F:   InternalDataFormat read new InternalDataFormat($881A);
    public static property RGBA32F:   InternalDataFormat read new InternalDataFormat($8814);
    public static property RGBA8I:    InternalDataFormat read new InternalDataFormat($8D8E);
    public static property RGBA16I:   InternalDataFormat read new InternalDataFormat($8D88);
    public static property RGBA32I:   InternalDataFormat read new InternalDataFormat($8D82);
    public static property RGBA8UI:   InternalDataFormat read new InternalDataFormat($8D7C);
    public static property RGBA16UI:  InternalDataFormat read new InternalDataFormat($8D76);
    public static property RGBA32UI:  InternalDataFormat read new InternalDataFormat($8D70);
    
    public static property RGB4:      InternalDataFormat read new InternalDataFormat($804F);
    public static property RGB5:      InternalDataFormat read new InternalDataFormat($8050);
    public static property RGB10:     InternalDataFormat read new InternalDataFormat($8052);
    public static property RGB12:     InternalDataFormat read new InternalDataFormat($8053);
    public static property RGB5_A1:   InternalDataFormat read new InternalDataFormat($8057);
    public static property RGB10_A2:  InternalDataFormat read new InternalDataFormat($8059);
    
    public static property RGBA2:     InternalDataFormat read new InternalDataFormat($8055);
    public static property RGBA4:     InternalDataFormat read new InternalDataFormat($8056);
    public static property RGBA12:    InternalDataFormat read new InternalDataFormat($805A);
    
  end;
  
  //S
  DataFormat = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property RED:             DataFormat read new DataFormat($1903);
    public static property GREEN:           DataFormat read new DataFormat($1904);
    public static property BLUE:            DataFormat read new DataFormat($1905);
    public static property RG:              DataFormat read new DataFormat($8227);
    public static property RGB:             DataFormat read new DataFormat($1907);
    public static property BGR:             DataFormat read new DataFormat($80E0);
    public static property RGBA:            DataFormat read new DataFormat($1908);
    public static property BGRA:            DataFormat read new DataFormat($80E1);
    public static property RED_INTEGER:     DataFormat read new DataFormat($8D94);
    public static property GREEN_INTEGER:   DataFormat read new DataFormat($8D95);
    public static property BLUE_INTEGER:    DataFormat read new DataFormat($8D96);
    public static property RGB_INTEGER:     DataFormat read new DataFormat($8D98);
    public static property RGBA_INTEGER:    DataFormat read new DataFormat($8D99);
    public static property BGR_INTEGER:     DataFormat read new DataFormat($8D9A);
    public static property BGRA_INTEGER:    DataFormat read new DataFormat($8D9B);
    public static property RG_INTEGER:      DataFormat read new DataFormat($8228);
    public static property STENCIL_INDEX:   DataFormat read new DataFormat($1901);
    public static property DEPTH_COMPONENT: DataFormat read new DataFormat($1902);
    public static property DEPTH_STENCIL:   DataFormat read new DataFormat($84F9);
    
  end;
  
  //S
  GLGetQueries = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ACTIVE_TEXTURE:                            GLGetQueries read new GLGetQueries($84E0);
    public static property ALIASED_LINE_WIDTH_RANGE:                  GLGetQueries read new GLGetQueries($846E);
    public static property ARRAY_BUFFER_BINDING:                      GLGetQueries read new GLGetQueries($8894);
    public static property BLEND_COLOR:                               GLGetQueries read new GLGetQueries($8005);
    public static property BLEND_DST_ALPHA:                           GLGetQueries read new GLGetQueries($80CA);
    public static property BLEND_DST_RGB:                             GLGetQueries read new GLGetQueries($80C8);
    public static property BLEND_EQUATION_RGB:                        GLGetQueries read new GLGetQueries($8009);
    public static property BLEND_EQUATION_ALPHA:                      GLGetQueries read new GLGetQueries($883D);
    public static property BLEND_SRC_ALPHA:                           GLGetQueries read new GLGetQueries($80CB);
    public static property BLEND_SRC_RGB:                             GLGetQueries read new GLGetQueries($80C9);
    public static property COLOR_CLEAR_VALUE:                         GLGetQueries read new GLGetQueries($0C22);
    public static property COLOR_WRITEMASK:                           GLGetQueries read new GLGetQueries($0C23);
    public static property COMPRESSED_TEXTURE_FORMATS:                GLGetQueries read new GLGetQueries($86A3);
    public static property MAX_COMPUTE_SHADER_STORAGE_BLOCKS:         GLGetQueries read new GLGetQueries($90DB);
    public static property MAX_COMBINED_SHADER_STORAGE_BLOCKS:        GLGetQueries read new GLGetQueries($90DC);
    public static property MAX_COMPUTE_UNIFORM_BLOCKS:                GLGetQueries read new GLGetQueries($91BB);
    public static property MAX_COMPUTE_TEXTURE_IMAGE_UNITS:           GLGetQueries read new GLGetQueries($91BC);
    public static property MAX_COMPUTE_UNIFORM_COMPONENTS:            GLGetQueries read new GLGetQueries($8263);
    public static property MAX_COMPUTE_ATOMIC_COUNTERS:               GLGetQueries read new GLGetQueries($8265);
    public static property MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS:        GLGetQueries read new GLGetQueries($8264);
    public static property MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS:   GLGetQueries read new GLGetQueries($8266);
    public static property MAX_COMPUTE_WORK_GROUP_INVOCATIONS:        GLGetQueries read new GLGetQueries($90EB);
    public static property MAX_COMPUTE_WORK_GROUP_COUNT:              GLGetQueries read new GLGetQueries($91BE);
    public static property MAX_COMPUTE_WORK_GROUP_SIZE:               GLGetQueries read new GLGetQueries($91BF);
    public static property DISPATCH_INDIRECT_BUFFER_BINDING:          GLGetQueries read new GLGetQueries($90EF);
    public static property MAX_DEBUG_GROUP_STACK_DEPTH:               GLGetQueries read new GLGetQueries($826C);
    public static property DEBUG_GROUP_STACK_DEPTH:                   GLGetQueries read new GLGetQueries($826D);
    public static property CONTEXT_FLAGS:                             GLGetQueries read new GLGetQueries($821E);
    public static property CULL_FACE_MODE:                            GLGetQueries read new GLGetQueries($0B45);
    public static property CURRENT_PROGRAM:                           GLGetQueries read new GLGetQueries($8B8D);
    public static property DEPTH_CLEAR_VALUE:                         GLGetQueries read new GLGetQueries($0B73);
    public static property DEPTH_FUNC:                                GLGetQueries read new GLGetQueries($0B74);
    public static property DEPTH_RANGE:                               GLGetQueries read new GLGetQueries($0B70);
    public static property DEPTH_WRITEMASK:                           GLGetQueries read new GLGetQueries($0B72);
    public static property DOUBLEBUFFER:                              GLGetQueries read new GLGetQueries($0C32);
    public static property DRAW_BUFFER:                               GLGetQueries read new GLGetQueries($0C01);
    public static property DRAW_FRAMEBUFFER_BINDING:                  GLGetQueries read new GLGetQueries($8CA6);
    public static property READ_FRAMEBUFFER_BINDING:                  GLGetQueries read new GLGetQueries($8CAA);
    public static property ELEMENT_ARRAY_BUFFER_BINDING:              GLGetQueries read new GLGetQueries($8895);
    public static property FRAGMENT_SHADER_DERIVATIVE_HINT:           GLGetQueries read new GLGetQueries($8B8B);
    public static property IMPLEMENTATION_COLOR_READ_FORMAT:          GLGetQueries read new GLGetQueries($8B9B);
    public static property IMPLEMENTATION_COLOR_READ_TYPE:            GLGetQueries read new GLGetQueries($8B9A);
    public static property LINE_SMOOTH_HINT:                          GLGetQueries read new GLGetQueries($0C52);
    public static property LINE_WIDTH:                                GLGetQueries read new GLGetQueries($0B21);
    public static property LAYER_PROVOKING_VERTEX:                    GLGetQueries read new GLGetQueries($825E);
    public static property LOGIC_OP_MODE:                             GLGetQueries read new GLGetQueries($0BF0);
    public static property MAJOR_VERSION:                             GLGetQueries read new GLGetQueries($821B);
    public static property MAX_3D_TEXTURE_SIZE:                       GLGetQueries read new GLGetQueries($8073);
    public static property MAX_ARRAY_TEXTURE_LAYERS:                  GLGetQueries read new GLGetQueries($88FF);
    public static property MAX_CLIP_DISTANCES:                        GLGetQueries read new GLGetQueries($0D32);
    public static property MAX_COLOR_TEXTURE_SAMPLES:                 GLGetQueries read new GLGetQueries($910E);
    public static property MAX_COMBINED_ATOMIC_COUNTERS:              GLGetQueries read new GLGetQueries($92D7);
    public static property MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS:  GLGetQueries read new GLGetQueries($8A33);
    public static property MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS:  GLGetQueries read new GLGetQueries($8A32);
    public static property MAX_COMBINED_TEXTURE_IMAGE_UNITS:          GLGetQueries read new GLGetQueries($8B4D);
    public static property MAX_COMBINED_UNIFORM_BLOCKS:               GLGetQueries read new GLGetQueries($8A2E);
    public static property MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS:    GLGetQueries read new GLGetQueries($8A31);
    public static property MAX_CUBE_MAP_TEXTURE_SIZE:                 GLGetQueries read new GLGetQueries($851C);
    public static property MAX_DEPTH_TEXTURE_SAMPLES:                 GLGetQueries read new GLGetQueries($910F);
    public static property MAX_DRAW_BUFFERS:                          GLGetQueries read new GLGetQueries($8824);
    public static property MAX_DUAL_SOURCE_DRAW_BUFFERS:              GLGetQueries read new GLGetQueries($88FC);
    public static property MAX_ELEMENTS_INDICES:                      GLGetQueries read new GLGetQueries($80E9);
    public static property MAX_ELEMENTS_VERTICES:                     GLGetQueries read new GLGetQueries($80E8);
    public static property MAX_FRAGMENT_ATOMIC_COUNTERS:              GLGetQueries read new GLGetQueries($92D6);
    public static property MAX_FRAGMENT_SHADER_STORAGE_BLOCKS:        GLGetQueries read new GLGetQueries($90DA);
    public static property MAX_FRAGMENT_INPUT_COMPONENTS:             GLGetQueries read new GLGetQueries($9125);
    public static property MAX_FRAGMENT_UNIFORM_COMPONENTS:           GLGetQueries read new GLGetQueries($8B49);
    public static property MAX_FRAGMENT_UNIFORM_VECTORS:              GLGetQueries read new GLGetQueries($8DFD);
    public static property MAX_FRAGMENT_UNIFORM_BLOCKS:               GLGetQueries read new GLGetQueries($8A2D);
    public static property MAX_FRAMEBUFFER_WIDTH:                     GLGetQueries read new GLGetQueries($9315);
    public static property MAX_FRAMEBUFFER_HEIGHT:                    GLGetQueries read new GLGetQueries($9316);
    public static property MAX_FRAMEBUFFER_LAYERS:                    GLGetQueries read new GLGetQueries($9317);
    public static property MAX_FRAMEBUFFER_SAMPLES:                   GLGetQueries read new GLGetQueries($9318);
    public static property MAX_GEOMETRY_ATOMIC_COUNTERS:              GLGetQueries read new GLGetQueries($92D5);
    public static property MAX_GEOMETRY_SHADER_STORAGE_BLOCKS:        GLGetQueries read new GLGetQueries($90D7);
    public static property MAX_GEOMETRY_INPUT_COMPONENTS:             GLGetQueries read new GLGetQueries($9123);
    public static property MAX_GEOMETRY_OUTPUT_COMPONENTS:            GLGetQueries read new GLGetQueries($9124);
    public static property MAX_GEOMETRY_TEXTURE_IMAGE_UNITS:          GLGetQueries read new GLGetQueries($8C29);
    public static property MAX_GEOMETRY_UNIFORM_BLOCKS:               GLGetQueries read new GLGetQueries($8A2C);
    public static property MAX_GEOMETRY_UNIFORM_COMPONENTS:           GLGetQueries read new GLGetQueries($8DDF);
    public static property MAX_INTEGER_SAMPLES:                       GLGetQueries read new GLGetQueries($9110);
    public static property MIN_MAP_BUFFER_ALIGNMENT:                  GLGetQueries read new GLGetQueries($90BC);
    public static property MAX_LABEL_LENGTH:                          GLGetQueries read new GLGetQueries($82E8);
    public static property MAX_PROGRAM_TEXEL_OFFSET:                  GLGetQueries read new GLGetQueries($8905);
    public static property MIN_PROGRAM_TEXEL_OFFSET:                  GLGetQueries read new GLGetQueries($8904);
    public static property MAX_RECTANGLE_TEXTURE_SIZE:                GLGetQueries read new GLGetQueries($84F8);
    public static property MAX_RENDERBUFFER_SIZE:                     GLGetQueries read new GLGetQueries($84E8);
    public static property MAX_SAMPLE_MASK_WORDS:                     GLGetQueries read new GLGetQueries($8E59);
    public static property MAX_SERVER_WAIT_TIMEOUT:                   GLGetQueries read new GLGetQueries($9111);
    public static property MAX_SHADER_STORAGE_BUFFER_BINDINGS:        GLGetQueries read new GLGetQueries($90DD);
    public static property MAX_TESS_CONTROL_ATOMIC_COUNTERS:          GLGetQueries read new GLGetQueries($92D3);
    public static property MAX_TESS_EVALUATION_ATOMIC_COUNTERS:       GLGetQueries read new GLGetQueries($92D4);
    public static property MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS:    GLGetQueries read new GLGetQueries($90D8);
    public static property MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS: GLGetQueries read new GLGetQueries($90D9);
    public static property MAX_TEXTURE_BUFFER_SIZE:                   GLGetQueries read new GLGetQueries($8C2B);
    public static property MAX_TEXTURE_IMAGE_UNITS:                   GLGetQueries read new GLGetQueries($8872);
    public static property MAX_TEXTURE_LOD_BIAS:                      GLGetQueries read new GLGetQueries($84FD);
    public static property MAX_TEXTURE_SIZE:                          GLGetQueries read new GLGetQueries($0D33);
    public static property MAX_UNIFORM_BUFFER_BINDINGS:               GLGetQueries read new GLGetQueries($8A2F);
    public static property MAX_UNIFORM_BLOCK_SIZE:                    GLGetQueries read new GLGetQueries($8A30);
    public static property MAX_UNIFORM_LOCATIONS:                     GLGetQueries read new GLGetQueries($826E);
    public static property MAX_VARYING_COMPONENTS:                    GLGetQueries read new GLGetQueries($8B4B);
    public static property MAX_VARYING_VECTORS:                       GLGetQueries read new GLGetQueries($8DFC);
    public static property MAX_VARYING_FLOATS:                        GLGetQueries read new GLGetQueries($8B4B);
    public static property MAX_VERTEX_ATOMIC_COUNTERS:                GLGetQueries read new GLGetQueries($92D2);
    public static property MAX_VERTEX_ATTRIBS:                        GLGetQueries read new GLGetQueries($8869);
    public static property MAX_VERTEX_SHADER_STORAGE_BLOCKS:          GLGetQueries read new GLGetQueries($90D6);
    public static property MAX_VERTEX_TEXTURE_IMAGE_UNITS:            GLGetQueries read new GLGetQueries($8B4C);
    public static property MAX_VERTEX_UNIFORM_COMPONENTS:             GLGetQueries read new GLGetQueries($8B4A);
    public static property MAX_VERTEX_UNIFORM_VECTORS:                GLGetQueries read new GLGetQueries($8DFB);
    public static property MAX_VERTEX_OUTPUT_COMPONENTS:              GLGetQueries read new GLGetQueries($9122);
    public static property MAX_VERTEX_UNIFORM_BLOCKS:                 GLGetQueries read new GLGetQueries($8A2B);
    public static property MAX_VIEWPORT_DIMS:                         GLGetQueries read new GLGetQueries($0D3A);
    public static property MAX_VIEWPORTS:                             GLGetQueries read new GLGetQueries($825B);
    public static property MINOR_VERSION:                             GLGetQueries read new GLGetQueries($821C);
    public static property NUM_COMPRESSED_TEXTURE_FORMATS:            GLGetQueries read new GLGetQueries($86A2);
    public static property NUM_EXTENSIONS:                            GLGetQueries read new GLGetQueries($821D);
    public static property NUM_PROGRAM_BINARY_FORMATS:                GLGetQueries read new GLGetQueries($87FE);
    public static property NUM_SHADER_BINARY_FORMATS:                 GLGetQueries read new GLGetQueries($8DF9);
    public static property PACK_ALIGNMENT:                            GLGetQueries read new GLGetQueries($0D05);
    public static property PACK_IMAGE_HEIGHT:                         GLGetQueries read new GLGetQueries($806C);
    public static property PACK_LSB_FIRST:                            GLGetQueries read new GLGetQueries($0D01);
    public static property PACK_ROW_LENGTH:                           GLGetQueries read new GLGetQueries($0D02);
    public static property PACK_SKIP_IMAGES:                          GLGetQueries read new GLGetQueries($806B);
    public static property PACK_SKIP_PIXELS:                          GLGetQueries read new GLGetQueries($0D04);
    public static property PACK_SKIP_ROWS:                            GLGetQueries read new GLGetQueries($0D03);
    public static property PACK_SWAP_BYTES:                           GLGetQueries read new GLGetQueries($0D00);
    public static property PIXEL_PACK_BUFFER_BINDING:                 GLGetQueries read new GLGetQueries($88ED);
    public static property PIXEL_UNPACK_BUFFER_BINDING:               GLGetQueries read new GLGetQueries($88EF);
    public static property POINT_FADE_THRESHOLD_SIZE:                 GLGetQueries read new GLGetQueries($8128);
    public static property PRIMITIVE_RESTART_INDEX:                   GLGetQueries read new GLGetQueries($8F9E);
    public static property PROGRAM_BINARY_FORMATS:                    GLGetQueries read new GLGetQueries($87FF);
    public static property PROGRAM_PIPELINE_BINDING:                  GLGetQueries read new GLGetQueries($825A);
    public static property PROGRAM_POINT_SIZE:                        GLGetQueries read new GLGetQueries($8642);
    public static property PROVOKING_VERTEX:                          GLGetQueries read new GLGetQueries($8E4F);
    public static property POINT_SIZE:                                GLGetQueries read new GLGetQueries($0B11);
    public static property POINT_SIZE_GRANULARITY:                    GLGetQueries read new GLGetQueries($0B13);
    public static property POINT_SIZE_RANGE:                          GLGetQueries read new GLGetQueries($0B12);
    public static property POLYGON_OFFSET_FACTOR:                     GLGetQueries read new GLGetQueries($8038);
    public static property POLYGON_OFFSET_UNITS:                      GLGetQueries read new GLGetQueries($2A00);
    public static property POLYGON_SMOOTH_HINT:                       GLGetQueries read new GLGetQueries($0C53);
    public static property READ_BUFFER:                               GLGetQueries read new GLGetQueries($0C02);
    public static property RENDERBUFFER_BINDING:                      GLGetQueries read new GLGetQueries($8CA7);
    public static property SAMPLE_BUFFERS:                            GLGetQueries read new GLGetQueries($80A8);
    public static property SAMPLE_COVERAGE_VALUE:                     GLGetQueries read new GLGetQueries($80AA);
    public static property SAMPLE_COVERAGE_INVERT:                    GLGetQueries read new GLGetQueries($80AB);
    public static property SAMPLER_BINDING:                           GLGetQueries read new GLGetQueries($8919);
    public static property SAMPLES:                                   GLGetQueries read new GLGetQueries($80A9);
    public static property SCISSOR_BOX:                               GLGetQueries read new GLGetQueries($0C10);
    public static property SHADER_COMPILER:                           GLGetQueries read new GLGetQueries($8DFA);
    public static property SHADER_STORAGE_BUFFER_BINDING:             GLGetQueries read new GLGetQueries($90D3);
    public static property SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT:    GLGetQueries read new GLGetQueries($90DF);
    public static property SHADER_STORAGE_BUFFER_START:               GLGetQueries read new GLGetQueries($90D4);
    public static property SHADER_STORAGE_BUFFER_SIZE:                GLGetQueries read new GLGetQueries($90D5);
    public static property SMOOTH_LINE_WIDTH_RANGE:                   GLGetQueries read new GLGetQueries($0B22);
    public static property SMOOTH_LINE_WIDTH_GRANULARITY:             GLGetQueries read new GLGetQueries($0B23);
    public static property STENCIL_BACK_FAIL:                         GLGetQueries read new GLGetQueries($8801);
    public static property STENCIL_BACK_FUNC:                         GLGetQueries read new GLGetQueries($8800);
    public static property STENCIL_BACK_PASS_DEPTH_FAIL:              GLGetQueries read new GLGetQueries($8802);
    public static property STENCIL_BACK_PASS_DEPTH_PASS:              GLGetQueries read new GLGetQueries($8803);
    public static property STENCIL_BACK_REF:                          GLGetQueries read new GLGetQueries($8CA3);
    public static property STENCIL_BACK_VALUE_MASK:                   GLGetQueries read new GLGetQueries($8CA4);
    public static property STENCIL_BACK_WRITEMASK:                    GLGetQueries read new GLGetQueries($8CA5);
    public static property STENCIL_CLEAR_VALUE:                       GLGetQueries read new GLGetQueries($0B91);
    public static property STENCIL_FAIL:                              GLGetQueries read new GLGetQueries($0B94);
    public static property STENCIL_FUNC:                              GLGetQueries read new GLGetQueries($0B92);
    public static property STENCIL_PASS_DEPTH_FAIL:                   GLGetQueries read new GLGetQueries($0B95);
    public static property STENCIL_PASS_DEPTH_PASS:                   GLGetQueries read new GLGetQueries($0B96);
    public static property STENCIL_REF:                               GLGetQueries read new GLGetQueries($0B97);
    public static property STENCIL_VALUE_MASK:                        GLGetQueries read new GLGetQueries($0B93);
    public static property STENCIL_WRITEMASK:                         GLGetQueries read new GLGetQueries($0B98);
    public static property STEREO:                                    GLGetQueries read new GLGetQueries($0C33);
    public static property SUBPIXEL_BITS:                             GLGetQueries read new GLGetQueries($0D50);
    public static property TEXTURE_BINDING_1D:                        GLGetQueries read new GLGetQueries($8068);
    public static property TEXTURE_BINDING_1D_ARRAY:                  GLGetQueries read new GLGetQueries($8C1C);
    public static property TEXTURE_BINDING_2D:                        GLGetQueries read new GLGetQueries($8069);
    public static property TEXTURE_BINDING_2D_ARRAY:                  GLGetQueries read new GLGetQueries($8C1D);
    public static property TEXTURE_BINDING_2D_MULTISAMPLE:            GLGetQueries read new GLGetQueries($9104);
    public static property TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY:      GLGetQueries read new GLGetQueries($9105);
    public static property TEXTURE_BINDING_3D:                        GLGetQueries read new GLGetQueries($806A);
    public static property TEXTURE_BINDING_BUFFER:                    GLGetQueries read new GLGetQueries($8C2C);
    public static property TEXTURE_BINDING_CUBE_MAP:                  GLGetQueries read new GLGetQueries($8514);
    public static property TEXTURE_BINDING_RECTANGLE:                 GLGetQueries read new GLGetQueries($84F6);
    public static property TEXTURE_COMPRESSION_HINT:                  GLGetQueries read new GLGetQueries($84EF);
    public static property TEXTURE_BUFFER_OFFSET_ALIGNMENT:           GLGetQueries read new GLGetQueries($919F);
    public static property TIMESTAMP:                                 GLGetQueries read new GLGetQueries($8E28);
    public static property TRANSFORM_FEEDBACK_BUFFER_BINDING:         GLGetQueries read new GLGetQueries($8C8F);
    public static property TRANSFORM_FEEDBACK_BUFFER_START:           GLGetQueries read new GLGetQueries($8C84);
    public static property TRANSFORM_FEEDBACK_BUFFER_SIZE:            GLGetQueries read new GLGetQueries($8C85);
    public static property UNIFORM_BUFFER_BINDING:                    GLGetQueries read new GLGetQueries($8A28);
    public static property UNIFORM_BUFFER_OFFSET_ALIGNMENT:           GLGetQueries read new GLGetQueries($8A34);
    public static property UNIFORM_BUFFER_SIZE:                       GLGetQueries read new GLGetQueries($8A2A);
    public static property UNIFORM_BUFFER_START:                      GLGetQueries read new GLGetQueries($8A29);
    public static property UNPACK_ALIGNMENT:                          GLGetQueries read new GLGetQueries($0CF5);
    public static property UNPACK_IMAGE_HEIGHT:                       GLGetQueries read new GLGetQueries($806E);
    public static property UNPACK_LSB_FIRST:                          GLGetQueries read new GLGetQueries($0CF1);
    public static property UNPACK_ROW_LENGTH:                         GLGetQueries read new GLGetQueries($0CF2);
    public static property UNPACK_SKIP_IMAGES:                        GLGetQueries read new GLGetQueries($806D);
    public static property UNPACK_SKIP_PIXELS:                        GLGetQueries read new GLGetQueries($0CF4);
    public static property UNPACK_SKIP_ROWS:                          GLGetQueries read new GLGetQueries($0CF3);
    public static property UNPACK_SWAP_BYTES:                         GLGetQueries read new GLGetQueries($0CF0);
    public static property VERTEX_ARRAY_BINDING:                      GLGetQueries read new GLGetQueries($85B5);
    public static property VERTEX_BINDING_DIVISOR:                    GLGetQueries read new GLGetQueries($82D6);
    public static property VERTEX_BINDING_OFFSET:                     GLGetQueries read new GLGetQueries($82D7);
    public static property VERTEX_BINDING_STRIDE:                     GLGetQueries read new GLGetQueries($82D8);
    public static property MAX_VERTEX_ATTRIB_RELATIVE_OFFSET:         GLGetQueries read new GLGetQueries($82D9);
    public static property MAX_VERTEX_ATTRIB_BINDINGS:                GLGetQueries read new GLGetQueries($82DA);
    public static property VIEWPORT:                                  GLGetQueries read new GLGetQueries($0BA2);
    public static property VIEWPORT_BOUNDS_RANGE:                     GLGetQueries read new GLGetQueries($825D);
    public static property VIEWPORT_INDEX_PROVOKING_VERTEX:           GLGetQueries read new GLGetQueries($825F);
    public static property VIEWPORT_SUBPIXEL_BITS:                    GLGetQueries read new GLGetQueries($825C);
    public static property MAX_ELEMENT_INDEX:                         GLGetQueries read new GLGetQueries($8D6B);
    
  end;
  
  //S
  EnablableName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BLEND:                         EnablableName read new EnablableName($0BE2);
    public static property CLIP_DISTANCE0:                EnablableName read new EnablableName($3000);
    public static property CLIP_DISTANCE1:                EnablableName read new EnablableName($3001);
    public static property CLIP_DISTANCE2:                EnablableName read new EnablableName($3002);
    public static property CLIP_DISTANCE3:                EnablableName read new EnablableName($3003);
    public static property CLIP_DISTANCE4:                EnablableName read new EnablableName($3004);
    public static property CLIP_DISTANCE5:                EnablableName read new EnablableName($3005);
    public static property CLIP_DISTANCE6:                EnablableName read new EnablableName($3006);
    public static property CLIP_DISTANCE7:                EnablableName read new EnablableName($3007);
    public static property COLOR_LOGIC_OP:                EnablableName read new EnablableName($0BF2);
    public static property CULL_FACE:                     EnablableName read new EnablableName($0B44);
    public static property DEBUG_OUTPUT:                  EnablableName read new EnablableName($92E0);
    public static property DEBUG_OUTPUT_SYNCHRONOUS:      EnablableName read new EnablableName($8242);
    public static property DEPTH_CLAMP:                   EnablableName read new EnablableName($864F);
    public static property DEPTH_TEST:                    EnablableName read new EnablableName($0B71);
    public static property DITHER:                        EnablableName read new EnablableName($0BD0);
    public static property FRAMEBUFFER_SRGB:              EnablableName read new EnablableName($8DB9);
    public static property LINE_SMOOTH:                   EnablableName read new EnablableName($0B20);
    public static property MULTISAMPLE:                   EnablableName read new EnablableName($809D);
    public static property POLYGON_OFFSET_FILL:           EnablableName read new EnablableName($8037);
    public static property POLYGON_OFFSET_LINE:           EnablableName read new EnablableName($2A02);
    public static property POLYGON_OFFSET_POINT:          EnablableName read new EnablableName($2A01);
    public static property POLYGON_SMOOTH:                EnablableName read new EnablableName($0B41);
    public static property PRIMITIVE_RESTART:             EnablableName read new EnablableName($8F9D);
    public static property PRIMITIVE_RESTART_FIXED_INDEX: EnablableName read new EnablableName($8D69);
    public static property RASTERIZER_DISCARD:            EnablableName read new EnablableName($8C89);
    public static property SAMPLE_ALPHA_TO_COVERAGE:      EnablableName read new EnablableName($809E);
    public static property SAMPLE_ALPHA_TO_ONE:           EnablableName read new EnablableName($809F);
    public static property SAMPLE_COVERAGE:               EnablableName read new EnablableName($80A0);
    public static property SAMPLE_SHADING:                EnablableName read new EnablableName($8C36);
    public static property SAMPLE_MASK:                   EnablableName read new EnablableName($8E51);
    public static property SCISSOR_TEST:                  EnablableName read new EnablableName($0C11);
    public static property STENCIL_TEST:                  EnablableName read new EnablableName($0B90);
    public static property TEXTURE_CUBE_MAP_SEAMLESS:     EnablableName read new EnablableName($884F);
    public static property PROGRAM_POINT_SIZE:            EnablableName read new EnablableName($8642);
    
    public static function operator implicit(v: EnablableName): GLGetQueries := new GLGetQueries(v.val);
    
  end;
  
  //S
  GLGetStringQueries = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property VENDOR:                    GLGetStringQueries read new GLGetStringQueries($1F00);
    public static property RENDERER:                  GLGetStringQueries read new GLGetStringQueries($1F01);
    public static property VERSION:                   GLGetStringQueries read new GLGetStringQueries($1F02);
    public static property EXTENSIONS:                GLGetStringQueries read new GLGetStringQueries($1F03);
    public static property SHADING_LANGUAGE_VERSION:  GLGetStringQueries read new GLGetStringQueries($8B8C);
    
  end;
  
  //SR
  ColorEncodingMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property LINEAR:  ColorEncodingMode read new ColorEncodingMode($2601);
    public static property SRGB:    ColorEncodingMode read new ColorEncodingMode($8C40);
    
    public property IS_LINEAR:  boolean read self = ColorEncodingMode.LINEAR;
    public property IS_SRGB:    boolean read self = ColorEncodingMode.SRGB;
    
    public function ToString: string; override;
    begin
      var res := typeof(ColorEncodingMode).GetProperties.Where(prop->prop.PropertyType=typeof(boolean)).Select(prop->(prop.Name,boolean(prop.GetValue(self)))).FirstOrDefault(t->t[1]);
      Result := res=nil?
        $'ColorEncodingMode[{self.val}]':
        res[0].Substring(3);
    end;
    
  end;
  
  //SR
  DataType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BYTE:                        DataType read new DataType($1400);
    public static property UNSIGNED_BYTE:               DataType read new DataType($1401);
    public static property SHORT:                       DataType read new DataType($1402);
    public static property UNSIGNED_SHORT:              DataType read new DataType($1403);
    public static property INT:                         DataType read new DataType($1404);
    public static property UNSIGNED_INT:                DataType read new DataType($1405);
    public static property FLOAT:                       DataType read new DataType($1406);
    public static property HALF_FLOAT:                  DataType read new DataType($140B);
    public static property UNSIGNED_BYTE_3_3_2:         DataType read new DataType($8032);
    public static property UNSIGNED_SHORT_5_6_5:        DataType read new DataType($8363);
    public static property UNSIGNED_SHORT_4_4_4_4:      DataType read new DataType($8033);
    public static property UNSIGNED_SHORT_5_5_5_1:      DataType read new DataType($8034);
    public static property UNSIGNED_INT_8_8_8_8:        DataType read new DataType($8035);
    public static property UNSIGNED_INT_10_10_10_2:     DataType read new DataType($8036);
    public static property UNSIGNED_BYTE_2_3_3_REV:     DataType read new DataType($8362);
    public static property UNSIGNED_SHORT_5_6_5_REV:    DataType read new DataType($8364);
    public static property UNSIGNED_SHORT_4_4_4_4_REV:  DataType read new DataType($8365);
    public static property UNSIGNED_SHORT_1_5_5_5_REV:  DataType read new DataType($8366);
    public static property UNSIGNED_INT_8_8_8_8_REV:    DataType read new DataType($8367);
    public static property UNSIGNED_INT_2_10_10_10_REV: DataType read new DataType($8368);
    public static property SIGNED_NORMALIZED:           DataType read new DataType($8F9C);
    public static property UNSIGNED_NORMALIZED:         DataType read new DataType($8C17);
    
    public property IS_NONE:                        boolean read self.val = 0;
    public property IS_BYTE:                        boolean read self.val = BYTE.val;
    public property IS_UNSIGNED_BYTE:               boolean read self.val = UNSIGNED_BYTE.val;
    public property IS_SHORT:                       boolean read self.val = SHORT.val;
    public property IS_UNSIGNED_SHORT:              boolean read self.val = UNSIGNED_SHORT.val;
    public property IS_INT:                         boolean read self.val = INT.val;
    public property IS_UNSIGNED_INT:                boolean read self.val = UNSIGNED_INT.val;
    public property IS_FLOAT:                       boolean read self.val = FLOAT.val;
    public property IS_HALF_FLOAT:                  boolean read self.val = HALF_FLOAT.val;
    public property IS_UNSIGNED_BYTE_3_3_2:         boolean read self.val = UNSIGNED_BYTE_3_3_2.val;
    public property IS_UNSIGNED_SHORT_5_6_5:        boolean read self.val = UNSIGNED_SHORT_5_6_5.val;
    public property IS_UNSIGNED_SHORT_4_4_4_4:      boolean read self.val = UNSIGNED_SHORT_4_4_4_4.val;
    public property IS_UNSIGNED_SHORT_5_5_5_1:      boolean read self.val = UNSIGNED_SHORT_5_5_5_1.val;
    public property IS_UNSIGNED_INT_8_8_8_8:        boolean read self.val = UNSIGNED_INT_8_8_8_8.val;
    public property IS_UNSIGNED_INT_10_10_10_2:     boolean read self.val = UNSIGNED_INT_10_10_10_2.val;
    public property IS_UNSIGNED_BYTE_2_3_3_REV:     boolean read self.val = UNSIGNED_BYTE_2_3_3_REV.val;
    public property IS_UNSIGNED_SHORT_5_6_5_REV:    boolean read self.val = UNSIGNED_SHORT_5_6_5_REV.val;
    public property IS_UNSIGNED_SHORT_4_4_4_4_REV:  boolean read self.val = UNSIGNED_SHORT_4_4_4_4_REV.val;
    public property IS_UNSIGNED_SHORT_1_5_5_5_REV:  boolean read self.val = UNSIGNED_SHORT_1_5_5_5_REV.val;
    public property IS_UNSIGNED_INT_8_8_8_8_REV:    boolean read self.val = UNSIGNED_INT_8_8_8_8_REV.val;
    public property IS_UNSIGNED_INT_2_10_10_10_REV: boolean read self.val = UNSIGNED_INT_2_10_10_10_REV.val;
    public property IS_SIGNED_NORMALIZED:           boolean read self.val = SIGNED_NORMALIZED.val;
    public property IS_UNSIGNED_NORMALIZED:         boolean read self.val = UNSIGNED_NORMALIZED.val;
    
    public function ToString: string; override;
    begin
      var res := typeof(DataType).GetProperties.Where(prop->prop.PropertyType=typeof(boolean)).Select(prop->(prop.Name,boolean(prop.GetValue(self)))).FirstOrDefault(t->t[1]);
      Result := res=nil?
        $'DataType[{self.val}]':
        res[0].Substring(3);
    end;
    
  end;
  
  //R
  ProgramVarType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public property FLOAT:             boolean read self.val = $1406;
    public property FLOAT_VEC2:        boolean read self.val = $8B50;
    public property FLOAT_VEC3:        boolean read self.val = $8B51;
    public property FLOAT_VEC4:        boolean read self.val = $8B52;
    public property FLOAT_MAT2:        boolean read self.val = $8B5A;
    public property FLOAT_MAT3:        boolean read self.val = $8B5B;
    public property FLOAT_MAT4:        boolean read self.val = $8B5C;
    public property FLOAT_MAT2x3:      boolean read self.val = $8B65;
    public property FLOAT_MAT3x2:      boolean read self.val = $8B67;
    public property FLOAT_MAT2x4:      boolean read self.val = $8B66;
    public property FLOAT_MAT4x2:      boolean read self.val = $8B69;
    public property FLOAT_MAT3x4:      boolean read self.val = $8B68;
    public property FLOAT_MAT4x3:      boolean read self.val = $8B6A;
    public property INT:               boolean read self.val = $1404;
    public property INT_VEC2:          boolean read self.val = $8B53;
    public property INT_VEC3:          boolean read self.val = $8B54;
    public property INT_VEC4:          boolean read self.val = $8B55;
    public property UNSIGNED_INT:      boolean read self.val = $1405;
    public property UNSIGNED_INT_VEC2: boolean read self.val = $8DC6;
    public property UNSIGNED_INT_VEC3: boolean read self.val = $8DC7;
    public property UNSIGNED_INT_VEC4: boolean read self.val = $8DC8;
    public property DOUBLE:            boolean read self.val = $140A;
    public property DOUBLE_VEC2:       boolean read self.val = $8FFC;
    public property DOUBLE_VEC3:       boolean read self.val = $8FFD;
    public property DOUBLE_VEC4:       boolean read self.val = $8FFE;
    public property DOUBLE_MAT2:       boolean read self.val = $8F46;
    public property DOUBLE_MAT3:       boolean read self.val = $8F47;
    public property DOUBLE_MAT4:       boolean read self.val = $8F48;
    public property DOUBLE_MAT2x3:     boolean read self.val = $8F49;
    public property DOUBLE_MAT3x2:     boolean read self.val = $8F4B;
    public property DOUBLE_MAT2x4:     boolean read self.val = $8F4A;
    public property DOUBLE_MAT4x2:     boolean read self.val = $8F4D;
    public property DOUBLE_MAT3x4:     boolean read self.val = $8F4C;
    public property DOUBLE_MAT4x3:     boolean read self.val = $8F4E;
    
    public function ToString: string; override;
    begin
      var res := typeof(ProgramVarType).GetProperties.Where(prop->prop.PropertyType=typeof(boolean)).Select(prop->(prop.Name,boolean(prop.GetValue(self)))).FirstOrDefault(t->t[1]);
      Result := res=nil?
        $'ProgramVarType[{self.val}]':
        res[0];
    end;
    
  end;
  
  //R
  FramebufferAttachmentObjectType = record
    public val: UInt32;
    
    public property NONE:                boolean read self.val = 0;
    public property FRAMEBUFFER_DEFAULT: boolean read self.val = $8218;
    public property TEXTURE:             boolean read self.val = $1702;
    public property RENDERBUFFER:        boolean read self.val = $8D41;
    
    public function ToString: string; override;
    begin
      var res := typeof(FramebufferAttachmentObjectType).GetProperties.Where(prop->prop.PropertyType=typeof(boolean)).Select(prop->(prop.Name,boolean(prop.GetValue(self)))).FirstOrDefault(t->t[1]);
      Result := res=nil?
        $'FramebufferAttachmentObjectType[{self.val}]':
        res[0];
    end;
    
  end;
  
  //R
  ClientWaitSyncResult = record
    public val: UInt32;
    
    public property ALREADY_SIGNALED:    boolean read self.val = $911A;
    public property TIMEOUT_EXPIRED:     boolean read self.val = $911B;
    public property CONDITION_SATISFIED: boolean read self.val = $911C;
    public property WAIT_FAILED:         boolean read self.val = $911D;
    
    public function ToString: string; override;
    begin
      var res := typeof(ClientWaitSyncResult).GetProperties.Select(prop->(prop.Name,boolean(prop.GetValue(self)))).FirstOrDefault(t->t[1]);
      Result := res=nil?
        $'ClientWaitSyncResult[{self.val}]':
        res[0];
    end;
    
  end;
  
  //R
  ShadingLanguageTypeToken = record
    public val: UInt32;
    
    public property FLOAT:                                     boolean read self.val = $1406;
    public property FLOAT_VEC2:                                boolean read self.val = $8B50;
    public property FLOAT_VEC3:                                boolean read self.val = $8B51;
    public property FLOAT_VEC4:                                boolean read self.val = $8B52;
    public property DOUBLE:                                    boolean read self.val = $140A;
    public property DOUBLE_VEC2:                               boolean read self.val = $8FFC;
    public property DOUBLE_VEC3:                               boolean read self.val = $8FFD;
    public property DOUBLE_VEC4:                               boolean read self.val = $8FFE;
    public property INT:                                       boolean read self.val = $1404;
    public property INT_VEC2:                                  boolean read self.val = $8B53;
    public property INT_VEC3:                                  boolean read self.val = $8B54;
    public property INT_VEC4:                                  boolean read self.val = $8B55;
    public property UNSIGNED_INT:                              boolean read self.val = $1405;
    public property UNSIGNED_INT_VEC2:                         boolean read self.val = $8DC6;
    public property UNSIGNED_INT_VEC3:                         boolean read self.val = $8DC7;
    public property UNSIGNED_INT_VEC4:                         boolean read self.val = $8DC8;
    public property BOOL:                                      boolean read self.val = $8B56;
    public property BOOL_VEC2:                                 boolean read self.val = $8B57;
    public property BOOL_VEC3:                                 boolean read self.val = $8B58;
    public property BOOL_VEC4:                                 boolean read self.val = $8B59;
    public property FLOAT_MAT2:                                boolean read self.val = $8B5A;
    public property FLOAT_MAT3:                                boolean read self.val = $8B5B;
    public property FLOAT_MAT4:                                boolean read self.val = $8B5C;
    public property FLOAT_MAT2x3:                              boolean read self.val = $8B65;
    public property FLOAT_MAT2x4:                              boolean read self.val = $8B66;
    public property FLOAT_MAT3x2:                              boolean read self.val = $8B67;
    public property FLOAT_MAT3x4:                              boolean read self.val = $8B68;
    public property FLOAT_MAT4x2:                              boolean read self.val = $8B69;
    public property FLOAT_MAT4x3:                              boolean read self.val = $8B6A;
    public property DOUBLE_MAT2:                               boolean read self.val = $8F46;
    public property DOUBLE_MAT3:                               boolean read self.val = $8F47;
    public property DOUBLE_MAT4:                               boolean read self.val = $8F48;
    public property DOUBLE_MAT2x3:                             boolean read self.val = $8F49;
    public property DOUBLE_MAT2x4:                             boolean read self.val = $8F4A;
    public property DOUBLE_MAT3x2:                             boolean read self.val = $8F4B;
    public property DOUBLE_MAT3x4:                             boolean read self.val = $8F4C;
    public property DOUBLE_MAT4x2:                             boolean read self.val = $8F4D;
    public property DOUBLE_MAT4x3:                             boolean read self.val = $8F4E;
    public property SAMPLER_1D:                                boolean read self.val = $8B5D;
    public property SAMPLER_2D:                                boolean read self.val = $8B5E;
    public property SAMPLER_3D:                                boolean read self.val = $8B5F;
    public property SAMPLER_CUBE:                              boolean read self.val = $8B60;
    public property SAMPLER_1D_SHADOW:                         boolean read self.val = $8B61;
    public property SAMPLER_2D_SHADOW:                         boolean read self.val = $8B62;
    public property SAMPLER_1D_ARRAY:                          boolean read self.val = $8DC0;
    public property SAMPLER_2D_ARRAY:                          boolean read self.val = $8DC1;
    public property SAMPLER_CUBE_MAP_ARRAY:                    boolean read self.val = $900C;
    public property SAMPLER_1D_ARRAY_SHADOW:                   boolean read self.val = $8DC3;
    public property SAMPLER_2D_ARRAY_SHADOW:                   boolean read self.val = $8DC4;
    public property SAMPLER_2D_MULTISAMPLE:                    boolean read self.val = $9108;
    public property SAMPLER_2D_MULTISAMPLE_ARRAY:              boolean read self.val = $910B;
    public property SAMPLER_CUBE_SHADOW:                       boolean read self.val = $8DC5;
    public property SAMPLER_CUBE_MAP_ARRAY_SHADOW:             boolean read self.val = $900D;
    public property SAMPLER_BUFFER:                            boolean read self.val = $8DC2;
    public property SAMPLER_2D_RECT:                           boolean read self.val = $8B63;
    public property SAMPLER_2D_RECT_SHADOW:                    boolean read self.val = $8B64;
    public property INT_SAMPLER_1D:                            boolean read self.val = $8DC9;
    public property INT_SAMPLER_2D:                            boolean read self.val = $8DCA;
    public property INT_SAMPLER_3D:                            boolean read self.val = $8DCB;
    public property INT_SAMPLER_CUBE:                          boolean read self.val = $8DCC;
    public property INT_SAMPLER_1D_ARRAY:                      boolean read self.val = $8DCE;
    public property INT_SAMPLER_2D_ARRAY:                      boolean read self.val = $8DCF;
    public property INT_SAMPLER_CUBE_MAP_ARRAY:                boolean read self.val = $900E;
    public property INT_SAMPLER_2D_MULTISAMPLE:                boolean read self.val = $9109;
    public property INT_SAMPLER_2D_MULTISAMPLE_ARRAY:          boolean read self.val = $910C;
    public property INT_SAMPLER_BUFFER:                        boolean read self.val = $8DD0;
    public property INT_SAMPLER_2D_RECT:                       boolean read self.val = $8DCD;
    public property UNSIGNED_INT_SAMPLER_1D:                   boolean read self.val = $8DD1;
    public property UNSIGNED_INT_SAMPLER_2D:                   boolean read self.val = $8DD2;
    public property UNSIGNED_INT_SAMPLER_3D:                   boolean read self.val = $8DD3;
    public property UNSIGNED_INT_SAMPLER_CUBE:                 boolean read self.val = $8DD4;
    public property UNSIGNED_INT_SAMPLER_1D_ARRAY:             boolean read self.val = $8DD6;
    public property UNSIGNED_INT_SAMPLER_2D_ARRAY:             boolean read self.val = $8DD7;
    public property UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY:       boolean read self.val = $900F;
    public property UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE:       boolean read self.val = $910A;
    public property UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY: boolean read self.val = $910D;
    public property UNSIGNED_INT_SAMPLER_BUFFER:               boolean read self.val = $8DD8;
    public property UNSIGNED_INT_SAMPLER_2D_RECT:              boolean read self.val = $8DD5;
    public property IMAGE_1D:                                  boolean read self.val = $904C;
    public property IMAGE_2D:                                  boolean read self.val = $904D;
    public property IMAGE_3D:                                  boolean read self.val = $904E;
    public property IMAGE_2D_RECT:                             boolean read self.val = $904F;
    public property IMAGE_CUBE:                                boolean read self.val = $9050;
    public property IMAGE_BUFFER:                              boolean read self.val = $9051;
    public property IMAGE_1D_ARRAY:                            boolean read self.val = $9052;
    public property IMAGE_2D_ARRAY:                            boolean read self.val = $9053;
    public property IMAGE_CUBE_MAP_ARRAY:                      boolean read self.val = $9054;
    public property IMAGE_2D_MULTISAMPLE:                      boolean read self.val = $9055;
    public property IMAGE_2D_MULTISAMPLE_ARRAY:                boolean read self.val = $9056;
    public property INT_IMAGE_1D:                              boolean read self.val = $9057;
    public property INT_IMAGE_2D:                              boolean read self.val = $9058;
    public property INT_IMAGE_3D:                              boolean read self.val = $9059;
    public property INT_IMAGE_2D_RECT:                         boolean read self.val = $905A;
    public property INT_IMAGE_CUBE:                            boolean read self.val = $905B;
    public property INT_IMAGE_BUFFER:                          boolean read self.val = $905C;
    public property INT_IMAGE_1D_ARRAY:                        boolean read self.val = $905D;
    public property INT_IMAGE_2D_ARRAY:                        boolean read self.val = $905E;
    public property INT_IMAGE_CUBE_MAP_ARRAY:                  boolean read self.val = $905F;
    public property INT_IMAGE_2D_MULTISAMPLE:                  boolean read self.val = $9060;
    public property INT_IMAGE_2D_MULTISAMPLE_ARRAY:            boolean read self.val = $9061;
    public property UNSIGNED_INT_IMAGE_1D:                     boolean read self.val = $9062;
    public property UNSIGNED_INT_IMAGE_2D:                     boolean read self.val = $9063;
    public property UNSIGNED_INT_IMAGE_3D:                     boolean read self.val = $9064;
    public property UNSIGNED_INT_IMAGE_2D_RECT:                boolean read self.val = $9065;
    public property UNSIGNED_INT_IMAGE_CUBE:                   boolean read self.val = $9066;
    public property UNSIGNED_INT_IMAGE_BUFFER:                 boolean read self.val = $9067;
    public property UNSIGNED_INT_IMAGE_1D_ARRAY:               boolean read self.val = $9068;
    public property UNSIGNED_INT_IMAGE_2D_ARRAY:               boolean read self.val = $9069;
    public property UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY:         boolean read self.val = $906A;
    public property UNSIGNED_INT_IMAGE_2D_MULTISAMPLE:         boolean read self.val = $906B;
    public property UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY:   boolean read self.val = $906C;
    public property UNSIGNED_INT_ATOMIC_COUNTER:               boolean read self.val = $92DB;
    
  end;
  
  //R
  DebugSourceType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public property API:                 boolean read self.val = $8246;
    public property WINDOW_SYSTEM:       boolean read self.val = $8247;
    public property SHADER_COMPILER:     boolean read self.val = $8248;
    public property THIRD_PARTY:         boolean read self.val = $8249;
    public property APPLICATION:         boolean read self.val = $824A;
    public property OTHER:               boolean read self.val = $824B;
    public property API_ARB:             boolean read self.val = $8246;
    public property WINDOW_SYSTEM_ARB:   boolean read self.val = $8247;
    public property SHADER_COMPILER_ARB: boolean read self.val = $8248;
    public property THIRD_PARTY_ARB:     boolean read self.val = $8249;
    public property APPLICATION_ARB:     boolean read self.val = $824A;
    public property OTHER_ARB:           boolean read self.val = $824B;
    
    public function ToString: string; override;
    begin
      var res := typeof(DebugSourceType).GetProperties.Where(prop->prop.PropertyType=typeof(boolean)).Select(prop->(prop.Name,boolean(prop.GetValue(self)))).FirstOrDefault(t->t[1]);
      Result := res=nil?
        $'DebugSourceType[{self.val}]':
        res[0];
    end;
    
  end;
  
  //R
  DebugMessageType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public property ERROR:               boolean read self.val = $824C;
    public property DEPRECATED_BEHAVIOR: boolean read self.val = $824D;
    public property UNDEFINED_BEHAVIOR:  boolean read self.val = $824E;
    public property PORTABILITY:         boolean read self.val = $824F;
    public property PERFORMANCE:         boolean read self.val = $8250;
    public property OTHER:               boolean read self.val = $8251;
    public property MARKER:              boolean read self.val = $8268;
    public property PUSH_GROUP:          boolean read self.val = $8269;
    public property POP_GROUP:           boolean read self.val = $826A;
    
    public function ToString: string; override;
    begin
      var res := typeof(DebugMessageType).GetProperties.Where(prop->prop.PropertyType=typeof(boolean)).Select(prop->(prop.Name,boolean(prop.GetValue(self)))).FirstOrDefault(t->t[1]);
      Result := res=nil?
        $'DebugMessageType[{self.val}]':
        res[0];
    end;
    
  end;
  
  //R
  DebugSeverityLevel = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public property HIGH:          boolean read self.val = $9146;
    public property MEDIUM:        boolean read self.val = $9147;
    public property LOW:           boolean read self.val = $9148;
    public property NOTIFICATION:  boolean read self.val = $826B;
    
    public function ToString: string; override;
    begin
      var res := typeof(DebugSeverityLevel).GetProperties.Where(prop->prop.PropertyType=typeof(boolean)).Select(prop->(prop.Name,boolean(prop.GetValue(self)))).FirstOrDefault(t->t[1]);
      Result := res=nil?
        $'DebugSeverityLevel[{self.val}]':
        res[0];
    end;
    
  end;
  
  {$endregion 1 значение}
  
  {$region Флаги}
  
  //S
  GDI_PixelFormatFlags = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property DOUBLEBUFFER:          GDI_PixelFormatFlags read new GDI_PixelFormatFlags($00000001);
    public static property STEREO:                GDI_PixelFormatFlags read new GDI_PixelFormatFlags($00000002);
    public static property DRAW_TO_WINDOW:        GDI_PixelFormatFlags read new GDI_PixelFormatFlags($00000004);
    public static property DRAW_TO_BITMAP:        GDI_PixelFormatFlags read new GDI_PixelFormatFlags($00000008);
    public static property SUPPORT_GDI:           GDI_PixelFormatFlags read new GDI_PixelFormatFlags($00000010);
    public static property SUPPORT_OPENGL:        GDI_PixelFormatFlags read new GDI_PixelFormatFlags($00000020);
    public static property GENERIC_FORMAT:        GDI_PixelFormatFlags read new GDI_PixelFormatFlags($00000040);
    public static property NEED_PALETTE:          GDI_PixelFormatFlags read new GDI_PixelFormatFlags($00000080);
    public static property NEED_SYSTEM_PALETTE:   GDI_PixelFormatFlags read new GDI_PixelFormatFlags($00000100);
    public static property SWAP_EXCHANGE:         GDI_PixelFormatFlags read new GDI_PixelFormatFlags($00000200);
    public static property SWAP_COPY:             GDI_PixelFormatFlags read new GDI_PixelFormatFlags($00000400);
    public static property SWAP_LAYER_BUFFERS:    GDI_PixelFormatFlags read new GDI_PixelFormatFlags($00000800);
    public static property GENERIC_ACCELERATED:   GDI_PixelFormatFlags read new GDI_PixelFormatFlags($00001000);
    public static property SUPPORT_DIRECTDRAW:    GDI_PixelFormatFlags read new GDI_PixelFormatFlags($00002000);
    public static property DEPTH_DONTCARE:        GDI_PixelFormatFlags read new GDI_PixelFormatFlags($20000000);
    public static property DOUBLEBUFFER_DONTCARE: GDI_PixelFormatFlags read new GDI_PixelFormatFlags($40000000);
    public static property STEREO_DONTCARE:       GDI_PixelFormatFlags read new GDI_PixelFormatFlags($80000000);
    
    public static function operator or(v1,v2: GDI_PixelFormatFlags): GDI_PixelFormatFlags := new GDI_PixelFormatFlags(v1.val or v2.val);
    
  end;
  
  //S
  BufferTypeFlags = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property COLOR_BUFFER_BIT:    BufferTypeFlags read new BufferTypeFlags($00004000);
    public static property DEPTH_BUFFER_BIT:    BufferTypeFlags read new BufferTypeFlags($00000100);
    public static property STENCIL_BUFFER_BIT:  BufferTypeFlags read new BufferTypeFlags($00000400);
    
    public static function operator or(f1,f2: BufferTypeFlags): BufferTypeFlags := new BufferTypeFlags(f1.val or f2.val);
    
  end;
  
  //S
  MemoryBarrierTypeFlags = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property VERTEX_ATTRIB_ARRAY_BARRIER_BIT: MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($00000001);
    public static property ELEMENT_ARRAY_BARRIER_BIT:       MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($00000002);
    public static property UNIFORM_BARRIER_BIT:             MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($00000004);
    public static property TEXTURE_FETCH_BARRIER_BIT:       MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($00000008);
    public static property SHADER_IMAGE_ACCESS_BARRIER_BIT: MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($00000020);
    public static property COMMAND_BARRIER_BIT:             MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($00000040);
    public static property PIXEL_BUFFER_BARRIER_BIT:        MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($00000080);
    public static property TEXTURE_UPDATE_BARRIER_BIT:      MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($00000100);
    public static property BUFFER_UPDATE_BARRIER_BIT:       MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($00000200);
    public static property FRAMEBUFFER_BARRIER_BIT:         MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($00000400);
    public static property TRANSFORM_FEEDBACK_BARRIER_BIT:  MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($00000800);
    public static property ATOMIC_COUNTER_BARRIER_BIT:      MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($00001000);
    public static property SHADER_STORAGE_BARRIER_BIT:      MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($00002000);
    public static property QUERY_BUFFER_BARRIER_BIT:        MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($00008000);
    public static property ALL_BARRIER_BITS:                MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($FFFFFFFF);
    
    public static function operator or(f1,f2: MemoryBarrierTypeFlags): MemoryBarrierTypeFlags := new MemoryBarrierTypeFlags(f1.val or f2.val);
    
  end;
  
  //S
  ProgramStagesFlags = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property VERTEX_SHADER_BIT:           ProgramStagesFlags read new ProgramStagesFlags($00000001);
    public static property FRAGMENT_SHADER_BIT:         ProgramStagesFlags read new ProgramStagesFlags($00000002);
    public static property GEOMETRY_SHADER_BIT:         ProgramStagesFlags read new ProgramStagesFlags($00000004);
    public static property TESS_CONTROL_SHADER_BIT:     ProgramStagesFlags read new ProgramStagesFlags($00000008);
    public static property TESS_EVALUATION_SHADER_BIT:  ProgramStagesFlags read new ProgramStagesFlags($00000010);
    public static property COMPUTE_SHADER_BIT:          ProgramStagesFlags read new ProgramStagesFlags($00000020);
    public static property ALL_SHADER_BITS:             ProgramStagesFlags read new ProgramStagesFlags($FFFFFFFF);
    
    public static function operator or(f1,f2: ProgramStagesFlags): ProgramStagesFlags := new ProgramStagesFlags(f1.val or f2.val);
    
  end;
  
  //S
  ReservedFlags = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE: ReservedFlags read new ReservedFlags($0);
    
    public static function operator or(f1,f2: ReservedFlags): ReservedFlags := new ReservedFlags(f1.val or f2.val);
    
  end;
  
  //S
  CommandFlushingBehaviorFlags = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SYNC_FLUSH_COMMANDS:  CommandFlushingBehaviorFlags read new CommandFlushingBehaviorFlags($00000001);
    
    public static function operator or(f1,f2: CommandFlushingBehaviorFlags): CommandFlushingBehaviorFlags := new CommandFlushingBehaviorFlags(f1.val or f2.val);
    
  end;
  
  //S
  BufferMapFlags = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property READ_BIT:              BufferMapFlags read new BufferMapFlags($0001);
    public static property WRITE_BIT:             BufferMapFlags read new BufferMapFlags($0002);
    public static property INVALIDATE_RANGE_BIT:  BufferMapFlags read new BufferMapFlags($0004);
    public static property INVALIDATE_BUFFER_BIT: BufferMapFlags read new BufferMapFlags($0008);
    public static property FLUSH_EXPLICIT_BIT:    BufferMapFlags read new BufferMapFlags($0010);
    public static property UNSYNCHRONIZED_BIT:    BufferMapFlags read new BufferMapFlags($0020);
    public static property PERSISTENT_BIT:        BufferMapFlags read new BufferMapFlags($0040);
    public static property COHERENT_BIT:          BufferMapFlags read new BufferMapFlags($0080);
    
    public static function operator or(f1,f2: BufferMapFlags): BufferMapFlags := new BufferMapFlags(f1.val or f2.val);
    
  end;
  
  //S
  BufferStorageFlags = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
//    public static property NONE:                BufferStorageFlags read new BufferStorageFlags(0); //ToDo узнать надо ли
    public static property MAP_READ_BIT:        BufferStorageFlags read new BufferStorageFlags($0001);
    public static property MAP_WRITE_BIT:       BufferStorageFlags read new BufferStorageFlags($0002);
    public static property MAP_PERSISTENT_BIT:  BufferStorageFlags read new BufferStorageFlags($0040);
    public static property MAP_COHERENT_BIT:    BufferStorageFlags read new BufferStorageFlags($0080);
    public static property DYNAMIC_STORAGE_BIT: BufferStorageFlags read new BufferStorageFlags($0100);
    public static property CLIENT_STORAGE_BIT:  BufferStorageFlags read new BufferStorageFlags($0200);
    
    public static function operator or(f1,f2: BufferStorageFlags): BufferStorageFlags := new BufferStorageFlags(f1.val or f2.val);
    
  end;
  
  {$endregion Флаги}
  
{$endregion Энумы}

{$region Делегаты}

type
  [UnmanagedFunctionPointer(CallingConvention.StdCall)]
  GLDEBUGPROC = procedure(source: DebugSourceType; &type: DebugMessageType; id: UInt32; severity: DebugSeverityLevel; length: Int32; message_text: IntPtr; userParam: pointer);
  
  [UnmanagedFunctionPointer(CallingConvention.StdCall)]
  GLVULKANPROCNV = procedure;
  
  //ToDo category, severity - энумы
  [UnmanagedFunctionPointer(CallingConvention.StdCall)]
  GLDEBUGPROCAMD = procedure(id: UInt32; category: UInt32; severity: UInt32; length: Int32; message: IntPtr; userParam: IntPtr);
  
{$endregion Делегаты}

{$region Записи} type
  
  {$region Vec}
  
  {$region Vec1}
  
  Vec1b = record
    public val0: SByte;
    
    public constructor(val0: SByte);
    begin
      self.val0 := val0;
    end;
    
    private function GetValAt(i: integer): SByte;
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^SByte := pointer(new IntPtr(@self) + i*1 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: SByte);
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^SByte := pointer(new IntPtr(@self) + i*1 );
      ptr^ := val;
    end;
    public property val[i: integer]: SByte read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec1b): Vec1b := new Vec1b(-v.val0);
    public static function operator*(v: Vec1b; k: SByte): Vec1b := new Vec1b(v.val0*k);
    public static function operator+(v1, v2: Vec1b): Vec1b := new Vec1b(v1.val0+v2.val0);
    public static function operator-(v1, v2: Vec1b): Vec1b := new Vec1b(v1.val0-v2.val0);
    
    public function SqrLength := val0*val0;
    
    public function SqrLength_d: double := real(val0)*val0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec1b;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec1ub = record
    public val0: Byte;
    
    public constructor(val0: Byte);
    begin
      self.val0 := val0;
    end;
    
    private function GetValAt(i: integer): Byte;
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^Byte := pointer(new IntPtr(@self) + i*1 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Byte);
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^Byte := pointer(new IntPtr(@self) + i*1 );
      ptr^ := val;
    end;
    public property val[i: integer]: Byte read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec1ub; k: Byte): Vec1ub := new Vec1ub(v.val0*k);
    public static function operator+(v1, v2: Vec1ub): Vec1ub := new Vec1ub(v1.val0+v2.val0);
    public static function operator-(v1, v2: Vec1ub): Vec1ub := new Vec1ub(v1.val0-v2.val0);
    
    public static function operator implicit(v: Vec1b): Vec1ub := new Vec1ub(v.val0);
    public static function operator implicit(v: Vec1ub): Vec1b := new Vec1b(v.val0);
    
    public function SqrLength := val0*val0;
    
    public function SqrLength_d: double := real(val0)*val0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec1ub;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec1s = record
    public val0: Int16;
    
    public constructor(val0: Int16);
    begin
      self.val0 := val0;
    end;
    
    private function GetValAt(i: integer): Int16;
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^Int16 := pointer(new IntPtr(@self) + i*2 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Int16);
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^Int16 := pointer(new IntPtr(@self) + i*2 );
      ptr^ := val;
    end;
    public property val[i: integer]: Int16 read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec1s): Vec1s := new Vec1s(-v.val0);
    public static function operator*(v: Vec1s; k: Int16): Vec1s := new Vec1s(v.val0*k);
    public static function operator+(v1, v2: Vec1s): Vec1s := new Vec1s(v1.val0+v2.val0);
    public static function operator-(v1, v2: Vec1s): Vec1s := new Vec1s(v1.val0-v2.val0);
    
    public static function operator implicit(v: Vec1b): Vec1s := new Vec1s(v.val0);
    public static function operator implicit(v: Vec1s): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec1s := new Vec1s(v.val0);
    public static function operator implicit(v: Vec1s): Vec1ub := new Vec1ub(v.val0);
    
    public function SqrLength := val0*val0;
    
    public function SqrLength_d: double := real(val0)*val0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec1s;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec1us = record
    public val0: UInt16;
    
    public constructor(val0: UInt16);
    begin
      self.val0 := val0;
    end;
    
    private function GetValAt(i: integer): UInt16;
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^UInt16 := pointer(new IntPtr(@self) + i*2 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: UInt16);
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^UInt16 := pointer(new IntPtr(@self) + i*2 );
      ptr^ := val;
    end;
    public property val[i: integer]: UInt16 read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec1us; k: UInt16): Vec1us := new Vec1us(v.val0*k);
    public static function operator+(v1, v2: Vec1us): Vec1us := new Vec1us(v1.val0+v2.val0);
    public static function operator-(v1, v2: Vec1us): Vec1us := new Vec1us(v1.val0-v2.val0);
    
    public static function operator implicit(v: Vec1b): Vec1us := new Vec1us(v.val0);
    public static function operator implicit(v: Vec1us): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec1us := new Vec1us(v.val0);
    public static function operator implicit(v: Vec1us): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec1us := new Vec1us(v.val0);
    public static function operator implicit(v: Vec1us): Vec1s := new Vec1s(v.val0);
    
    public function SqrLength := val0*val0;
    
    public function SqrLength_d: double := real(val0)*val0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec1us;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec1i = record
    public val0: Int32;
    
    public constructor(val0: Int32);
    begin
      self.val0 := val0;
    end;
    
    private function GetValAt(i: integer): Int32;
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^Int32 := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Int32);
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^Int32 := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: Int32 read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec1i): Vec1i := new Vec1i(-v.val0);
    public static function operator*(v: Vec1i; k: Int32): Vec1i := new Vec1i(v.val0*k);
    public static function operator+(v1, v2: Vec1i): Vec1i := new Vec1i(v1.val0+v2.val0);
    public static function operator-(v1, v2: Vec1i): Vec1i := new Vec1i(v1.val0-v2.val0);
    
    public static function operator implicit(v: Vec1b): Vec1i := new Vec1i(v.val0);
    public static function operator implicit(v: Vec1i): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec1i := new Vec1i(v.val0);
    public static function operator implicit(v: Vec1i): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec1i := new Vec1i(v.val0);
    public static function operator implicit(v: Vec1i): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec1i := new Vec1i(v.val0);
    public static function operator implicit(v: Vec1i): Vec1us := new Vec1us(v.val0);
    
    public function SqrLength := val0*val0;
    
    public function SqrLength_d: double := real(val0)*val0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec1i;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec1ui = record
    public val0: UInt32;
    
    public constructor(val0: UInt32);
    begin
      self.val0 := val0;
    end;
    
    private function GetValAt(i: integer): UInt32;
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^UInt32 := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: UInt32);
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^UInt32 := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: UInt32 read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec1ui; k: UInt32): Vec1ui := new Vec1ui(v.val0*k);
    public static function operator+(v1, v2: Vec1ui): Vec1ui := new Vec1ui(v1.val0+v2.val0);
    public static function operator-(v1, v2: Vec1ui): Vec1ui := new Vec1ui(v1.val0-v2.val0);
    
    public static function operator implicit(v: Vec1b): Vec1ui := new Vec1ui(v.val0);
    public static function operator implicit(v: Vec1ui): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec1ui := new Vec1ui(v.val0);
    public static function operator implicit(v: Vec1ui): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec1ui := new Vec1ui(v.val0);
    public static function operator implicit(v: Vec1ui): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec1ui := new Vec1ui(v.val0);
    public static function operator implicit(v: Vec1ui): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec1ui := new Vec1ui(v.val0);
    public static function operator implicit(v: Vec1ui): Vec1i := new Vec1i(v.val0);
    
    public function SqrLength := val0*val0;
    
    public function SqrLength_d: double := real(val0)*val0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec1ui;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec1i64 = record
    public val0: Int64;
    
    public constructor(val0: Int64);
    begin
      self.val0 := val0;
    end;
    
    private function GetValAt(i: integer): Int64;
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^Int64 := pointer(new IntPtr(@self) + i*8 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Int64);
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^Int64 := pointer(new IntPtr(@self) + i*8 );
      ptr^ := val;
    end;
    public property val[i: integer]: Int64 read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec1i64): Vec1i64 := new Vec1i64(-v.val0);
    public static function operator*(v: Vec1i64; k: Int64): Vec1i64 := new Vec1i64(v.val0*k);
    public static function operator+(v1, v2: Vec1i64): Vec1i64 := new Vec1i64(v1.val0+v2.val0);
    public static function operator-(v1, v2: Vec1i64): Vec1i64 := new Vec1i64(v1.val0-v2.val0);
    
    public static function operator implicit(v: Vec1b): Vec1i64 := new Vec1i64(v.val0);
    public static function operator implicit(v: Vec1i64): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec1i64 := new Vec1i64(v.val0);
    public static function operator implicit(v: Vec1i64): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec1i64 := new Vec1i64(v.val0);
    public static function operator implicit(v: Vec1i64): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec1i64 := new Vec1i64(v.val0);
    public static function operator implicit(v: Vec1i64): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec1i64 := new Vec1i64(v.val0);
    public static function operator implicit(v: Vec1i64): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec1i64 := new Vec1i64(v.val0);
    public static function operator implicit(v: Vec1i64): Vec1ui := new Vec1ui(v.val0);
    
    public function SqrLength := val0*val0;
    
    public function SqrLength_d: double := real(val0)*val0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec1i64;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec1ui64 = record
    public val0: UInt64;
    
    public constructor(val0: UInt64);
    begin
      self.val0 := val0;
    end;
    
    private function GetValAt(i: integer): UInt64;
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^UInt64 := pointer(new IntPtr(@self) + i*8 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: UInt64);
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^UInt64 := pointer(new IntPtr(@self) + i*8 );
      ptr^ := val;
    end;
    public property val[i: integer]: UInt64 read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec1ui64; k: UInt64): Vec1ui64 := new Vec1ui64(v.val0*k);
    public static function operator+(v1, v2: Vec1ui64): Vec1ui64 := new Vec1ui64(v1.val0+v2.val0);
    public static function operator-(v1, v2: Vec1ui64): Vec1ui64 := new Vec1ui64(v1.val0-v2.val0);
    
    public static function operator implicit(v: Vec1b): Vec1ui64 := new Vec1ui64(v.val0);
    public static function operator implicit(v: Vec1ui64): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec1ui64 := new Vec1ui64(v.val0);
    public static function operator implicit(v: Vec1ui64): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec1ui64 := new Vec1ui64(v.val0);
    public static function operator implicit(v: Vec1ui64): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec1ui64 := new Vec1ui64(v.val0);
    public static function operator implicit(v: Vec1ui64): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec1ui64 := new Vec1ui64(v.val0);
    public static function operator implicit(v: Vec1ui64): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec1ui64 := new Vec1ui64(v.val0);
    public static function operator implicit(v: Vec1ui64): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec1ui64 := new Vec1ui64(v.val0);
    public static function operator implicit(v: Vec1ui64): Vec1i64 := new Vec1i64(v.val0);
    
    public function SqrLength := val0*val0;
    
    public function SqrLength_d: double := real(val0)*val0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec1ui64;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec1f = record
    public val0: single;
    
    public constructor(val0: single);
    begin
      self.val0 := val0;
    end;
    
    private function GetValAt(i: integer): single;
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^single := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: single);
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^single := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: single read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec1f): Vec1f := new Vec1f(-v.val0);
    public static function operator*(v: Vec1f; k: single): Vec1f := new Vec1f(v.val0*k);
    public static function operator/(v: Vec1f; k: single): Vec1f := new Vec1f(v.val0/k);
    public static function operator+(v1, v2: Vec1f): Vec1f := new Vec1f(v1.val0+v2.val0);
    public static function operator-(v1, v2: Vec1f): Vec1f := new Vec1f(v1.val0-v2.val0);
    
    public static function operator implicit(v: Vec1b): Vec1f := new Vec1f(v.val0);
    public static function operator implicit(v: Vec1f): Vec1b := new Vec1b(Convert.ToSByte(v.val0));
    
    public static function operator implicit(v: Vec1ub): Vec1f := new Vec1f(v.val0);
    public static function operator implicit(v: Vec1f): Vec1ub := new Vec1ub(Convert.ToByte(v.val0));
    
    public static function operator implicit(v: Vec1s): Vec1f := new Vec1f(v.val0);
    public static function operator implicit(v: Vec1f): Vec1s := new Vec1s(Convert.ToInt16(v.val0));
    
    public static function operator implicit(v: Vec1us): Vec1f := new Vec1f(v.val0);
    public static function operator implicit(v: Vec1f): Vec1us := new Vec1us(Convert.ToUInt16(v.val0));
    
    public static function operator implicit(v: Vec1i): Vec1f := new Vec1f(v.val0);
    public static function operator implicit(v: Vec1f): Vec1i := new Vec1i(Convert.ToInt32(v.val0));
    
    public static function operator implicit(v: Vec1ui): Vec1f := new Vec1f(v.val0);
    public static function operator implicit(v: Vec1f): Vec1ui := new Vec1ui(Convert.ToUInt32(v.val0));
    
    public static function operator implicit(v: Vec1i64): Vec1f := new Vec1f(v.val0);
    public static function operator implicit(v: Vec1f): Vec1i64 := new Vec1i64(Convert.ToInt64(v.val0));
    
    public static function operator implicit(v: Vec1ui64): Vec1f := new Vec1f(v.val0);
    public static function operator implicit(v: Vec1f): Vec1ui64 := new Vec1ui64(Convert.ToUInt64(v.val0));
    
    public function SqrLength := val0*val0;
    
    public function SqrLength_d: double := real(val0)*val0;
    
    public function Normalized := self / single(Sqrt(self.SqrLength_d));
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec1f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec1d = record
    public val0: double;
    
    public constructor(val0: double);
    begin
      self.val0 := val0;
    end;
    
    private function GetValAt(i: integer): double;
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^double := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: double);
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^double := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: double read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec1d): Vec1d := new Vec1d(-v.val0);
    public static function operator*(v: Vec1d; k: double): Vec1d := new Vec1d(v.val0*k);
    public static function operator/(v: Vec1d; k: double): Vec1d := new Vec1d(v.val0/k);
    public static function operator+(v1, v2: Vec1d): Vec1d := new Vec1d(v1.val0+v2.val0);
    public static function operator-(v1, v2: Vec1d): Vec1d := new Vec1d(v1.val0-v2.val0);
    
    public static function operator implicit(v: Vec1b): Vec1d := new Vec1d(v.val0);
    public static function operator implicit(v: Vec1d): Vec1b := new Vec1b(Convert.ToSByte(v.val0));
    
    public static function operator implicit(v: Vec1ub): Vec1d := new Vec1d(v.val0);
    public static function operator implicit(v: Vec1d): Vec1ub := new Vec1ub(Convert.ToByte(v.val0));
    
    public static function operator implicit(v: Vec1s): Vec1d := new Vec1d(v.val0);
    public static function operator implicit(v: Vec1d): Vec1s := new Vec1s(Convert.ToInt16(v.val0));
    
    public static function operator implicit(v: Vec1us): Vec1d := new Vec1d(v.val0);
    public static function operator implicit(v: Vec1d): Vec1us := new Vec1us(Convert.ToUInt16(v.val0));
    
    public static function operator implicit(v: Vec1i): Vec1d := new Vec1d(v.val0);
    public static function operator implicit(v: Vec1d): Vec1i := new Vec1i(Convert.ToInt32(v.val0));
    
    public static function operator implicit(v: Vec1ui): Vec1d := new Vec1d(v.val0);
    public static function operator implicit(v: Vec1d): Vec1ui := new Vec1ui(Convert.ToUInt32(v.val0));
    
    public static function operator implicit(v: Vec1i64): Vec1d := new Vec1d(v.val0);
    public static function operator implicit(v: Vec1d): Vec1i64 := new Vec1i64(Convert.ToInt64(v.val0));
    
    public static function operator implicit(v: Vec1ui64): Vec1d := new Vec1d(v.val0);
    public static function operator implicit(v: Vec1d): Vec1ui64 := new Vec1ui64(Convert.ToUInt64(v.val0));
    
    public static function operator implicit(v: Vec1f): Vec1d := new Vec1d(v.val0);
    public static function operator implicit(v: Vec1d): Vec1f := new Vec1f(v.val0);
    
    public function SqrLength := val0*val0;
    
    public function Normalized := self / Sqrt(self.SqrLength);
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec1d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  {$endregion Vec1}
  
  {$region Vec2}
  
  Vec2b = record
    public val0: SByte;
    public val1: SByte;
    
    public constructor(val0, val1: SByte);
    begin
      self.val0 := val0;
      self.val1 := val1;
    end;
    
    private function GetValAt(i: integer): SByte;
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^SByte := pointer(new IntPtr(@self) + i*1 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: SByte);
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^SByte := pointer(new IntPtr(@self) + i*1 );
      ptr^ := val;
    end;
    public property val[i: integer]: SByte read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec2b): Vec2b := new Vec2b(-v.val0, -v.val1);
    public static function operator*(v: Vec2b; k: SByte): Vec2b := new Vec2b(v.val0*k, v.val1*k);
    public static function operator+(v1, v2: Vec2b): Vec2b := new Vec2b(v1.val0+v2.val0, v1.val1+v2.val1);
    public static function operator-(v1, v2: Vec2b): Vec2b := new Vec2b(v1.val0-v2.val0, v1.val1-v2.val1);
    
    public static function operator implicit(v: Vec1b): Vec2b := new Vec2b(v.val0, 0);
    public static function operator implicit(v: Vec2b): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec2b := new Vec2b(v.val0, 0);
    public static function operator implicit(v: Vec2b): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec2b := new Vec2b(v.val0, 0);
    public static function operator implicit(v: Vec2b): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec2b := new Vec2b(v.val0, 0);
    public static function operator implicit(v: Vec2b): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec2b := new Vec2b(v.val0, 0);
    public static function operator implicit(v: Vec2b): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec2b := new Vec2b(v.val0, 0);
    public static function operator implicit(v: Vec2b): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec2b := new Vec2b(v.val0, 0);
    public static function operator implicit(v: Vec2b): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec2b := new Vec2b(v.val0, 0);
    public static function operator implicit(v: Vec2b): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec2b := new Vec2b(Convert.ToSByte(v.val0), 0);
    public static function operator implicit(v: Vec2b): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec2b := new Vec2b(Convert.ToSByte(v.val0), 0);
    public static function operator implicit(v: Vec2b): Vec1d := new Vec1d(v.val0);
    
    public function SqrLength := val0*val0 + val1*val1;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec2b;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec2ub = record
    public val0: Byte;
    public val1: Byte;
    
    public constructor(val0, val1: Byte);
    begin
      self.val0 := val0;
      self.val1 := val1;
    end;
    
    private function GetValAt(i: integer): Byte;
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^Byte := pointer(new IntPtr(@self) + i*1 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Byte);
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^Byte := pointer(new IntPtr(@self) + i*1 );
      ptr^ := val;
    end;
    public property val[i: integer]: Byte read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec2ub; k: Byte): Vec2ub := new Vec2ub(v.val0*k, v.val1*k);
    public static function operator+(v1, v2: Vec2ub): Vec2ub := new Vec2ub(v1.val0+v2.val0, v1.val1+v2.val1);
    public static function operator-(v1, v2: Vec2ub): Vec2ub := new Vec2ub(v1.val0-v2.val0, v1.val1-v2.val1);
    
    public static function operator implicit(v: Vec1b): Vec2ub := new Vec2ub(v.val0, 0);
    public static function operator implicit(v: Vec2ub): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec2ub := new Vec2ub(v.val0, 0);
    public static function operator implicit(v: Vec2ub): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec2ub := new Vec2ub(v.val0, 0);
    public static function operator implicit(v: Vec2ub): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec2ub := new Vec2ub(v.val0, 0);
    public static function operator implicit(v: Vec2ub): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec2ub := new Vec2ub(v.val0, 0);
    public static function operator implicit(v: Vec2ub): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec2ub := new Vec2ub(v.val0, 0);
    public static function operator implicit(v: Vec2ub): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec2ub := new Vec2ub(v.val0, 0);
    public static function operator implicit(v: Vec2ub): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec2ub := new Vec2ub(v.val0, 0);
    public static function operator implicit(v: Vec2ub): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec2ub := new Vec2ub(Convert.ToByte(v.val0), 0);
    public static function operator implicit(v: Vec2ub): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec2ub := new Vec2ub(Convert.ToByte(v.val0), 0);
    public static function operator implicit(v: Vec2ub): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec2ub := new Vec2ub(v.val0, v.val1);
    public static function operator implicit(v: Vec2ub): Vec2b := new Vec2b(v.val0, v.val1);
    
    public function SqrLength := val0*val0 + val1*val1;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec2ub;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec2s = record
    public val0: Int16;
    public val1: Int16;
    
    public constructor(val0, val1: Int16);
    begin
      self.val0 := val0;
      self.val1 := val1;
    end;
    
    private function GetValAt(i: integer): Int16;
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^Int16 := pointer(new IntPtr(@self) + i*2 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Int16);
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^Int16 := pointer(new IntPtr(@self) + i*2 );
      ptr^ := val;
    end;
    public property val[i: integer]: Int16 read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec2s): Vec2s := new Vec2s(-v.val0, -v.val1);
    public static function operator*(v: Vec2s; k: Int16): Vec2s := new Vec2s(v.val0*k, v.val1*k);
    public static function operator+(v1, v2: Vec2s): Vec2s := new Vec2s(v1.val0+v2.val0, v1.val1+v2.val1);
    public static function operator-(v1, v2: Vec2s): Vec2s := new Vec2s(v1.val0-v2.val0, v1.val1-v2.val1);
    
    public static function operator implicit(v: Vec1b): Vec2s := new Vec2s(v.val0, 0);
    public static function operator implicit(v: Vec2s): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec2s := new Vec2s(v.val0, 0);
    public static function operator implicit(v: Vec2s): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec2s := new Vec2s(v.val0, 0);
    public static function operator implicit(v: Vec2s): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec2s := new Vec2s(v.val0, 0);
    public static function operator implicit(v: Vec2s): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec2s := new Vec2s(v.val0, 0);
    public static function operator implicit(v: Vec2s): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec2s := new Vec2s(v.val0, 0);
    public static function operator implicit(v: Vec2s): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec2s := new Vec2s(v.val0, 0);
    public static function operator implicit(v: Vec2s): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec2s := new Vec2s(v.val0, 0);
    public static function operator implicit(v: Vec2s): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec2s := new Vec2s(Convert.ToInt16(v.val0), 0);
    public static function operator implicit(v: Vec2s): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec2s := new Vec2s(Convert.ToInt16(v.val0), 0);
    public static function operator implicit(v: Vec2s): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec2s := new Vec2s(v.val0, v.val1);
    public static function operator implicit(v: Vec2s): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec2s := new Vec2s(v.val0, v.val1);
    public static function operator implicit(v: Vec2s): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public function SqrLength := val0*val0 + val1*val1;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec2s;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec2us = record
    public val0: UInt16;
    public val1: UInt16;
    
    public constructor(val0, val1: UInt16);
    begin
      self.val0 := val0;
      self.val1 := val1;
    end;
    
    private function GetValAt(i: integer): UInt16;
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^UInt16 := pointer(new IntPtr(@self) + i*2 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: UInt16);
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^UInt16 := pointer(new IntPtr(@self) + i*2 );
      ptr^ := val;
    end;
    public property val[i: integer]: UInt16 read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec2us; k: UInt16): Vec2us := new Vec2us(v.val0*k, v.val1*k);
    public static function operator+(v1, v2: Vec2us): Vec2us := new Vec2us(v1.val0+v2.val0, v1.val1+v2.val1);
    public static function operator-(v1, v2: Vec2us): Vec2us := new Vec2us(v1.val0-v2.val0, v1.val1-v2.val1);
    
    public static function operator implicit(v: Vec1b): Vec2us := new Vec2us(v.val0, 0);
    public static function operator implicit(v: Vec2us): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec2us := new Vec2us(v.val0, 0);
    public static function operator implicit(v: Vec2us): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec2us := new Vec2us(v.val0, 0);
    public static function operator implicit(v: Vec2us): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec2us := new Vec2us(v.val0, 0);
    public static function operator implicit(v: Vec2us): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec2us := new Vec2us(v.val0, 0);
    public static function operator implicit(v: Vec2us): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec2us := new Vec2us(v.val0, 0);
    public static function operator implicit(v: Vec2us): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec2us := new Vec2us(v.val0, 0);
    public static function operator implicit(v: Vec2us): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec2us := new Vec2us(v.val0, 0);
    public static function operator implicit(v: Vec2us): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec2us := new Vec2us(Convert.ToUInt16(v.val0), 0);
    public static function operator implicit(v: Vec2us): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec2us := new Vec2us(Convert.ToUInt16(v.val0), 0);
    public static function operator implicit(v: Vec2us): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec2us := new Vec2us(v.val0, v.val1);
    public static function operator implicit(v: Vec2us): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec2us := new Vec2us(v.val0, v.val1);
    public static function operator implicit(v: Vec2us): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec2us := new Vec2us(v.val0, v.val1);
    public static function operator implicit(v: Vec2us): Vec2s := new Vec2s(v.val0, v.val1);
    
    public function SqrLength := val0*val0 + val1*val1;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec2us;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec2i = record
    public val0: Int32;
    public val1: Int32;
    
    public constructor(val0, val1: Int32);
    begin
      self.val0 := val0;
      self.val1 := val1;
    end;
    
    private function GetValAt(i: integer): Int32;
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^Int32 := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Int32);
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^Int32 := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: Int32 read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec2i): Vec2i := new Vec2i(-v.val0, -v.val1);
    public static function operator*(v: Vec2i; k: Int32): Vec2i := new Vec2i(v.val0*k, v.val1*k);
    public static function operator+(v1, v2: Vec2i): Vec2i := new Vec2i(v1.val0+v2.val0, v1.val1+v2.val1);
    public static function operator-(v1, v2: Vec2i): Vec2i := new Vec2i(v1.val0-v2.val0, v1.val1-v2.val1);
    
    public static function operator implicit(v: Vec1b): Vec2i := new Vec2i(v.val0, 0);
    public static function operator implicit(v: Vec2i): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec2i := new Vec2i(v.val0, 0);
    public static function operator implicit(v: Vec2i): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec2i := new Vec2i(v.val0, 0);
    public static function operator implicit(v: Vec2i): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec2i := new Vec2i(v.val0, 0);
    public static function operator implicit(v: Vec2i): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec2i := new Vec2i(v.val0, 0);
    public static function operator implicit(v: Vec2i): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec2i := new Vec2i(v.val0, 0);
    public static function operator implicit(v: Vec2i): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec2i := new Vec2i(v.val0, 0);
    public static function operator implicit(v: Vec2i): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec2i := new Vec2i(v.val0, 0);
    public static function operator implicit(v: Vec2i): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec2i := new Vec2i(Convert.ToInt32(v.val0), 0);
    public static function operator implicit(v: Vec2i): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec2i := new Vec2i(Convert.ToInt32(v.val0), 0);
    public static function operator implicit(v: Vec2i): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec2i := new Vec2i(v.val0, v.val1);
    public static function operator implicit(v: Vec2i): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec2i := new Vec2i(v.val0, v.val1);
    public static function operator implicit(v: Vec2i): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec2i := new Vec2i(v.val0, v.val1);
    public static function operator implicit(v: Vec2i): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec2i := new Vec2i(v.val0, v.val1);
    public static function operator implicit(v: Vec2i): Vec2us := new Vec2us(v.val0, v.val1);
    
    public function SqrLength := val0*val0 + val1*val1;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec2i;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec2ui = record
    public val0: UInt32;
    public val1: UInt32;
    
    public constructor(val0, val1: UInt32);
    begin
      self.val0 := val0;
      self.val1 := val1;
    end;
    
    private function GetValAt(i: integer): UInt32;
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^UInt32 := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: UInt32);
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^UInt32 := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: UInt32 read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec2ui; k: UInt32): Vec2ui := new Vec2ui(v.val0*k, v.val1*k);
    public static function operator+(v1, v2: Vec2ui): Vec2ui := new Vec2ui(v1.val0+v2.val0, v1.val1+v2.val1);
    public static function operator-(v1, v2: Vec2ui): Vec2ui := new Vec2ui(v1.val0-v2.val0, v1.val1-v2.val1);
    
    public static function operator implicit(v: Vec1b): Vec2ui := new Vec2ui(v.val0, 0);
    public static function operator implicit(v: Vec2ui): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec2ui := new Vec2ui(v.val0, 0);
    public static function operator implicit(v: Vec2ui): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec2ui := new Vec2ui(v.val0, 0);
    public static function operator implicit(v: Vec2ui): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec2ui := new Vec2ui(v.val0, 0);
    public static function operator implicit(v: Vec2ui): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec2ui := new Vec2ui(v.val0, 0);
    public static function operator implicit(v: Vec2ui): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec2ui := new Vec2ui(v.val0, 0);
    public static function operator implicit(v: Vec2ui): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec2ui := new Vec2ui(v.val0, 0);
    public static function operator implicit(v: Vec2ui): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec2ui := new Vec2ui(v.val0, 0);
    public static function operator implicit(v: Vec2ui): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec2ui := new Vec2ui(Convert.ToUInt32(v.val0), 0);
    public static function operator implicit(v: Vec2ui): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec2ui := new Vec2ui(Convert.ToUInt32(v.val0), 0);
    public static function operator implicit(v: Vec2ui): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec2ui := new Vec2ui(v.val0, v.val1);
    public static function operator implicit(v: Vec2ui): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec2ui := new Vec2ui(v.val0, v.val1);
    public static function operator implicit(v: Vec2ui): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec2ui := new Vec2ui(v.val0, v.val1);
    public static function operator implicit(v: Vec2ui): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec2ui := new Vec2ui(v.val0, v.val1);
    public static function operator implicit(v: Vec2ui): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec2ui := new Vec2ui(v.val0, v.val1);
    public static function operator implicit(v: Vec2ui): Vec2i := new Vec2i(v.val0, v.val1);
    
    public function SqrLength := val0*val0 + val1*val1;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec2ui;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec2i64 = record
    public val0: Int64;
    public val1: Int64;
    
    public constructor(val0, val1: Int64);
    begin
      self.val0 := val0;
      self.val1 := val1;
    end;
    
    private function GetValAt(i: integer): Int64;
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^Int64 := pointer(new IntPtr(@self) + i*8 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Int64);
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^Int64 := pointer(new IntPtr(@self) + i*8 );
      ptr^ := val;
    end;
    public property val[i: integer]: Int64 read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec2i64): Vec2i64 := new Vec2i64(-v.val0, -v.val1);
    public static function operator*(v: Vec2i64; k: Int64): Vec2i64 := new Vec2i64(v.val0*k, v.val1*k);
    public static function operator+(v1, v2: Vec2i64): Vec2i64 := new Vec2i64(v1.val0+v2.val0, v1.val1+v2.val1);
    public static function operator-(v1, v2: Vec2i64): Vec2i64 := new Vec2i64(v1.val0-v2.val0, v1.val1-v2.val1);
    
    public static function operator implicit(v: Vec1b): Vec2i64 := new Vec2i64(v.val0, 0);
    public static function operator implicit(v: Vec2i64): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec2i64 := new Vec2i64(v.val0, 0);
    public static function operator implicit(v: Vec2i64): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec2i64 := new Vec2i64(v.val0, 0);
    public static function operator implicit(v: Vec2i64): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec2i64 := new Vec2i64(v.val0, 0);
    public static function operator implicit(v: Vec2i64): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec2i64 := new Vec2i64(v.val0, 0);
    public static function operator implicit(v: Vec2i64): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec2i64 := new Vec2i64(v.val0, 0);
    public static function operator implicit(v: Vec2i64): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec2i64 := new Vec2i64(v.val0, 0);
    public static function operator implicit(v: Vec2i64): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec2i64 := new Vec2i64(v.val0, 0);
    public static function operator implicit(v: Vec2i64): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec2i64 := new Vec2i64(Convert.ToInt64(v.val0), 0);
    public static function operator implicit(v: Vec2i64): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec2i64 := new Vec2i64(Convert.ToInt64(v.val0), 0);
    public static function operator implicit(v: Vec2i64): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec2i64 := new Vec2i64(v.val0, v.val1);
    public static function operator implicit(v: Vec2i64): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec2i64 := new Vec2i64(v.val0, v.val1);
    public static function operator implicit(v: Vec2i64): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec2i64 := new Vec2i64(v.val0, v.val1);
    public static function operator implicit(v: Vec2i64): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec2i64 := new Vec2i64(v.val0, v.val1);
    public static function operator implicit(v: Vec2i64): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec2i64 := new Vec2i64(v.val0, v.val1);
    public static function operator implicit(v: Vec2i64): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec2i64 := new Vec2i64(v.val0, v.val1);
    public static function operator implicit(v: Vec2i64): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public function SqrLength := val0*val0 + val1*val1;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec2i64;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec2ui64 = record
    public val0: UInt64;
    public val1: UInt64;
    
    public constructor(val0, val1: UInt64);
    begin
      self.val0 := val0;
      self.val1 := val1;
    end;
    
    private function GetValAt(i: integer): UInt64;
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^UInt64 := pointer(new IntPtr(@self) + i*8 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: UInt64);
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^UInt64 := pointer(new IntPtr(@self) + i*8 );
      ptr^ := val;
    end;
    public property val[i: integer]: UInt64 read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec2ui64; k: UInt64): Vec2ui64 := new Vec2ui64(v.val0*k, v.val1*k);
    public static function operator+(v1, v2: Vec2ui64): Vec2ui64 := new Vec2ui64(v1.val0+v2.val0, v1.val1+v2.val1);
    public static function operator-(v1, v2: Vec2ui64): Vec2ui64 := new Vec2ui64(v1.val0-v2.val0, v1.val1-v2.val1);
    
    public static function operator implicit(v: Vec1b): Vec2ui64 := new Vec2ui64(v.val0, 0);
    public static function operator implicit(v: Vec2ui64): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec2ui64 := new Vec2ui64(v.val0, 0);
    public static function operator implicit(v: Vec2ui64): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec2ui64 := new Vec2ui64(v.val0, 0);
    public static function operator implicit(v: Vec2ui64): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec2ui64 := new Vec2ui64(v.val0, 0);
    public static function operator implicit(v: Vec2ui64): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec2ui64 := new Vec2ui64(v.val0, 0);
    public static function operator implicit(v: Vec2ui64): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec2ui64 := new Vec2ui64(v.val0, 0);
    public static function operator implicit(v: Vec2ui64): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec2ui64 := new Vec2ui64(v.val0, 0);
    public static function operator implicit(v: Vec2ui64): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec2ui64 := new Vec2ui64(v.val0, 0);
    public static function operator implicit(v: Vec2ui64): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec2ui64 := new Vec2ui64(Convert.ToUInt64(v.val0), 0);
    public static function operator implicit(v: Vec2ui64): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec2ui64 := new Vec2ui64(Convert.ToUInt64(v.val0), 0);
    public static function operator implicit(v: Vec2ui64): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    public static function operator implicit(v: Vec2ui64): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    public static function operator implicit(v: Vec2ui64): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    public static function operator implicit(v: Vec2ui64): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    public static function operator implicit(v: Vec2ui64): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    public static function operator implicit(v: Vec2ui64): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    public static function operator implicit(v: Vec2ui64): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    public static function operator implicit(v: Vec2ui64): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public function SqrLength := val0*val0 + val1*val1;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec2ui64;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec2f = record
    public val0: single;
    public val1: single;
    
    public constructor(val0, val1: single);
    begin
      self.val0 := val0;
      self.val1 := val1;
    end;
    
    private function GetValAt(i: integer): single;
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^single := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: single);
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^single := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: single read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec2f): Vec2f := new Vec2f(-v.val0, -v.val1);
    public static function operator*(v: Vec2f; k: single): Vec2f := new Vec2f(v.val0*k, v.val1*k);
    public static function operator/(v: Vec2f; k: single): Vec2f := new Vec2f(v.val0/k, v.val1/k);
    public static function operator+(v1, v2: Vec2f): Vec2f := new Vec2f(v1.val0+v2.val0, v1.val1+v2.val1);
    public static function operator-(v1, v2: Vec2f): Vec2f := new Vec2f(v1.val0-v2.val0, v1.val1-v2.val1);
    
    public static function operator implicit(v: Vec1b): Vec2f := new Vec2f(v.val0, 0);
    public static function operator implicit(v: Vec2f): Vec1b := new Vec1b(Convert.ToSByte(v.val0));
    
    public static function operator implicit(v: Vec1ub): Vec2f := new Vec2f(v.val0, 0);
    public static function operator implicit(v: Vec2f): Vec1ub := new Vec1ub(Convert.ToByte(v.val0));
    
    public static function operator implicit(v: Vec1s): Vec2f := new Vec2f(v.val0, 0);
    public static function operator implicit(v: Vec2f): Vec1s := new Vec1s(Convert.ToInt16(v.val0));
    
    public static function operator implicit(v: Vec1us): Vec2f := new Vec2f(v.val0, 0);
    public static function operator implicit(v: Vec2f): Vec1us := new Vec1us(Convert.ToUInt16(v.val0));
    
    public static function operator implicit(v: Vec1i): Vec2f := new Vec2f(v.val0, 0);
    public static function operator implicit(v: Vec2f): Vec1i := new Vec1i(Convert.ToInt32(v.val0));
    
    public static function operator implicit(v: Vec1ui): Vec2f := new Vec2f(v.val0, 0);
    public static function operator implicit(v: Vec2f): Vec1ui := new Vec1ui(Convert.ToUInt32(v.val0));
    
    public static function operator implicit(v: Vec1i64): Vec2f := new Vec2f(v.val0, 0);
    public static function operator implicit(v: Vec2f): Vec1i64 := new Vec1i64(Convert.ToInt64(v.val0));
    
    public static function operator implicit(v: Vec1ui64): Vec2f := new Vec2f(v.val0, 0);
    public static function operator implicit(v: Vec2f): Vec1ui64 := new Vec1ui64(Convert.ToUInt64(v.val0));
    
    public static function operator implicit(v: Vec1f): Vec2f := new Vec2f(v.val0, 0);
    public static function operator implicit(v: Vec2f): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec2f := new Vec2f(v.val0, 0);
    public static function operator implicit(v: Vec2f): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec2f := new Vec2f(v.val0, v.val1);
    public static function operator implicit(v: Vec2f): Vec2b := new Vec2b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1));
    
    public static function operator implicit(v: Vec2ub): Vec2f := new Vec2f(v.val0, v.val1);
    public static function operator implicit(v: Vec2f): Vec2ub := new Vec2ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1));
    
    public static function operator implicit(v: Vec2s): Vec2f := new Vec2f(v.val0, v.val1);
    public static function operator implicit(v: Vec2f): Vec2s := new Vec2s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1));
    
    public static function operator implicit(v: Vec2us): Vec2f := new Vec2f(v.val0, v.val1);
    public static function operator implicit(v: Vec2f): Vec2us := new Vec2us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1));
    
    public static function operator implicit(v: Vec2i): Vec2f := new Vec2f(v.val0, v.val1);
    public static function operator implicit(v: Vec2f): Vec2i := new Vec2i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1));
    
    public static function operator implicit(v: Vec2ui): Vec2f := new Vec2f(v.val0, v.val1);
    public static function operator implicit(v: Vec2f): Vec2ui := new Vec2ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1));
    
    public static function operator implicit(v: Vec2i64): Vec2f := new Vec2f(v.val0, v.val1);
    public static function operator implicit(v: Vec2f): Vec2i64 := new Vec2i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1));
    
    public static function operator implicit(v: Vec2ui64): Vec2f := new Vec2f(v.val0, v.val1);
    public static function operator implicit(v: Vec2f): Vec2ui64 := new Vec2ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1));
    
    public function SqrLength := val0*val0 + val1*val1;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1;
    
    public function Normalized := self / single(Sqrt(self.SqrLength_d));
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec2f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec2d = record
    public val0: double;
    public val1: double;
    
    public constructor(val0, val1: double);
    begin
      self.val0 := val0;
      self.val1 := val1;
    end;
    
    private function GetValAt(i: integer): double;
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^double := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: double);
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^double := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: double read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec2d): Vec2d := new Vec2d(-v.val0, -v.val1);
    public static function operator*(v: Vec2d; k: double): Vec2d := new Vec2d(v.val0*k, v.val1*k);
    public static function operator/(v: Vec2d; k: double): Vec2d := new Vec2d(v.val0/k, v.val1/k);
    public static function operator+(v1, v2: Vec2d): Vec2d := new Vec2d(v1.val0+v2.val0, v1.val1+v2.val1);
    public static function operator-(v1, v2: Vec2d): Vec2d := new Vec2d(v1.val0-v2.val0, v1.val1-v2.val1);
    
    public static function operator implicit(v: Vec1b): Vec2d := new Vec2d(v.val0, 0);
    public static function operator implicit(v: Vec2d): Vec1b := new Vec1b(Convert.ToSByte(v.val0));
    
    public static function operator implicit(v: Vec1ub): Vec2d := new Vec2d(v.val0, 0);
    public static function operator implicit(v: Vec2d): Vec1ub := new Vec1ub(Convert.ToByte(v.val0));
    
    public static function operator implicit(v: Vec1s): Vec2d := new Vec2d(v.val0, 0);
    public static function operator implicit(v: Vec2d): Vec1s := new Vec1s(Convert.ToInt16(v.val0));
    
    public static function operator implicit(v: Vec1us): Vec2d := new Vec2d(v.val0, 0);
    public static function operator implicit(v: Vec2d): Vec1us := new Vec1us(Convert.ToUInt16(v.val0));
    
    public static function operator implicit(v: Vec1i): Vec2d := new Vec2d(v.val0, 0);
    public static function operator implicit(v: Vec2d): Vec1i := new Vec1i(Convert.ToInt32(v.val0));
    
    public static function operator implicit(v: Vec1ui): Vec2d := new Vec2d(v.val0, 0);
    public static function operator implicit(v: Vec2d): Vec1ui := new Vec1ui(Convert.ToUInt32(v.val0));
    
    public static function operator implicit(v: Vec1i64): Vec2d := new Vec2d(v.val0, 0);
    public static function operator implicit(v: Vec2d): Vec1i64 := new Vec1i64(Convert.ToInt64(v.val0));
    
    public static function operator implicit(v: Vec1ui64): Vec2d := new Vec2d(v.val0, 0);
    public static function operator implicit(v: Vec2d): Vec1ui64 := new Vec1ui64(Convert.ToUInt64(v.val0));
    
    public static function operator implicit(v: Vec1f): Vec2d := new Vec2d(v.val0, 0);
    public static function operator implicit(v: Vec2d): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec2d := new Vec2d(v.val0, 0);
    public static function operator implicit(v: Vec2d): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec2d := new Vec2d(v.val0, v.val1);
    public static function operator implicit(v: Vec2d): Vec2b := new Vec2b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1));
    
    public static function operator implicit(v: Vec2ub): Vec2d := new Vec2d(v.val0, v.val1);
    public static function operator implicit(v: Vec2d): Vec2ub := new Vec2ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1));
    
    public static function operator implicit(v: Vec2s): Vec2d := new Vec2d(v.val0, v.val1);
    public static function operator implicit(v: Vec2d): Vec2s := new Vec2s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1));
    
    public static function operator implicit(v: Vec2us): Vec2d := new Vec2d(v.val0, v.val1);
    public static function operator implicit(v: Vec2d): Vec2us := new Vec2us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1));
    
    public static function operator implicit(v: Vec2i): Vec2d := new Vec2d(v.val0, v.val1);
    public static function operator implicit(v: Vec2d): Vec2i := new Vec2i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1));
    
    public static function operator implicit(v: Vec2ui): Vec2d := new Vec2d(v.val0, v.val1);
    public static function operator implicit(v: Vec2d): Vec2ui := new Vec2ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1));
    
    public static function operator implicit(v: Vec2i64): Vec2d := new Vec2d(v.val0, v.val1);
    public static function operator implicit(v: Vec2d): Vec2i64 := new Vec2i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1));
    
    public static function operator implicit(v: Vec2ui64): Vec2d := new Vec2d(v.val0, v.val1);
    public static function operator implicit(v: Vec2d): Vec2ui64 := new Vec2ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1));
    
    public static function operator implicit(v: Vec2f): Vec2d := new Vec2d(v.val0, v.val1);
    public static function operator implicit(v: Vec2d): Vec2f := new Vec2f(v.val0, v.val1);
    
    public function SqrLength := val0*val0 + val1*val1;
    
    public function Normalized := self / Sqrt(self.SqrLength);
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec2d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  {$endregion Vec2}
  
  {$region Vec3}
  
  Vec3b = record
    public val0: SByte;
    public val1: SByte;
    public val2: SByte;
    
    public constructor(val0, val1, val2: SByte);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
    end;
    
    private function GetValAt(i: integer): SByte;
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^SByte := pointer(new IntPtr(@self) + i*1 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: SByte);
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^SByte := pointer(new IntPtr(@self) + i*1 );
      ptr^ := val;
    end;
    public property val[i: integer]: SByte read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec3b): Vec3b := new Vec3b(-v.val0, -v.val1, -v.val2);
    public static function operator*(v: Vec3b; k: SByte): Vec3b := new Vec3b(v.val0*k, v.val1*k, v.val2*k);
    public static function operator+(v1, v2: Vec3b): Vec3b := new Vec3b(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2);
    public static function operator-(v1, v2: Vec3b): Vec3b := new Vec3b(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2);
    
    public static function operator implicit(v: Vec1b): Vec3b := new Vec3b(v.val0, 0, 0);
    public static function operator implicit(v: Vec3b): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec3b := new Vec3b(v.val0, 0, 0);
    public static function operator implicit(v: Vec3b): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec3b := new Vec3b(v.val0, 0, 0);
    public static function operator implicit(v: Vec3b): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec3b := new Vec3b(v.val0, 0, 0);
    public static function operator implicit(v: Vec3b): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec3b := new Vec3b(v.val0, 0, 0);
    public static function operator implicit(v: Vec3b): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec3b := new Vec3b(v.val0, 0, 0);
    public static function operator implicit(v: Vec3b): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec3b := new Vec3b(v.val0, 0, 0);
    public static function operator implicit(v: Vec3b): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec3b := new Vec3b(v.val0, 0, 0);
    public static function operator implicit(v: Vec3b): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec3b := new Vec3b(Convert.ToSByte(v.val0), 0, 0);
    public static function operator implicit(v: Vec3b): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec3b := new Vec3b(Convert.ToSByte(v.val0), 0, 0);
    public static function operator implicit(v: Vec3b): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec3b := new Vec3b(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3b): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec3b := new Vec3b(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3b): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec3b := new Vec3b(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3b): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec3b := new Vec3b(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3b): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec3b := new Vec3b(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3b): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec3b := new Vec3b(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3b): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec3b := new Vec3b(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3b): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec3b := new Vec3b(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3b): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec3b := new Vec3b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1), 0);
    public static function operator implicit(v: Vec3b): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec3b := new Vec3b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1), 0);
    public static function operator implicit(v: Vec3b): Vec2d := new Vec2d(v.val0, v.val1);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec3b;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec3ub = record
    public val0: Byte;
    public val1: Byte;
    public val2: Byte;
    
    public constructor(val0, val1, val2: Byte);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
    end;
    
    private function GetValAt(i: integer): Byte;
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^Byte := pointer(new IntPtr(@self) + i*1 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Byte);
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^Byte := pointer(new IntPtr(@self) + i*1 );
      ptr^ := val;
    end;
    public property val[i: integer]: Byte read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec3ub; k: Byte): Vec3ub := new Vec3ub(v.val0*k, v.val1*k, v.val2*k);
    public static function operator+(v1, v2: Vec3ub): Vec3ub := new Vec3ub(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2);
    public static function operator-(v1, v2: Vec3ub): Vec3ub := new Vec3ub(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2);
    
    public static function operator implicit(v: Vec1b): Vec3ub := new Vec3ub(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ub): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec3ub := new Vec3ub(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ub): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec3ub := new Vec3ub(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ub): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec3ub := new Vec3ub(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ub): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec3ub := new Vec3ub(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ub): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec3ub := new Vec3ub(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ub): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec3ub := new Vec3ub(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ub): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec3ub := new Vec3ub(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ub): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec3ub := new Vec3ub(Convert.ToByte(v.val0), 0, 0);
    public static function operator implicit(v: Vec3ub): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec3ub := new Vec3ub(Convert.ToByte(v.val0), 0, 0);
    public static function operator implicit(v: Vec3ub): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec3ub := new Vec3ub(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ub): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec3ub := new Vec3ub(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ub): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec3ub := new Vec3ub(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ub): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec3ub := new Vec3ub(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ub): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec3ub := new Vec3ub(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ub): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec3ub := new Vec3ub(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ub): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec3ub := new Vec3ub(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ub): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec3ub := new Vec3ub(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ub): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec3ub := new Vec3ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1), 0);
    public static function operator implicit(v: Vec3ub): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec3ub := new Vec3ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1), 0);
    public static function operator implicit(v: Vec3ub): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3ub): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec3ub;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec3s = record
    public val0: Int16;
    public val1: Int16;
    public val2: Int16;
    
    public constructor(val0, val1, val2: Int16);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
    end;
    
    private function GetValAt(i: integer): Int16;
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^Int16 := pointer(new IntPtr(@self) + i*2 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Int16);
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^Int16 := pointer(new IntPtr(@self) + i*2 );
      ptr^ := val;
    end;
    public property val[i: integer]: Int16 read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec3s): Vec3s := new Vec3s(-v.val0, -v.val1, -v.val2);
    public static function operator*(v: Vec3s; k: Int16): Vec3s := new Vec3s(v.val0*k, v.val1*k, v.val2*k);
    public static function operator+(v1, v2: Vec3s): Vec3s := new Vec3s(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2);
    public static function operator-(v1, v2: Vec3s): Vec3s := new Vec3s(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2);
    
    public static function operator implicit(v: Vec1b): Vec3s := new Vec3s(v.val0, 0, 0);
    public static function operator implicit(v: Vec3s): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec3s := new Vec3s(v.val0, 0, 0);
    public static function operator implicit(v: Vec3s): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec3s := new Vec3s(v.val0, 0, 0);
    public static function operator implicit(v: Vec3s): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec3s := new Vec3s(v.val0, 0, 0);
    public static function operator implicit(v: Vec3s): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec3s := new Vec3s(v.val0, 0, 0);
    public static function operator implicit(v: Vec3s): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec3s := new Vec3s(v.val0, 0, 0);
    public static function operator implicit(v: Vec3s): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec3s := new Vec3s(v.val0, 0, 0);
    public static function operator implicit(v: Vec3s): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec3s := new Vec3s(v.val0, 0, 0);
    public static function operator implicit(v: Vec3s): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec3s := new Vec3s(Convert.ToInt16(v.val0), 0, 0);
    public static function operator implicit(v: Vec3s): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec3s := new Vec3s(Convert.ToInt16(v.val0), 0, 0);
    public static function operator implicit(v: Vec3s): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec3s := new Vec3s(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3s): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec3s := new Vec3s(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3s): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec3s := new Vec3s(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3s): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec3s := new Vec3s(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3s): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec3s := new Vec3s(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3s): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec3s := new Vec3s(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3s): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec3s := new Vec3s(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3s): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec3s := new Vec3s(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3s): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec3s := new Vec3s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1), 0);
    public static function operator implicit(v: Vec3s): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec3s := new Vec3s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1), 0);
    public static function operator implicit(v: Vec3s): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3s): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ub): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3s): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec3s;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec3us = record
    public val0: UInt16;
    public val1: UInt16;
    public val2: UInt16;
    
    public constructor(val0, val1, val2: UInt16);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
    end;
    
    private function GetValAt(i: integer): UInt16;
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^UInt16 := pointer(new IntPtr(@self) + i*2 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: UInt16);
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^UInt16 := pointer(new IntPtr(@self) + i*2 );
      ptr^ := val;
    end;
    public property val[i: integer]: UInt16 read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec3us; k: UInt16): Vec3us := new Vec3us(v.val0*k, v.val1*k, v.val2*k);
    public static function operator+(v1, v2: Vec3us): Vec3us := new Vec3us(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2);
    public static function operator-(v1, v2: Vec3us): Vec3us := new Vec3us(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2);
    
    public static function operator implicit(v: Vec1b): Vec3us := new Vec3us(v.val0, 0, 0);
    public static function operator implicit(v: Vec3us): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec3us := new Vec3us(v.val0, 0, 0);
    public static function operator implicit(v: Vec3us): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec3us := new Vec3us(v.val0, 0, 0);
    public static function operator implicit(v: Vec3us): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec3us := new Vec3us(v.val0, 0, 0);
    public static function operator implicit(v: Vec3us): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec3us := new Vec3us(v.val0, 0, 0);
    public static function operator implicit(v: Vec3us): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec3us := new Vec3us(v.val0, 0, 0);
    public static function operator implicit(v: Vec3us): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec3us := new Vec3us(v.val0, 0, 0);
    public static function operator implicit(v: Vec3us): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec3us := new Vec3us(v.val0, 0, 0);
    public static function operator implicit(v: Vec3us): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec3us := new Vec3us(Convert.ToUInt16(v.val0), 0, 0);
    public static function operator implicit(v: Vec3us): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec3us := new Vec3us(Convert.ToUInt16(v.val0), 0, 0);
    public static function operator implicit(v: Vec3us): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec3us := new Vec3us(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3us): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec3us := new Vec3us(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3us): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec3us := new Vec3us(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3us): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec3us := new Vec3us(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3us): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec3us := new Vec3us(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3us): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec3us := new Vec3us(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3us): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec3us := new Vec3us(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3us): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec3us := new Vec3us(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3us): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec3us := new Vec3us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1), 0);
    public static function operator implicit(v: Vec3us): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec3us := new Vec3us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1), 0);
    public static function operator implicit(v: Vec3us): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3us): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ub): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3us): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3s): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3us): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec3us;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec3i = record
    public val0: Int32;
    public val1: Int32;
    public val2: Int32;
    
    public constructor(val0, val1, val2: Int32);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
    end;
    
    private function GetValAt(i: integer): Int32;
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^Int32 := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Int32);
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^Int32 := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: Int32 read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec3i): Vec3i := new Vec3i(-v.val0, -v.val1, -v.val2);
    public static function operator*(v: Vec3i; k: Int32): Vec3i := new Vec3i(v.val0*k, v.val1*k, v.val2*k);
    public static function operator+(v1, v2: Vec3i): Vec3i := new Vec3i(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2);
    public static function operator-(v1, v2: Vec3i): Vec3i := new Vec3i(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2);
    
    public static function operator implicit(v: Vec1b): Vec3i := new Vec3i(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec3i := new Vec3i(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec3i := new Vec3i(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec3i := new Vec3i(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec3i := new Vec3i(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec3i := new Vec3i(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec3i := new Vec3i(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec3i := new Vec3i(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec3i := new Vec3i(Convert.ToInt32(v.val0), 0, 0);
    public static function operator implicit(v: Vec3i): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec3i := new Vec3i(Convert.ToInt32(v.val0), 0, 0);
    public static function operator implicit(v: Vec3i): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec3i := new Vec3i(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec3i := new Vec3i(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec3i := new Vec3i(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec3i := new Vec3i(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec3i := new Vec3i(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec3i := new Vec3i(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec3i := new Vec3i(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec3i := new Vec3i(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec3i := new Vec3i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1), 0);
    public static function operator implicit(v: Vec3i): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec3i := new Vec3i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1), 0);
    public static function operator implicit(v: Vec3i): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3i): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ub): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3i): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3s): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3i): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3us): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3i): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec3i;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec3ui = record
    public val0: UInt32;
    public val1: UInt32;
    public val2: UInt32;
    
    public constructor(val0, val1, val2: UInt32);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
    end;
    
    private function GetValAt(i: integer): UInt32;
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^UInt32 := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: UInt32);
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^UInt32 := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: UInt32 read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec3ui; k: UInt32): Vec3ui := new Vec3ui(v.val0*k, v.val1*k, v.val2*k);
    public static function operator+(v1, v2: Vec3ui): Vec3ui := new Vec3ui(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2);
    public static function operator-(v1, v2: Vec3ui): Vec3ui := new Vec3ui(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2);
    
    public static function operator implicit(v: Vec1b): Vec3ui := new Vec3ui(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec3ui := new Vec3ui(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec3ui := new Vec3ui(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec3ui := new Vec3ui(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec3ui := new Vec3ui(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec3ui := new Vec3ui(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec3ui := new Vec3ui(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec3ui := new Vec3ui(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec3ui := new Vec3ui(Convert.ToUInt32(v.val0), 0, 0);
    public static function operator implicit(v: Vec3ui): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec3ui := new Vec3ui(Convert.ToUInt32(v.val0), 0, 0);
    public static function operator implicit(v: Vec3ui): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec3ui := new Vec3ui(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec3ui := new Vec3ui(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec3ui := new Vec3ui(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec3ui := new Vec3ui(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec3ui := new Vec3ui(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec3ui := new Vec3ui(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec3ui := new Vec3ui(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec3ui := new Vec3ui(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec3ui := new Vec3ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1), 0);
    public static function operator implicit(v: Vec3ui): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec3ui := new Vec3ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1), 0);
    public static function operator implicit(v: Vec3ui): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3ui): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ub): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3ui): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3s): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3ui): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3us): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3ui): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3ui): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec3ui;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec3i64 = record
    public val0: Int64;
    public val1: Int64;
    public val2: Int64;
    
    public constructor(val0, val1, val2: Int64);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
    end;
    
    private function GetValAt(i: integer): Int64;
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^Int64 := pointer(new IntPtr(@self) + i*8 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Int64);
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^Int64 := pointer(new IntPtr(@self) + i*8 );
      ptr^ := val;
    end;
    public property val[i: integer]: Int64 read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec3i64): Vec3i64 := new Vec3i64(-v.val0, -v.val1, -v.val2);
    public static function operator*(v: Vec3i64; k: Int64): Vec3i64 := new Vec3i64(v.val0*k, v.val1*k, v.val2*k);
    public static function operator+(v1, v2: Vec3i64): Vec3i64 := new Vec3i64(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2);
    public static function operator-(v1, v2: Vec3i64): Vec3i64 := new Vec3i64(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2);
    
    public static function operator implicit(v: Vec1b): Vec3i64 := new Vec3i64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i64): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec3i64 := new Vec3i64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i64): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec3i64 := new Vec3i64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i64): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec3i64 := new Vec3i64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i64): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec3i64 := new Vec3i64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i64): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec3i64 := new Vec3i64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i64): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec3i64 := new Vec3i64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i64): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec3i64 := new Vec3i64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i64): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec3i64 := new Vec3i64(Convert.ToInt64(v.val0), 0, 0);
    public static function operator implicit(v: Vec3i64): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec3i64 := new Vec3i64(Convert.ToInt64(v.val0), 0, 0);
    public static function operator implicit(v: Vec3i64): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec3i64 := new Vec3i64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i64): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec3i64 := new Vec3i64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i64): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec3i64 := new Vec3i64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i64): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec3i64 := new Vec3i64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i64): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec3i64 := new Vec3i64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i64): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec3i64 := new Vec3i64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i64): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec3i64 := new Vec3i64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i64): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec3i64 := new Vec3i64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i64): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec3i64 := new Vec3i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1), 0);
    public static function operator implicit(v: Vec3i64): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec3i64 := new Vec3i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1), 0);
    public static function operator implicit(v: Vec3i64): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3i64): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ub): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3i64): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3s): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3i64): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3us): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3i64): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3i64): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3i64): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec3i64;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec3ui64 = record
    public val0: UInt64;
    public val1: UInt64;
    public val2: UInt64;
    
    public constructor(val0, val1, val2: UInt64);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
    end;
    
    private function GetValAt(i: integer): UInt64;
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^UInt64 := pointer(new IntPtr(@self) + i*8 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: UInt64);
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^UInt64 := pointer(new IntPtr(@self) + i*8 );
      ptr^ := val;
    end;
    public property val[i: integer]: UInt64 read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec3ui64; k: UInt64): Vec3ui64 := new Vec3ui64(v.val0*k, v.val1*k, v.val2*k);
    public static function operator+(v1, v2: Vec3ui64): Vec3ui64 := new Vec3ui64(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2);
    public static function operator-(v1, v2: Vec3ui64): Vec3ui64 := new Vec3ui64(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2);
    
    public static function operator implicit(v: Vec1b): Vec3ui64 := new Vec3ui64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui64): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec3ui64 := new Vec3ui64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui64): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec3ui64 := new Vec3ui64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui64): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec3ui64 := new Vec3ui64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui64): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec3ui64 := new Vec3ui64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui64): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec3ui64 := new Vec3ui64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui64): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec3ui64 := new Vec3ui64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui64): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec3ui64 := new Vec3ui64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui64): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec3ui64 := new Vec3ui64(Convert.ToUInt64(v.val0), 0, 0);
    public static function operator implicit(v: Vec3ui64): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec3ui64 := new Vec3ui64(Convert.ToUInt64(v.val0), 0, 0);
    public static function operator implicit(v: Vec3ui64): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec3ui64 := new Vec3ui64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui64): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec3ui64 := new Vec3ui64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui64): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec3ui64 := new Vec3ui64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui64): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec3ui64 := new Vec3ui64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui64): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec3ui64 := new Vec3ui64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui64): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec3ui64 := new Vec3ui64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui64): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec3ui64 := new Vec3ui64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui64): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec3ui64 := new Vec3ui64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui64): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec3ui64 := new Vec3ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1), 0);
    public static function operator implicit(v: Vec3ui64): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec3ui64 := new Vec3ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1), 0);
    public static function operator implicit(v: Vec3ui64): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3ui64): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ub): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3ui64): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3s): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3ui64): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3us): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3ui64): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3ui64): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3ui64): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i64): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3ui64): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec3ui64;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec3f = record
    public val0: single;
    public val1: single;
    public val2: single;
    
    public constructor(val0, val1, val2: single);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
    end;
    
    private function GetValAt(i: integer): single;
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^single := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: single);
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^single := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: single read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec3f): Vec3f := new Vec3f(-v.val0, -v.val1, -v.val2);
    public static function operator*(v: Vec3f; k: single): Vec3f := new Vec3f(v.val0*k, v.val1*k, v.val2*k);
    public static function operator/(v: Vec3f; k: single): Vec3f := new Vec3f(v.val0/k, v.val1/k, v.val2/k);
    public static function operator+(v1, v2: Vec3f): Vec3f := new Vec3f(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2);
    public static function operator-(v1, v2: Vec3f): Vec3f := new Vec3f(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2);
    
    public static function operator implicit(v: Vec1b): Vec3f := new Vec3f(v.val0, 0, 0);
    public static function operator implicit(v: Vec3f): Vec1b := new Vec1b(Convert.ToSByte(v.val0));
    
    public static function operator implicit(v: Vec1ub): Vec3f := new Vec3f(v.val0, 0, 0);
    public static function operator implicit(v: Vec3f): Vec1ub := new Vec1ub(Convert.ToByte(v.val0));
    
    public static function operator implicit(v: Vec1s): Vec3f := new Vec3f(v.val0, 0, 0);
    public static function operator implicit(v: Vec3f): Vec1s := new Vec1s(Convert.ToInt16(v.val0));
    
    public static function operator implicit(v: Vec1us): Vec3f := new Vec3f(v.val0, 0, 0);
    public static function operator implicit(v: Vec3f): Vec1us := new Vec1us(Convert.ToUInt16(v.val0));
    
    public static function operator implicit(v: Vec1i): Vec3f := new Vec3f(v.val0, 0, 0);
    public static function operator implicit(v: Vec3f): Vec1i := new Vec1i(Convert.ToInt32(v.val0));
    
    public static function operator implicit(v: Vec1ui): Vec3f := new Vec3f(v.val0, 0, 0);
    public static function operator implicit(v: Vec3f): Vec1ui := new Vec1ui(Convert.ToUInt32(v.val0));
    
    public static function operator implicit(v: Vec1i64): Vec3f := new Vec3f(v.val0, 0, 0);
    public static function operator implicit(v: Vec3f): Vec1i64 := new Vec1i64(Convert.ToInt64(v.val0));
    
    public static function operator implicit(v: Vec1ui64): Vec3f := new Vec3f(v.val0, 0, 0);
    public static function operator implicit(v: Vec3f): Vec1ui64 := new Vec1ui64(Convert.ToUInt64(v.val0));
    
    public static function operator implicit(v: Vec1f): Vec3f := new Vec3f(v.val0, 0, 0);
    public static function operator implicit(v: Vec3f): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec3f := new Vec3f(v.val0, 0, 0);
    public static function operator implicit(v: Vec3f): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec3f := new Vec3f(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3f): Vec2b := new Vec2b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1));
    
    public static function operator implicit(v: Vec2ub): Vec3f := new Vec3f(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3f): Vec2ub := new Vec2ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1));
    
    public static function operator implicit(v: Vec2s): Vec3f := new Vec3f(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3f): Vec2s := new Vec2s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1));
    
    public static function operator implicit(v: Vec2us): Vec3f := new Vec3f(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3f): Vec2us := new Vec2us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1));
    
    public static function operator implicit(v: Vec2i): Vec3f := new Vec3f(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3f): Vec2i := new Vec2i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1));
    
    public static function operator implicit(v: Vec2ui): Vec3f := new Vec3f(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3f): Vec2ui := new Vec2ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1));
    
    public static function operator implicit(v: Vec2i64): Vec3f := new Vec3f(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3f): Vec2i64 := new Vec2i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1));
    
    public static function operator implicit(v: Vec2ui64): Vec3f := new Vec3f(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3f): Vec2ui64 := new Vec2ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1));
    
    public static function operator implicit(v: Vec2f): Vec3f := new Vec3f(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3f): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec3f := new Vec3f(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3f): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3f): Vec3b := new Vec3b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1), Convert.ToSByte(v.val2));
    
    public static function operator implicit(v: Vec3ub): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3f): Vec3ub := new Vec3ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1), Convert.ToByte(v.val2));
    
    public static function operator implicit(v: Vec3s): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3f): Vec3s := new Vec3s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1), Convert.ToInt16(v.val2));
    
    public static function operator implicit(v: Vec3us): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3f): Vec3us := new Vec3us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1), Convert.ToUInt16(v.val2));
    
    public static function operator implicit(v: Vec3i): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3f): Vec3i := new Vec3i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1), Convert.ToInt32(v.val2));
    
    public static function operator implicit(v: Vec3ui): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3f): Vec3ui := new Vec3ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1), Convert.ToUInt32(v.val2));
    
    public static function operator implicit(v: Vec3i64): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3f): Vec3i64 := new Vec3i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1), Convert.ToInt64(v.val2));
    
    public static function operator implicit(v: Vec3ui64): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3f): Vec3ui64 := new Vec3ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1), Convert.ToUInt64(v.val2));
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2;
    
    public function Normalized := self / single(Sqrt(self.SqrLength_d));
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec3f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec3d = record
    public val0: double;
    public val1: double;
    public val2: double;
    
    public constructor(val0, val1, val2: double);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
    end;
    
    private function GetValAt(i: integer): double;
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^double := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: double);
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^double := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: double read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec3d): Vec3d := new Vec3d(-v.val0, -v.val1, -v.val2);
    public static function operator*(v: Vec3d; k: double): Vec3d := new Vec3d(v.val0*k, v.val1*k, v.val2*k);
    public static function operator/(v: Vec3d; k: double): Vec3d := new Vec3d(v.val0/k, v.val1/k, v.val2/k);
    public static function operator+(v1, v2: Vec3d): Vec3d := new Vec3d(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2);
    public static function operator-(v1, v2: Vec3d): Vec3d := new Vec3d(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2);
    
    public static function operator implicit(v: Vec1b): Vec3d := new Vec3d(v.val0, 0, 0);
    public static function operator implicit(v: Vec3d): Vec1b := new Vec1b(Convert.ToSByte(v.val0));
    
    public static function operator implicit(v: Vec1ub): Vec3d := new Vec3d(v.val0, 0, 0);
    public static function operator implicit(v: Vec3d): Vec1ub := new Vec1ub(Convert.ToByte(v.val0));
    
    public static function operator implicit(v: Vec1s): Vec3d := new Vec3d(v.val0, 0, 0);
    public static function operator implicit(v: Vec3d): Vec1s := new Vec1s(Convert.ToInt16(v.val0));
    
    public static function operator implicit(v: Vec1us): Vec3d := new Vec3d(v.val0, 0, 0);
    public static function operator implicit(v: Vec3d): Vec1us := new Vec1us(Convert.ToUInt16(v.val0));
    
    public static function operator implicit(v: Vec1i): Vec3d := new Vec3d(v.val0, 0, 0);
    public static function operator implicit(v: Vec3d): Vec1i := new Vec1i(Convert.ToInt32(v.val0));
    
    public static function operator implicit(v: Vec1ui): Vec3d := new Vec3d(v.val0, 0, 0);
    public static function operator implicit(v: Vec3d): Vec1ui := new Vec1ui(Convert.ToUInt32(v.val0));
    
    public static function operator implicit(v: Vec1i64): Vec3d := new Vec3d(v.val0, 0, 0);
    public static function operator implicit(v: Vec3d): Vec1i64 := new Vec1i64(Convert.ToInt64(v.val0));
    
    public static function operator implicit(v: Vec1ui64): Vec3d := new Vec3d(v.val0, 0, 0);
    public static function operator implicit(v: Vec3d): Vec1ui64 := new Vec1ui64(Convert.ToUInt64(v.val0));
    
    public static function operator implicit(v: Vec1f): Vec3d := new Vec3d(v.val0, 0, 0);
    public static function operator implicit(v: Vec3d): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec3d := new Vec3d(v.val0, 0, 0);
    public static function operator implicit(v: Vec3d): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec3d := new Vec3d(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3d): Vec2b := new Vec2b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1));
    
    public static function operator implicit(v: Vec2ub): Vec3d := new Vec3d(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3d): Vec2ub := new Vec2ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1));
    
    public static function operator implicit(v: Vec2s): Vec3d := new Vec3d(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3d): Vec2s := new Vec2s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1));
    
    public static function operator implicit(v: Vec2us): Vec3d := new Vec3d(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3d): Vec2us := new Vec2us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1));
    
    public static function operator implicit(v: Vec2i): Vec3d := new Vec3d(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3d): Vec2i := new Vec2i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1));
    
    public static function operator implicit(v: Vec2ui): Vec3d := new Vec3d(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3d): Vec2ui := new Vec2ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1));
    
    public static function operator implicit(v: Vec2i64): Vec3d := new Vec3d(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3d): Vec2i64 := new Vec2i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1));
    
    public static function operator implicit(v: Vec2ui64): Vec3d := new Vec3d(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3d): Vec2ui64 := new Vec2ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1));
    
    public static function operator implicit(v: Vec2f): Vec3d := new Vec3d(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3d): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec3d := new Vec3d(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3d): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3d): Vec3b := new Vec3b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1), Convert.ToSByte(v.val2));
    
    public static function operator implicit(v: Vec3ub): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3d): Vec3ub := new Vec3ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1), Convert.ToByte(v.val2));
    
    public static function operator implicit(v: Vec3s): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3d): Vec3s := new Vec3s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1), Convert.ToInt16(v.val2));
    
    public static function operator implicit(v: Vec3us): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3d): Vec3us := new Vec3us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1), Convert.ToUInt16(v.val2));
    
    public static function operator implicit(v: Vec3i): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3d): Vec3i := new Vec3i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1), Convert.ToInt32(v.val2));
    
    public static function operator implicit(v: Vec3ui): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3d): Vec3ui := new Vec3ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1), Convert.ToUInt32(v.val2));
    
    public static function operator implicit(v: Vec3i64): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3d): Vec3i64 := new Vec3i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1), Convert.ToInt64(v.val2));
    
    public static function operator implicit(v: Vec3ui64): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3d): Vec3ui64 := new Vec3ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1), Convert.ToUInt64(v.val2));
    
    public static function operator implicit(v: Vec3f): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3d): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2;
    
    public function Normalized := self / Sqrt(self.SqrLength);
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec3d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  {$endregion Vec3}
  
  {$region Vec4}
  
  Vec4b = record
    public val0: SByte;
    public val1: SByte;
    public val2: SByte;
    public val3: SByte;
    
    public constructor(val0, val1, val2, val3: SByte);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
      self.val3 := val3;
    end;
    
    private function GetValAt(i: integer): SByte;
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^SByte := pointer(new IntPtr(@self) + i*1 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: SByte);
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^SByte := pointer(new IntPtr(@self) + i*1 );
      ptr^ := val;
    end;
    public property val[i: integer]: SByte read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec4b): Vec4b := new Vec4b(-v.val0, -v.val1, -v.val2, -v.val3);
    public static function operator*(v: Vec4b; k: SByte): Vec4b := new Vec4b(v.val0*k, v.val1*k, v.val2*k, v.val3*k);
    public static function operator+(v1, v2: Vec4b): Vec4b := new Vec4b(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2, v1.val3+v2.val3);
    public static function operator-(v1, v2: Vec4b): Vec4b := new Vec4b(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2, v1.val3-v2.val3);
    
    public static function operator implicit(v: Vec1b): Vec4b := new Vec4b(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4b): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec4b := new Vec4b(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4b): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec4b := new Vec4b(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4b): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec4b := new Vec4b(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4b): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec4b := new Vec4b(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4b): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec4b := new Vec4b(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4b): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec4b := new Vec4b(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4b): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec4b := new Vec4b(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4b): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec4b := new Vec4b(Convert.ToSByte(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4b): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec4b := new Vec4b(Convert.ToSByte(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4b): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec4b := new Vec4b(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4b): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec4b := new Vec4b(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4b): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec4b := new Vec4b(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4b): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec4b := new Vec4b(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4b): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec4b := new Vec4b(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4b): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec4b := new Vec4b(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4b): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec4b := new Vec4b(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4b): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec4b := new Vec4b(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4b): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec4b := new Vec4b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1), 0, 0);
    public static function operator implicit(v: Vec4b): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec4b := new Vec4b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1), 0, 0);
    public static function operator implicit(v: Vec4b): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec4b := new Vec4b(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4b): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ub): Vec4b := new Vec4b(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4b): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3s): Vec4b := new Vec4b(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4b): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3us): Vec4b := new Vec4b(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4b): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i): Vec4b := new Vec4b(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4b): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui): Vec4b := new Vec4b(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4b): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i64): Vec4b := new Vec4b(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4b): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui64): Vec4b := new Vec4b(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4b): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3f): Vec4b := new Vec4b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1), Convert.ToSByte(v.val2), 0);
    public static function operator implicit(v: Vec4b): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3d): Vec4b := new Vec4b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1), Convert.ToSByte(v.val2), 0);
    public static function operator implicit(v: Vec4b): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2 + val3*val3;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2 + real(val3)*val3;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ', ';
      res += val3.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec4b;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec4ub = record
    public val0: Byte;
    public val1: Byte;
    public val2: Byte;
    public val3: Byte;
    
    public constructor(val0, val1, val2, val3: Byte);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
      self.val3 := val3;
    end;
    
    private function GetValAt(i: integer): Byte;
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^Byte := pointer(new IntPtr(@self) + i*1 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Byte);
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^Byte := pointer(new IntPtr(@self) + i*1 );
      ptr^ := val;
    end;
    public property val[i: integer]: Byte read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec4ub; k: Byte): Vec4ub := new Vec4ub(v.val0*k, v.val1*k, v.val2*k, v.val3*k);
    public static function operator+(v1, v2: Vec4ub): Vec4ub := new Vec4ub(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2, v1.val3+v2.val3);
    public static function operator-(v1, v2: Vec4ub): Vec4ub := new Vec4ub(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2, v1.val3-v2.val3);
    
    public static function operator implicit(v: Vec1b): Vec4ub := new Vec4ub(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec4ub := new Vec4ub(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec4ub := new Vec4ub(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec4ub := new Vec4ub(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec4ub := new Vec4ub(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec4ub := new Vec4ub(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec4ub := new Vec4ub(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec4ub := new Vec4ub(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec4ub := new Vec4ub(Convert.ToByte(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec4ub := new Vec4ub(Convert.ToByte(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec4ub := new Vec4ub(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec4ub := new Vec4ub(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec4ub := new Vec4ub(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec4ub := new Vec4ub(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec4ub := new Vec4ub(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec4ub := new Vec4ub(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec4ub := new Vec4ub(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec4ub := new Vec4ub(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec4ub := new Vec4ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1), 0, 0);
    public static function operator implicit(v: Vec4ub): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec4ub := new Vec4ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1), 0, 0);
    public static function operator implicit(v: Vec4ub): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ub): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ub): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ub): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3s): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ub): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3us): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ub): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ub): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ub): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i64): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ub): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui64): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ub): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3f): Vec4ub := new Vec4ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1), Convert.ToByte(v.val2), 0);
    public static function operator implicit(v: Vec4ub): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3d): Vec4ub := new Vec4ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1), Convert.ToByte(v.val2), 0);
    public static function operator implicit(v: Vec4ub): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec4b): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4ub): Vec4b := new Vec4b(v.val0, v.val1, v.val2, v.val3);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2 + val3*val3;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2 + real(val3)*val3;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ', ';
      res += val3.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec4ub;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec4s = record
    public val0: Int16;
    public val1: Int16;
    public val2: Int16;
    public val3: Int16;
    
    public constructor(val0, val1, val2, val3: Int16);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
      self.val3 := val3;
    end;
    
    private function GetValAt(i: integer): Int16;
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^Int16 := pointer(new IntPtr(@self) + i*2 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Int16);
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^Int16 := pointer(new IntPtr(@self) + i*2 );
      ptr^ := val;
    end;
    public property val[i: integer]: Int16 read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec4s): Vec4s := new Vec4s(-v.val0, -v.val1, -v.val2, -v.val3);
    public static function operator*(v: Vec4s; k: Int16): Vec4s := new Vec4s(v.val0*k, v.val1*k, v.val2*k, v.val3*k);
    public static function operator+(v1, v2: Vec4s): Vec4s := new Vec4s(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2, v1.val3+v2.val3);
    public static function operator-(v1, v2: Vec4s): Vec4s := new Vec4s(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2, v1.val3-v2.val3);
    
    public static function operator implicit(v: Vec1b): Vec4s := new Vec4s(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4s): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec4s := new Vec4s(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4s): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec4s := new Vec4s(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4s): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec4s := new Vec4s(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4s): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec4s := new Vec4s(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4s): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec4s := new Vec4s(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4s): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec4s := new Vec4s(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4s): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec4s := new Vec4s(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4s): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec4s := new Vec4s(Convert.ToInt16(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4s): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec4s := new Vec4s(Convert.ToInt16(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4s): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec4s := new Vec4s(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4s): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec4s := new Vec4s(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4s): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec4s := new Vec4s(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4s): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec4s := new Vec4s(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4s): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec4s := new Vec4s(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4s): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec4s := new Vec4s(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4s): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec4s := new Vec4s(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4s): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec4s := new Vec4s(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4s): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec4s := new Vec4s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1), 0, 0);
    public static function operator implicit(v: Vec4s): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec4s := new Vec4s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1), 0, 0);
    public static function operator implicit(v: Vec4s): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec4s := new Vec4s(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4s): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ub): Vec4s := new Vec4s(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4s): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3s): Vec4s := new Vec4s(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4s): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3us): Vec4s := new Vec4s(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4s): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i): Vec4s := new Vec4s(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4s): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui): Vec4s := new Vec4s(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4s): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i64): Vec4s := new Vec4s(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4s): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui64): Vec4s := new Vec4s(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4s): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3f): Vec4s := new Vec4s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1), Convert.ToInt16(v.val2), 0);
    public static function operator implicit(v: Vec4s): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3d): Vec4s := new Vec4s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1), Convert.ToInt16(v.val2), 0);
    public static function operator implicit(v: Vec4s): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec4b): Vec4s := new Vec4s(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4s): Vec4b := new Vec4b(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4ub): Vec4s := new Vec4s(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4s): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, v.val3);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2 + val3*val3;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2 + real(val3)*val3;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ', ';
      res += val3.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec4s;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec4us = record
    public val0: UInt16;
    public val1: UInt16;
    public val2: UInt16;
    public val3: UInt16;
    
    public constructor(val0, val1, val2, val3: UInt16);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
      self.val3 := val3;
    end;
    
    private function GetValAt(i: integer): UInt16;
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^UInt16 := pointer(new IntPtr(@self) + i*2 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: UInt16);
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^UInt16 := pointer(new IntPtr(@self) + i*2 );
      ptr^ := val;
    end;
    public property val[i: integer]: UInt16 read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec4us; k: UInt16): Vec4us := new Vec4us(v.val0*k, v.val1*k, v.val2*k, v.val3*k);
    public static function operator+(v1, v2: Vec4us): Vec4us := new Vec4us(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2, v1.val3+v2.val3);
    public static function operator-(v1, v2: Vec4us): Vec4us := new Vec4us(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2, v1.val3-v2.val3);
    
    public static function operator implicit(v: Vec1b): Vec4us := new Vec4us(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4us): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec4us := new Vec4us(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4us): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec4us := new Vec4us(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4us): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec4us := new Vec4us(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4us): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec4us := new Vec4us(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4us): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec4us := new Vec4us(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4us): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec4us := new Vec4us(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4us): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec4us := new Vec4us(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4us): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec4us := new Vec4us(Convert.ToUInt16(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4us): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec4us := new Vec4us(Convert.ToUInt16(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4us): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec4us := new Vec4us(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4us): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec4us := new Vec4us(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4us): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec4us := new Vec4us(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4us): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec4us := new Vec4us(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4us): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec4us := new Vec4us(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4us): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec4us := new Vec4us(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4us): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec4us := new Vec4us(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4us): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec4us := new Vec4us(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4us): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec4us := new Vec4us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1), 0, 0);
    public static function operator implicit(v: Vec4us): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec4us := new Vec4us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1), 0, 0);
    public static function operator implicit(v: Vec4us): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec4us := new Vec4us(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4us): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ub): Vec4us := new Vec4us(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4us): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3s): Vec4us := new Vec4us(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4us): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3us): Vec4us := new Vec4us(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4us): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i): Vec4us := new Vec4us(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4us): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui): Vec4us := new Vec4us(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4us): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i64): Vec4us := new Vec4us(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4us): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui64): Vec4us := new Vec4us(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4us): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3f): Vec4us := new Vec4us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1), Convert.ToUInt16(v.val2), 0);
    public static function operator implicit(v: Vec4us): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3d): Vec4us := new Vec4us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1), Convert.ToUInt16(v.val2), 0);
    public static function operator implicit(v: Vec4us): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec4b): Vec4us := new Vec4us(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4us): Vec4b := new Vec4b(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4ub): Vec4us := new Vec4us(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4us): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4s): Vec4us := new Vec4us(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4us): Vec4s := new Vec4s(v.val0, v.val1, v.val2, v.val3);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2 + val3*val3;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2 + real(val3)*val3;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ', ';
      res += val3.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec4us;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec4i = record
    public val0: Int32;
    public val1: Int32;
    public val2: Int32;
    public val3: Int32;
    
    public constructor(val0, val1, val2, val3: Int32);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
      self.val3 := val3;
    end;
    
    private function GetValAt(i: integer): Int32;
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^Int32 := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Int32);
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^Int32 := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: Int32 read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec4i): Vec4i := new Vec4i(-v.val0, -v.val1, -v.val2, -v.val3);
    public static function operator*(v: Vec4i; k: Int32): Vec4i := new Vec4i(v.val0*k, v.val1*k, v.val2*k, v.val3*k);
    public static function operator+(v1, v2: Vec4i): Vec4i := new Vec4i(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2, v1.val3+v2.val3);
    public static function operator-(v1, v2: Vec4i): Vec4i := new Vec4i(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2, v1.val3-v2.val3);
    
    public static function operator implicit(v: Vec1b): Vec4i := new Vec4i(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec4i := new Vec4i(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec4i := new Vec4i(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec4i := new Vec4i(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec4i := new Vec4i(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec4i := new Vec4i(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec4i := new Vec4i(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec4i := new Vec4i(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec4i := new Vec4i(Convert.ToInt32(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4i): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec4i := new Vec4i(Convert.ToInt32(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4i): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec4i := new Vec4i(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec4i := new Vec4i(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec4i := new Vec4i(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec4i := new Vec4i(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec4i := new Vec4i(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec4i := new Vec4i(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec4i := new Vec4i(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec4i := new Vec4i(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec4i := new Vec4i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1), 0, 0);
    public static function operator implicit(v: Vec4i): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec4i := new Vec4i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1), 0, 0);
    public static function operator implicit(v: Vec4i): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec4i := new Vec4i(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ub): Vec4i := new Vec4i(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3s): Vec4i := new Vec4i(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3us): Vec4i := new Vec4i(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i): Vec4i := new Vec4i(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui): Vec4i := new Vec4i(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i64): Vec4i := new Vec4i(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui64): Vec4i := new Vec4i(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3f): Vec4i := new Vec4i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1), Convert.ToInt32(v.val2), 0);
    public static function operator implicit(v: Vec4i): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3d): Vec4i := new Vec4i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1), Convert.ToInt32(v.val2), 0);
    public static function operator implicit(v: Vec4i): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec4b): Vec4i := new Vec4i(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4i): Vec4b := new Vec4b(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4ub): Vec4i := new Vec4i(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4i): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4s): Vec4i := new Vec4i(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4i): Vec4s := new Vec4s(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4us): Vec4i := new Vec4i(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4i): Vec4us := new Vec4us(v.val0, v.val1, v.val2, v.val3);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2 + val3*val3;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2 + real(val3)*val3;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ', ';
      res += val3.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec4i;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec4ui = record
    public val0: UInt32;
    public val1: UInt32;
    public val2: UInt32;
    public val3: UInt32;
    
    public constructor(val0, val1, val2, val3: UInt32);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
      self.val3 := val3;
    end;
    
    private function GetValAt(i: integer): UInt32;
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^UInt32 := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: UInt32);
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^UInt32 := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: UInt32 read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec4ui; k: UInt32): Vec4ui := new Vec4ui(v.val0*k, v.val1*k, v.val2*k, v.val3*k);
    public static function operator+(v1, v2: Vec4ui): Vec4ui := new Vec4ui(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2, v1.val3+v2.val3);
    public static function operator-(v1, v2: Vec4ui): Vec4ui := new Vec4ui(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2, v1.val3-v2.val3);
    
    public static function operator implicit(v: Vec1b): Vec4ui := new Vec4ui(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec4ui := new Vec4ui(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec4ui := new Vec4ui(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec4ui := new Vec4ui(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec4ui := new Vec4ui(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec4ui := new Vec4ui(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec4ui := new Vec4ui(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec4ui := new Vec4ui(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec4ui := new Vec4ui(Convert.ToUInt32(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec4ui := new Vec4ui(Convert.ToUInt32(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec4ui := new Vec4ui(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec4ui := new Vec4ui(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec4ui := new Vec4ui(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec4ui := new Vec4ui(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec4ui := new Vec4ui(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec4ui := new Vec4ui(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec4ui := new Vec4ui(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec4ui := new Vec4ui(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec4ui := new Vec4ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1), 0, 0);
    public static function operator implicit(v: Vec4ui): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec4ui := new Vec4ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1), 0, 0);
    public static function operator implicit(v: Vec4ui): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ub): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3s): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3us): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i64): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui64): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3f): Vec4ui := new Vec4ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1), Convert.ToUInt32(v.val2), 0);
    public static function operator implicit(v: Vec4ui): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3d): Vec4ui := new Vec4ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1), Convert.ToUInt32(v.val2), 0);
    public static function operator implicit(v: Vec4ui): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec4b): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4ui): Vec4b := new Vec4b(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4ub): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4ui): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4s): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4ui): Vec4s := new Vec4s(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4us): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4ui): Vec4us := new Vec4us(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4i): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4ui): Vec4i := new Vec4i(v.val0, v.val1, v.val2, v.val3);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2 + val3*val3;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2 + real(val3)*val3;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ', ';
      res += val3.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec4ui;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec4i64 = record
    public val0: Int64;
    public val1: Int64;
    public val2: Int64;
    public val3: Int64;
    
    public constructor(val0, val1, val2, val3: Int64);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
      self.val3 := val3;
    end;
    
    private function GetValAt(i: integer): Int64;
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^Int64 := pointer(new IntPtr(@self) + i*8 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Int64);
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^Int64 := pointer(new IntPtr(@self) + i*8 );
      ptr^ := val;
    end;
    public property val[i: integer]: Int64 read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec4i64): Vec4i64 := new Vec4i64(-v.val0, -v.val1, -v.val2, -v.val3);
    public static function operator*(v: Vec4i64; k: Int64): Vec4i64 := new Vec4i64(v.val0*k, v.val1*k, v.val2*k, v.val3*k);
    public static function operator+(v1, v2: Vec4i64): Vec4i64 := new Vec4i64(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2, v1.val3+v2.val3);
    public static function operator-(v1, v2: Vec4i64): Vec4i64 := new Vec4i64(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2, v1.val3-v2.val3);
    
    public static function operator implicit(v: Vec1b): Vec4i64 := new Vec4i64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec4i64 := new Vec4i64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec4i64 := new Vec4i64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec4i64 := new Vec4i64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec4i64 := new Vec4i64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec4i64 := new Vec4i64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec4i64 := new Vec4i64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec4i64 := new Vec4i64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec4i64 := new Vec4i64(Convert.ToInt64(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec4i64 := new Vec4i64(Convert.ToInt64(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec4i64 := new Vec4i64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec4i64 := new Vec4i64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec4i64 := new Vec4i64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec4i64 := new Vec4i64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec4i64 := new Vec4i64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec4i64 := new Vec4i64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec4i64 := new Vec4i64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec4i64 := new Vec4i64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec4i64 := new Vec4i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1), 0, 0);
    public static function operator implicit(v: Vec4i64): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec4i64 := new Vec4i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1), 0, 0);
    public static function operator implicit(v: Vec4i64): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i64): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ub): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i64): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3s): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i64): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3us): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i64): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i64): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i64): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i64): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i64): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui64): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i64): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3f): Vec4i64 := new Vec4i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1), Convert.ToInt64(v.val2), 0);
    public static function operator implicit(v: Vec4i64): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3d): Vec4i64 := new Vec4i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1), Convert.ToInt64(v.val2), 0);
    public static function operator implicit(v: Vec4i64): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec4b): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4i64): Vec4b := new Vec4b(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4ub): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4i64): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4s): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4i64): Vec4s := new Vec4s(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4us): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4i64): Vec4us := new Vec4us(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4i): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4i64): Vec4i := new Vec4i(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4ui): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4i64): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, v.val3);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2 + val3*val3;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2 + real(val3)*val3;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ', ';
      res += val3.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec4i64;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec4ui64 = record
    public val0: UInt64;
    public val1: UInt64;
    public val2: UInt64;
    public val3: UInt64;
    
    public constructor(val0, val1, val2, val3: UInt64);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
      self.val3 := val3;
    end;
    
    private function GetValAt(i: integer): UInt64;
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^UInt64 := pointer(new IntPtr(@self) + i*8 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: UInt64);
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^UInt64 := pointer(new IntPtr(@self) + i*8 );
      ptr^ := val;
    end;
    public property val[i: integer]: UInt64 read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec4ui64; k: UInt64): Vec4ui64 := new Vec4ui64(v.val0*k, v.val1*k, v.val2*k, v.val3*k);
    public static function operator+(v1, v2: Vec4ui64): Vec4ui64 := new Vec4ui64(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2, v1.val3+v2.val3);
    public static function operator-(v1, v2: Vec4ui64): Vec4ui64 := new Vec4ui64(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2, v1.val3-v2.val3);
    
    public static function operator implicit(v: Vec1b): Vec4ui64 := new Vec4ui64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec4ui64 := new Vec4ui64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec4ui64 := new Vec4ui64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec4ui64 := new Vec4ui64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec4ui64 := new Vec4ui64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec4ui64 := new Vec4ui64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec4ui64 := new Vec4ui64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec4ui64 := new Vec4ui64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec4ui64 := new Vec4ui64(Convert.ToUInt64(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec4ui64 := new Vec4ui64(Convert.ToUInt64(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec4ui64 := new Vec4ui64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec4ui64 := new Vec4ui64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec4ui64 := new Vec4ui64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec4ui64 := new Vec4ui64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec4ui64 := new Vec4ui64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec4ui64 := new Vec4ui64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec4ui64 := new Vec4ui64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec4ui64 := new Vec4ui64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec4ui64 := new Vec4ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1), 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec4ui64 := new Vec4ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1), 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui64): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ub): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui64): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3s): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui64): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3us): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui64): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui64): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui64): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i64): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui64): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui64): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui64): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3f): Vec4ui64 := new Vec4ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1), Convert.ToUInt64(v.val2), 0);
    public static function operator implicit(v: Vec4ui64): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3d): Vec4ui64 := new Vec4ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1), Convert.ToUInt64(v.val2), 0);
    public static function operator implicit(v: Vec4ui64): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec4b): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4ui64): Vec4b := new Vec4b(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4ub): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4ui64): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4s): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4ui64): Vec4s := new Vec4s(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4us): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4ui64): Vec4us := new Vec4us(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4i): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4ui64): Vec4i := new Vec4i(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4ui): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4ui64): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4i64): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4ui64): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, v.val3);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2 + val3*val3;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2 + real(val3)*val3;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ', ';
      res += val3.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec4ui64;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec4f = record
    public val0: single;
    public val1: single;
    public val2: single;
    public val3: single;
    
    public constructor(val0, val1, val2, val3: single);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
      self.val3 := val3;
    end;
    
    private function GetValAt(i: integer): single;
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^single := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: single);
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^single := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: single read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec4f): Vec4f := new Vec4f(-v.val0, -v.val1, -v.val2, -v.val3);
    public static function operator*(v: Vec4f; k: single): Vec4f := new Vec4f(v.val0*k, v.val1*k, v.val2*k, v.val3*k);
    public static function operator/(v: Vec4f; k: single): Vec4f := new Vec4f(v.val0/k, v.val1/k, v.val2/k, v.val3/k);
    public static function operator+(v1, v2: Vec4f): Vec4f := new Vec4f(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2, v1.val3+v2.val3);
    public static function operator-(v1, v2: Vec4f): Vec4f := new Vec4f(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2, v1.val3-v2.val3);
    
    public static function operator implicit(v: Vec1b): Vec4f := new Vec4f(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4f): Vec1b := new Vec1b(Convert.ToSByte(v.val0));
    
    public static function operator implicit(v: Vec1ub): Vec4f := new Vec4f(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4f): Vec1ub := new Vec1ub(Convert.ToByte(v.val0));
    
    public static function operator implicit(v: Vec1s): Vec4f := new Vec4f(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4f): Vec1s := new Vec1s(Convert.ToInt16(v.val0));
    
    public static function operator implicit(v: Vec1us): Vec4f := new Vec4f(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4f): Vec1us := new Vec1us(Convert.ToUInt16(v.val0));
    
    public static function operator implicit(v: Vec1i): Vec4f := new Vec4f(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4f): Vec1i := new Vec1i(Convert.ToInt32(v.val0));
    
    public static function operator implicit(v: Vec1ui): Vec4f := new Vec4f(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4f): Vec1ui := new Vec1ui(Convert.ToUInt32(v.val0));
    
    public static function operator implicit(v: Vec1i64): Vec4f := new Vec4f(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4f): Vec1i64 := new Vec1i64(Convert.ToInt64(v.val0));
    
    public static function operator implicit(v: Vec1ui64): Vec4f := new Vec4f(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4f): Vec1ui64 := new Vec1ui64(Convert.ToUInt64(v.val0));
    
    public static function operator implicit(v: Vec1f): Vec4f := new Vec4f(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4f): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec4f := new Vec4f(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4f): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec4f := new Vec4f(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4f): Vec2b := new Vec2b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1));
    
    public static function operator implicit(v: Vec2ub): Vec4f := new Vec4f(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4f): Vec2ub := new Vec2ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1));
    
    public static function operator implicit(v: Vec2s): Vec4f := new Vec4f(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4f): Vec2s := new Vec2s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1));
    
    public static function operator implicit(v: Vec2us): Vec4f := new Vec4f(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4f): Vec2us := new Vec2us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1));
    
    public static function operator implicit(v: Vec2i): Vec4f := new Vec4f(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4f): Vec2i := new Vec2i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1));
    
    public static function operator implicit(v: Vec2ui): Vec4f := new Vec4f(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4f): Vec2ui := new Vec2ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1));
    
    public static function operator implicit(v: Vec2i64): Vec4f := new Vec4f(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4f): Vec2i64 := new Vec2i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1));
    
    public static function operator implicit(v: Vec2ui64): Vec4f := new Vec4f(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4f): Vec2ui64 := new Vec2ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1));
    
    public static function operator implicit(v: Vec2f): Vec4f := new Vec4f(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4f): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec4f := new Vec4f(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4f): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec4f := new Vec4f(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4f): Vec3b := new Vec3b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1), Convert.ToSByte(v.val2));
    
    public static function operator implicit(v: Vec3ub): Vec4f := new Vec4f(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4f): Vec3ub := new Vec3ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1), Convert.ToByte(v.val2));
    
    public static function operator implicit(v: Vec3s): Vec4f := new Vec4f(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4f): Vec3s := new Vec3s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1), Convert.ToInt16(v.val2));
    
    public static function operator implicit(v: Vec3us): Vec4f := new Vec4f(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4f): Vec3us := new Vec3us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1), Convert.ToUInt16(v.val2));
    
    public static function operator implicit(v: Vec3i): Vec4f := new Vec4f(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4f): Vec3i := new Vec3i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1), Convert.ToInt32(v.val2));
    
    public static function operator implicit(v: Vec3ui): Vec4f := new Vec4f(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4f): Vec3ui := new Vec3ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1), Convert.ToUInt32(v.val2));
    
    public static function operator implicit(v: Vec3i64): Vec4f := new Vec4f(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4f): Vec3i64 := new Vec3i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1), Convert.ToInt64(v.val2));
    
    public static function operator implicit(v: Vec3ui64): Vec4f := new Vec4f(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4f): Vec3ui64 := new Vec3ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1), Convert.ToUInt64(v.val2));
    
    public static function operator implicit(v: Vec3f): Vec4f := new Vec4f(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4f): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3d): Vec4f := new Vec4f(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4f): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec4b): Vec4f := new Vec4f(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4f): Vec4b := new Vec4b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1), Convert.ToSByte(v.val2), Convert.ToSByte(v.val3));
    
    public static function operator implicit(v: Vec4ub): Vec4f := new Vec4f(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4f): Vec4ub := new Vec4ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1), Convert.ToByte(v.val2), Convert.ToByte(v.val3));
    
    public static function operator implicit(v: Vec4s): Vec4f := new Vec4f(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4f): Vec4s := new Vec4s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1), Convert.ToInt16(v.val2), Convert.ToInt16(v.val3));
    
    public static function operator implicit(v: Vec4us): Vec4f := new Vec4f(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4f): Vec4us := new Vec4us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1), Convert.ToUInt16(v.val2), Convert.ToUInt16(v.val3));
    
    public static function operator implicit(v: Vec4i): Vec4f := new Vec4f(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4f): Vec4i := new Vec4i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1), Convert.ToInt32(v.val2), Convert.ToInt32(v.val3));
    
    public static function operator implicit(v: Vec4ui): Vec4f := new Vec4f(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4f): Vec4ui := new Vec4ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1), Convert.ToUInt32(v.val2), Convert.ToUInt32(v.val3));
    
    public static function operator implicit(v: Vec4i64): Vec4f := new Vec4f(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4f): Vec4i64 := new Vec4i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1), Convert.ToInt64(v.val2), Convert.ToInt64(v.val3));
    
    public static function operator implicit(v: Vec4ui64): Vec4f := new Vec4f(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4f): Vec4ui64 := new Vec4ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1), Convert.ToUInt64(v.val2), Convert.ToUInt64(v.val3));
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2 + val3*val3;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2 + real(val3)*val3;
    
    public function Normalized := self / single(Sqrt(self.SqrLength_d));
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ', ';
      res += val3.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec4f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec4d = record
    public val0: double;
    public val1: double;
    public val2: double;
    public val3: double;
    
    public constructor(val0, val1, val2, val3: double);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
      self.val3 := val3;
    end;
    
    private function GetValAt(i: integer): double;
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^double := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: double);
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^double := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: double read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec4d): Vec4d := new Vec4d(-v.val0, -v.val1, -v.val2, -v.val3);
    public static function operator*(v: Vec4d; k: double): Vec4d := new Vec4d(v.val0*k, v.val1*k, v.val2*k, v.val3*k);
    public static function operator/(v: Vec4d; k: double): Vec4d := new Vec4d(v.val0/k, v.val1/k, v.val2/k, v.val3/k);
    public static function operator+(v1, v2: Vec4d): Vec4d := new Vec4d(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2, v1.val3+v2.val3);
    public static function operator-(v1, v2: Vec4d): Vec4d := new Vec4d(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2, v1.val3-v2.val3);
    
    public static function operator implicit(v: Vec1b): Vec4d := new Vec4d(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4d): Vec1b := new Vec1b(Convert.ToSByte(v.val0));
    
    public static function operator implicit(v: Vec1ub): Vec4d := new Vec4d(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4d): Vec1ub := new Vec1ub(Convert.ToByte(v.val0));
    
    public static function operator implicit(v: Vec1s): Vec4d := new Vec4d(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4d): Vec1s := new Vec1s(Convert.ToInt16(v.val0));
    
    public static function operator implicit(v: Vec1us): Vec4d := new Vec4d(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4d): Vec1us := new Vec1us(Convert.ToUInt16(v.val0));
    
    public static function operator implicit(v: Vec1i): Vec4d := new Vec4d(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4d): Vec1i := new Vec1i(Convert.ToInt32(v.val0));
    
    public static function operator implicit(v: Vec1ui): Vec4d := new Vec4d(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4d): Vec1ui := new Vec1ui(Convert.ToUInt32(v.val0));
    
    public static function operator implicit(v: Vec1i64): Vec4d := new Vec4d(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4d): Vec1i64 := new Vec1i64(Convert.ToInt64(v.val0));
    
    public static function operator implicit(v: Vec1ui64): Vec4d := new Vec4d(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4d): Vec1ui64 := new Vec1ui64(Convert.ToUInt64(v.val0));
    
    public static function operator implicit(v: Vec1f): Vec4d := new Vec4d(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4d): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec4d := new Vec4d(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4d): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec4d := new Vec4d(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4d): Vec2b := new Vec2b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1));
    
    public static function operator implicit(v: Vec2ub): Vec4d := new Vec4d(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4d): Vec2ub := new Vec2ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1));
    
    public static function operator implicit(v: Vec2s): Vec4d := new Vec4d(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4d): Vec2s := new Vec2s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1));
    
    public static function operator implicit(v: Vec2us): Vec4d := new Vec4d(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4d): Vec2us := new Vec2us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1));
    
    public static function operator implicit(v: Vec2i): Vec4d := new Vec4d(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4d): Vec2i := new Vec2i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1));
    
    public static function operator implicit(v: Vec2ui): Vec4d := new Vec4d(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4d): Vec2ui := new Vec2ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1));
    
    public static function operator implicit(v: Vec2i64): Vec4d := new Vec4d(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4d): Vec2i64 := new Vec2i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1));
    
    public static function operator implicit(v: Vec2ui64): Vec4d := new Vec4d(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4d): Vec2ui64 := new Vec2ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1));
    
    public static function operator implicit(v: Vec2f): Vec4d := new Vec4d(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4d): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec4d := new Vec4d(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4d): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec4d := new Vec4d(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4d): Vec3b := new Vec3b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1), Convert.ToSByte(v.val2));
    
    public static function operator implicit(v: Vec3ub): Vec4d := new Vec4d(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4d): Vec3ub := new Vec3ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1), Convert.ToByte(v.val2));
    
    public static function operator implicit(v: Vec3s): Vec4d := new Vec4d(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4d): Vec3s := new Vec3s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1), Convert.ToInt16(v.val2));
    
    public static function operator implicit(v: Vec3us): Vec4d := new Vec4d(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4d): Vec3us := new Vec3us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1), Convert.ToUInt16(v.val2));
    
    public static function operator implicit(v: Vec3i): Vec4d := new Vec4d(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4d): Vec3i := new Vec3i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1), Convert.ToInt32(v.val2));
    
    public static function operator implicit(v: Vec3ui): Vec4d := new Vec4d(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4d): Vec3ui := new Vec3ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1), Convert.ToUInt32(v.val2));
    
    public static function operator implicit(v: Vec3i64): Vec4d := new Vec4d(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4d): Vec3i64 := new Vec3i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1), Convert.ToInt64(v.val2));
    
    public static function operator implicit(v: Vec3ui64): Vec4d := new Vec4d(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4d): Vec3ui64 := new Vec3ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1), Convert.ToUInt64(v.val2));
    
    public static function operator implicit(v: Vec3f): Vec4d := new Vec4d(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4d): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3d): Vec4d := new Vec4d(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4d): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec4b): Vec4d := new Vec4d(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4d): Vec4b := new Vec4b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1), Convert.ToSByte(v.val2), Convert.ToSByte(v.val3));
    
    public static function operator implicit(v: Vec4ub): Vec4d := new Vec4d(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4d): Vec4ub := new Vec4ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1), Convert.ToByte(v.val2), Convert.ToByte(v.val3));
    
    public static function operator implicit(v: Vec4s): Vec4d := new Vec4d(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4d): Vec4s := new Vec4s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1), Convert.ToInt16(v.val2), Convert.ToInt16(v.val3));
    
    public static function operator implicit(v: Vec4us): Vec4d := new Vec4d(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4d): Vec4us := new Vec4us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1), Convert.ToUInt16(v.val2), Convert.ToUInt16(v.val3));
    
    public static function operator implicit(v: Vec4i): Vec4d := new Vec4d(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4d): Vec4i := new Vec4i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1), Convert.ToInt32(v.val2), Convert.ToInt32(v.val3));
    
    public static function operator implicit(v: Vec4ui): Vec4d := new Vec4d(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4d): Vec4ui := new Vec4ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1), Convert.ToUInt32(v.val2), Convert.ToUInt32(v.val3));
    
    public static function operator implicit(v: Vec4i64): Vec4d := new Vec4d(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4d): Vec4i64 := new Vec4i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1), Convert.ToInt64(v.val2), Convert.ToInt64(v.val3));
    
    public static function operator implicit(v: Vec4ui64): Vec4d := new Vec4d(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4d): Vec4ui64 := new Vec4ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1), Convert.ToUInt64(v.val2), Convert.ToUInt64(v.val3));
    
    public static function operator implicit(v: Vec4f): Vec4d := new Vec4d(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4d): Vec4f := new Vec4f(v.val0, v.val1, v.val2, v.val3);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2 + val3*val3;
    
    public function Normalized := self / Sqrt(self.SqrLength);
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ', ';
      res += val3.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec4d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  {$endregion Vec4}
  
  {$endregion Vec}
  
  {$region Mtr}
  
  Mtr2x2f = record
    public val00, val10: single;
    public val01, val11: single;
    
    public constructor(val00, val01, val10, val11: single);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val10 := val10;
      self.val11 := val11;
    end;
    
    private function GetValAt(y,x: integer): single;
    begin
      if cardinal(x) > 1 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..1');
      if cardinal(y) > 1 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..1');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*2 + y) * 4 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: single);
    begin
      if cardinal(x) > 1 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..1');
      if cardinal(y) > 1 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..1');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*2 + y) * 4 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: single read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr2x2f read new Mtr2x2f(1.0, 0.0, 0.0, 1.0);
    
    public property Row0: Vec2f read new Vec2f(self.val00, self.val01) write begin self.val00 := value.val0; self.val01 := value.val1; end;
    public property Row1: Vec2f read new Vec2f(self.val10, self.val11) write begin self.val10 := value.val0; self.val11 := value.val1; end;
    public property Row[y: integer]: Vec2f read y=0?Row0:y=1?Row1:Arr&<Vec2f>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..1');
    end;
    
    public property Col0: Vec2f read new Vec2f(self.val00, self.val10) write begin self.val00 := value.val0; self.val10 := value.val1; end;
    public property Col1: Vec2f read new Vec2f(self.val01, self.val11) write begin self.val01 := value.val0; self.val11 := value.val1; end;
    public property Col[x: integer]: Vec2f read x=0?Col0:x=1?Col1:Arr&<Vec2f>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..1');
    end;
    
    public property ColPtr0: ^Vec2f read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec2f read pointer(IntPtr(pointer(@self)) + 8);
    public property ColPtr[x: integer]: ^Vec2f read pointer(IntPtr(pointer(@self)) + x*8);
    
    public static function Scale(k: double): Mtr2x2f := new Mtr2x2f(k, 0.0, 0.0, k);
    
    public static function Traslate(X: single): Mtr2x2f := new Mtr2x2f(1.0, X, 0.0, 1.0);
    public static function TraslateTransposed(X: single): Mtr2x2f := new Mtr2x2f(1.0, 0.0, X, 1.0);
    
    public static function RotateXYcw(rot: double): Mtr2x2f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr2x2f(
         cr, +sr,
        -sr,  cr
      );
    end;
    public static function RotateXYccw(rot: double): Mtr2x2f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr2x2f(
         cr, -sr,
        +sr,  cr
      );
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[2,2];
      for var y := 0 to 2-1 do
        for var x := 0 to 2-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*2 + 4; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr2x2f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr2x2f; v: Vec2f): Vec2f := new Vec2f(m.val00*v.val0+m.val01*v.val1, m.val10*v.val0+m.val11*v.val1);
    public static function operator*(v: Vec2f; m: Mtr2x2f): Vec2f := new Vec2f(m.val00*v.val0+m.val10*v.val1, m.val01*v.val0+m.val11*v.val1);
    
  end;
  Mtr2f = Mtr2x2f;
  
  Mtr3x3f = record
    public val00, val10, val20: single;
    public val01, val11, val21: single;
    public val02, val12, val22: single;
    
    public constructor(val00, val01, val02, val10, val11, val12, val20, val21, val22: single);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val02 := val02;
      self.val10 := val10;
      self.val11 := val11;
      self.val12 := val12;
      self.val20 := val20;
      self.val21 := val21;
      self.val22 := val22;
    end;
    
    private function GetValAt(y,x: integer): single;
    begin
      if cardinal(x) > 2 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..2');
      if cardinal(y) > 2 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..2');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*3 + y) * 4 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: single);
    begin
      if cardinal(x) > 2 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..2');
      if cardinal(y) > 2 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..2');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*3 + y) * 4 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: single read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr3x3f read new Mtr3x3f(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);
    
    public property Row0: Vec3f read new Vec3f(self.val00, self.val01, self.val02) write begin self.val00 := value.val0; self.val01 := value.val1; self.val02 := value.val2; end;
    public property Row1: Vec3f read new Vec3f(self.val10, self.val11, self.val12) write begin self.val10 := value.val0; self.val11 := value.val1; self.val12 := value.val2; end;
    public property Row2: Vec3f read new Vec3f(self.val20, self.val21, self.val22) write begin self.val20 := value.val0; self.val21 := value.val1; self.val22 := value.val2; end;
    public property Row[y: integer]: Vec3f read y=0?Row0:y=1?Row1:y=2?Row2:Arr&<Vec3f>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      2: Row2 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..2');
    end;
    
    public property Col0: Vec3f read new Vec3f(self.val00, self.val10, self.val20) write begin self.val00 := value.val0; self.val10 := value.val1; self.val20 := value.val2; end;
    public property Col1: Vec3f read new Vec3f(self.val01, self.val11, self.val21) write begin self.val01 := value.val0; self.val11 := value.val1; self.val21 := value.val2; end;
    public property Col2: Vec3f read new Vec3f(self.val02, self.val12, self.val22) write begin self.val02 := value.val0; self.val12 := value.val1; self.val22 := value.val2; end;
    public property Col[x: integer]: Vec3f read x=0?Col0:x=1?Col1:x=2?Col2:Arr&<Vec3f>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      2: Col2 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..2');
    end;
    
    public property ColPtr0: ^Vec3f read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec3f read pointer(IntPtr(pointer(@self)) + 12);
    public property ColPtr2: ^Vec3f read pointer(IntPtr(pointer(@self)) + 24);
    public property ColPtr[x: integer]: ^Vec3f read pointer(IntPtr(pointer(@self)) + x*12);
    
    public static function Scale(k: double): Mtr3x3f := new Mtr3x3f(k, 0.0, 0.0, 0.0, k, 0.0, 0.0, 0.0, k);
    
    public static function Traslate(X, Y: single): Mtr3x3f := new Mtr3x3f(1.0, 0.0, X, 0.0, 1.0, Y, 0.0, 0.0, 1.0);
    public static function TraslateTransposed(X, Y: single): Mtr3x3f := new Mtr3x3f(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, X, Y, 1.0);
    
    public static function RotateXYcw(rot: double): Mtr3x3f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr3x3f(
         cr, +sr, 0.0,
        -sr,  cr, 0.0,
        0.0, 0.0, 1.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr3x3f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr3x3f(
         cr, -sr, 0.0,
        +sr,  cr, 0.0,
        0.0, 0.0, 1.0
      );
    end;
    
    public static function RotateYZcw(rot: double): Mtr3x3f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr3x3f(
        1.0, 0.0, 0.0,
        0.0,  cr, +sr,
        0.0, -sr,  cr
      );
    end;
    public static function RotateYZccw(rot: double): Mtr3x3f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr3x3f(
        1.0, 0.0, 0.0,
        0.0,  cr, -sr,
        0.0, +sr,  cr
      );
    end;
    
    public static function RotateZXcw(rot: double): Mtr3x3f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr3x3f(
         cr, 0.0, -sr,
        0.0, 1.0, 0.0,
        +sr, 0.0,  cr
      );
    end;
    public static function RotateZXccw(rot: double): Mtr3x3f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr3x3f(
         cr, 0.0, +sr,
        0.0, 1.0, 0.0,
        -sr, 0.0,  cr
      );
    end;
    
    public static function Rotate3Dcw(u: Vec3f; rot: double): Mtr3x3f;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := -k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := -k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := -k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
    end;
    
    public static function Rotate3Dccw(u: Vec3f; rot: double): Mtr3x3f;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := -k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := -k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := -k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[3,3];
      for var y := 0 to 3-1 do
        for var x := 0 to 3-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*3 + 6; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[2,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr3x3f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr3x3f; v: Vec3f): Vec3f := new Vec3f(m.val00*v.val0+m.val01*v.val1+m.val02*v.val2, m.val10*v.val0+m.val11*v.val1+m.val12*v.val2, m.val20*v.val0+m.val21*v.val1+m.val22*v.val2);
    public static function operator*(v: Vec3f; m: Mtr3x3f): Vec3f := new Vec3f(m.val00*v.val0+m.val10*v.val1+m.val20*v.val2, m.val01*v.val0+m.val11*v.val1+m.val21*v.val2, m.val02*v.val0+m.val12*v.val1+m.val22*v.val2);
    
    public static function operator implicit(m: Mtr2x2f): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x3f): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
  end;
  Mtr3f = Mtr3x3f;
  
  Mtr4x4f = record
    public val00, val10, val20, val30: single;
    public val01, val11, val21, val31: single;
    public val02, val12, val22, val32: single;
    public val03, val13, val23, val33: single;
    
    public constructor(val00, val01, val02, val03, val10, val11, val12, val13, val20, val21, val22, val23, val30, val31, val32, val33: single);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val02 := val02;
      self.val03 := val03;
      self.val10 := val10;
      self.val11 := val11;
      self.val12 := val12;
      self.val13 := val13;
      self.val20 := val20;
      self.val21 := val21;
      self.val22 := val22;
      self.val23 := val23;
      self.val30 := val30;
      self.val31 := val31;
      self.val32 := val32;
      self.val33 := val33;
    end;
    
    private function GetValAt(y,x: integer): single;
    begin
      if cardinal(x) > 3 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..3');
      if cardinal(y) > 3 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..3');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*4 + y) * 4 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: single);
    begin
      if cardinal(x) > 3 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..3');
      if cardinal(y) > 3 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..3');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*4 + y) * 4 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: single read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr4x4f read new Mtr4x4f(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);
    
    public property Row0: Vec4f read new Vec4f(self.val00, self.val01, self.val02, self.val03) write begin self.val00 := value.val0; self.val01 := value.val1; self.val02 := value.val2; self.val03 := value.val3; end;
    public property Row1: Vec4f read new Vec4f(self.val10, self.val11, self.val12, self.val13) write begin self.val10 := value.val0; self.val11 := value.val1; self.val12 := value.val2; self.val13 := value.val3; end;
    public property Row2: Vec4f read new Vec4f(self.val20, self.val21, self.val22, self.val23) write begin self.val20 := value.val0; self.val21 := value.val1; self.val22 := value.val2; self.val23 := value.val3; end;
    public property Row3: Vec4f read new Vec4f(self.val30, self.val31, self.val32, self.val33) write begin self.val30 := value.val0; self.val31 := value.val1; self.val32 := value.val2; self.val33 := value.val3; end;
    public property Row[y: integer]: Vec4f read y=0?Row0:y=1?Row1:y=2?Row2:y=3?Row3:Arr&<Vec4f>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      2: Row2 := value;
      3: Row3 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..3');
    end;
    
    public property Col0: Vec4f read new Vec4f(self.val00, self.val10, self.val20, self.val30) write begin self.val00 := value.val0; self.val10 := value.val1; self.val20 := value.val2; self.val30 := value.val3; end;
    public property Col1: Vec4f read new Vec4f(self.val01, self.val11, self.val21, self.val31) write begin self.val01 := value.val0; self.val11 := value.val1; self.val21 := value.val2; self.val31 := value.val3; end;
    public property Col2: Vec4f read new Vec4f(self.val02, self.val12, self.val22, self.val32) write begin self.val02 := value.val0; self.val12 := value.val1; self.val22 := value.val2; self.val32 := value.val3; end;
    public property Col3: Vec4f read new Vec4f(self.val03, self.val13, self.val23, self.val33) write begin self.val03 := value.val0; self.val13 := value.val1; self.val23 := value.val2; self.val33 := value.val3; end;
    public property Col[x: integer]: Vec4f read x=0?Col0:x=1?Col1:x=2?Col2:x=3?Col3:Arr&<Vec4f>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      2: Col2 := value;
      3: Col3 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..3');
    end;
    
    public property ColPtr0: ^Vec4f read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec4f read pointer(IntPtr(pointer(@self)) + 16);
    public property ColPtr2: ^Vec4f read pointer(IntPtr(pointer(@self)) + 32);
    public property ColPtr3: ^Vec4f read pointer(IntPtr(pointer(@self)) + 48);
    public property ColPtr[x: integer]: ^Vec4f read pointer(IntPtr(pointer(@self)) + x*16);
    
    public static function Scale(k: double): Mtr4x4f := new Mtr4x4f(k, 0.0, 0.0, 0.0, 0.0, k, 0.0, 0.0, 0.0, 0.0, k, 0.0, 0.0, 0.0, 0.0, k);
    
    public static function Traslate(X, Y, Z: single): Mtr4x4f := new Mtr4x4f(1.0, 0.0, 0.0, X, 0.0, 1.0, 0.0, Y, 0.0, 0.0, 1.0, Z, 0.0, 0.0, 0.0, 1.0);
    public static function TraslateTransposed(X, Y, Z: single): Mtr4x4f := new Mtr4x4f(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, X, Y, Z, 1.0);
    
    public static function RotateXYcw(rot: double): Mtr4x4f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr4x4f(
         cr, +sr, 0.0, 0.0,
        -sr,  cr, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0,
        0.0, 0.0, 0.0, 1.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr4x4f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr4x4f(
         cr, -sr, 0.0, 0.0,
        +sr,  cr, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0,
        0.0, 0.0, 0.0, 1.0
      );
    end;
    
    public static function RotateYZcw(rot: double): Mtr4x4f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr4x4f(
        1.0, 0.0, 0.0, 0.0,
        0.0,  cr, +sr, 0.0,
        0.0, -sr,  cr, 0.0,
        0.0, 0.0, 0.0, 1.0
      );
    end;
    public static function RotateYZccw(rot: double): Mtr4x4f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr4x4f(
        1.0, 0.0, 0.0, 0.0,
        0.0,  cr, -sr, 0.0,
        0.0, +sr,  cr, 0.0,
        0.0, 0.0, 0.0, 1.0
      );
    end;
    
    public static function RotateZXcw(rot: double): Mtr4x4f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr4x4f(
         cr, 0.0, -sr, 0.0,
        0.0, 1.0, 0.0, 0.0,
        +sr, 0.0,  cr, 0.0,
        0.0, 0.0, 0.0, 1.0
      );
    end;
    public static function RotateZXccw(rot: double): Mtr4x4f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr4x4f(
         cr, 0.0, +sr, 0.0,
        0.0, 1.0, 0.0, 0.0,
        -sr, 0.0,  cr, 0.0,
        0.0, 0.0, 0.0, 1.0
      );
    end;
    
    public static function Rotate3Dcw(u: Vec3f; rot: double): Mtr4x4f;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := -k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := -k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := -k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
      Result.val33 := 1;
    end;
    
    public static function Rotate3Dccw(u: Vec3f; rot: double): Mtr4x4f;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := -k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := -k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := -k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
      Result.val33 := 1;
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[4,4];
      for var y := 0 to 4-1 do
        for var x := 0 to 4-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*4 + 8; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[2,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[3,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[3,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[3,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[3,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr4x4f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr4x4f; v: Vec4f): Vec4f := new Vec4f(m.val00*v.val0+m.val01*v.val1+m.val02*v.val2+m.val03*v.val3, m.val10*v.val0+m.val11*v.val1+m.val12*v.val2+m.val13*v.val3, m.val20*v.val0+m.val21*v.val1+m.val22*v.val2+m.val23*v.val3, m.val30*v.val0+m.val31*v.val1+m.val32*v.val2+m.val33*v.val3);
    public static function operator*(v: Vec4f; m: Mtr4x4f): Vec4f := new Vec4f(m.val00*v.val0+m.val10*v.val1+m.val20*v.val2+m.val30*v.val3, m.val01*v.val0+m.val11*v.val1+m.val21*v.val2+m.val31*v.val3, m.val02*v.val0+m.val12*v.val1+m.val22*v.val2+m.val32*v.val3, m.val03*v.val0+m.val13*v.val1+m.val23*v.val2+m.val33*v.val3);
    
    public static function operator implicit(m: Mtr2x2f): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x4f): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x4f): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22);
    
  end;
  Mtr4f = Mtr4x4f;
  
  Mtr2x3f = record
    public val00, val10: single;
    public val01, val11: single;
    public val02, val12: single;
    
    public constructor(val00, val01, val02, val10, val11, val12: single);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val02 := val02;
      self.val10 := val10;
      self.val11 := val11;
      self.val12 := val12;
    end;
    
    private function GetValAt(y,x: integer): single;
    begin
      if cardinal(x) > 2 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..2');
      if cardinal(y) > 1 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..1');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*2 + y) * 4 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: single);
    begin
      if cardinal(x) > 2 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..2');
      if cardinal(y) > 1 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..1');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*2 + y) * 4 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: single read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr2x3f read new Mtr2x3f(1.0, 0.0, 0.0, 0.0, 1.0, 0.0);
    
    public property Row0: Vec3f read new Vec3f(self.val00, self.val01, self.val02) write begin self.val00 := value.val0; self.val01 := value.val1; self.val02 := value.val2; end;
    public property Row1: Vec3f read new Vec3f(self.val10, self.val11, self.val12) write begin self.val10 := value.val0; self.val11 := value.val1; self.val12 := value.val2; end;
    public property Row[y: integer]: Vec3f read y=0?Row0:y=1?Row1:Arr&<Vec3f>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..1');
    end;
    
    public property Col0: Vec2f read new Vec2f(self.val00, self.val10) write begin self.val00 := value.val0; self.val10 := value.val1; end;
    public property Col1: Vec2f read new Vec2f(self.val01, self.val11) write begin self.val01 := value.val0; self.val11 := value.val1; end;
    public property Col2: Vec2f read new Vec2f(self.val02, self.val12) write begin self.val02 := value.val0; self.val12 := value.val1; end;
    public property Col[x: integer]: Vec2f read x=0?Col0:x=1?Col1:x=2?Col2:Arr&<Vec2f>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      2: Col2 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..2');
    end;
    
    public property ColPtr0: ^Vec3f read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec3f read pointer(IntPtr(pointer(@self)) + 8);
    public property ColPtr[x: integer]: ^Vec3f read pointer(IntPtr(pointer(@self)) + x*8);
    
    public static function Scale(k: double): Mtr2x3f := new Mtr2x3f(k, 0.0, 0.0, 0.0, k, 0.0);
    
    public static function Traslate(X, Y: single): Mtr2x3f := new Mtr2x3f(1.0, 0.0, X, 0.0, 1.0, Y);
    public static function TraslateTransposed(X: single): Mtr2x3f := new Mtr2x3f(1.0, 0.0, 0.0, X, 1.0, 0.0);
    
    public static function RotateXYcw(rot: double): Mtr2x3f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr2x3f(
         cr, +sr, 0.0,
        -sr,  cr, 0.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr2x3f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr2x3f(
         cr, -sr, 0.0,
        +sr,  cr, 0.0
      );
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[2,3];
      for var y := 0 to 2-1 do
        for var x := 0 to 3-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*3 + 6; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr2x3f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr2x3f; v: Vec3f): Vec2f := new Vec2f(m.val00*v.val0+m.val01*v.val1+m.val02*v.val2, m.val10*v.val0+m.val11*v.val1+m.val12*v.val2);
    public static function operator*(v: Vec2f; m: Mtr2x3f): Vec3f := new Vec3f(m.val00*v.val0+m.val10*v.val1, m.val01*v.val0+m.val11*v.val1, m.val02*v.val0+m.val12*v.val1);
    
    public static function operator implicit(m: Mtr2x2f): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0);
    public static function operator implicit(m: Mtr2x3f): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    public static function operator implicit(m: Mtr2x3f): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x4f): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    public static function operator implicit(m: Mtr2x3f): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    
  end;
  
  Mtr3x2f = record
    public val00, val10, val20: single;
    public val01, val11, val21: single;
    
    public constructor(val00, val01, val10, val11, val20, val21: single);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val10 := val10;
      self.val11 := val11;
      self.val20 := val20;
      self.val21 := val21;
    end;
    
    private function GetValAt(y,x: integer): single;
    begin
      if cardinal(x) > 1 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..1');
      if cardinal(y) > 2 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..2');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*3 + y) * 4 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: single);
    begin
      if cardinal(x) > 1 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..1');
      if cardinal(y) > 2 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..2');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*3 + y) * 4 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: single read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr3x2f read new Mtr3x2f(1.0, 0.0, 0.0, 1.0, 0.0, 0.0);
    
    public property Row0: Vec2f read new Vec2f(self.val00, self.val01) write begin self.val00 := value.val0; self.val01 := value.val1; end;
    public property Row1: Vec2f read new Vec2f(self.val10, self.val11) write begin self.val10 := value.val0; self.val11 := value.val1; end;
    public property Row2: Vec2f read new Vec2f(self.val20, self.val21) write begin self.val20 := value.val0; self.val21 := value.val1; end;
    public property Row[y: integer]: Vec2f read y=0?Row0:y=1?Row1:y=2?Row2:Arr&<Vec2f>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      2: Row2 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..2');
    end;
    
    public property Col0: Vec3f read new Vec3f(self.val00, self.val10, self.val20) write begin self.val00 := value.val0; self.val10 := value.val1; self.val20 := value.val2; end;
    public property Col1: Vec3f read new Vec3f(self.val01, self.val11, self.val21) write begin self.val01 := value.val0; self.val11 := value.val1; self.val21 := value.val2; end;
    public property Col[x: integer]: Vec3f read x=0?Col0:x=1?Col1:Arr&<Vec3f>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..1');
    end;
    
    public property ColPtr0: ^Vec2f read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec2f read pointer(IntPtr(pointer(@self)) + 12);
    public property ColPtr2: ^Vec2f read pointer(IntPtr(pointer(@self)) + 24);
    public property ColPtr[x: integer]: ^Vec2f read pointer(IntPtr(pointer(@self)) + x*12);
    
    public static function Scale(k: double): Mtr3x2f := new Mtr3x2f(k, 0.0, 0.0, k, 0.0, 0.0);
    
    public static function Traslate(X: single): Mtr3x2f := new Mtr3x2f(1.0, X, 0.0, 1.0, 0.0, 0.0);
    public static function TraslateTransposed(X, Y: single): Mtr3x2f := new Mtr3x2f(1.0, 0.0, 0.0, 1.0, X, Y);
    
    public static function RotateXYcw(rot: double): Mtr3x2f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr3x2f(
         cr, +sr,
        -sr,  cr,
        0.0, 0.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr3x2f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr3x2f(
         cr, -sr,
        +sr,  cr,
        0.0, 0.0
      );
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[3,2];
      for var y := 0 to 3-1 do
        for var x := 0 to 2-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*2 + 4; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[2,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr3x2f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr3x2f; v: Vec2f): Vec3f := new Vec3f(m.val00*v.val0+m.val01*v.val1, m.val10*v.val0+m.val11*v.val1, m.val20*v.val0+m.val21*v.val1);
    public static function operator*(v: Vec3f; m: Mtr3x2f): Vec2f := new Vec2f(m.val00*v.val0+m.val10*v.val1+m.val20*v.val2, m.val01*v.val0+m.val11*v.val1+m.val21*v.val2);
    
    public static function operator implicit(m: Mtr2x2f): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x2f): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    public static function operator implicit(m: Mtr3x2f): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0);
    
    public static function operator implicit(m: Mtr4x4f): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    public static function operator implicit(m: Mtr3x2f): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3f): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x2f): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0);
    
  end;
  
  Mtr2x4f = record
    public val00, val10: single;
    public val01, val11: single;
    public val02, val12: single;
    public val03, val13: single;
    
    public constructor(val00, val01, val02, val03, val10, val11, val12, val13: single);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val02 := val02;
      self.val03 := val03;
      self.val10 := val10;
      self.val11 := val11;
      self.val12 := val12;
      self.val13 := val13;
    end;
    
    private function GetValAt(y,x: integer): single;
    begin
      if cardinal(x) > 3 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..3');
      if cardinal(y) > 1 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..1');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*2 + y) * 4 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: single);
    begin
      if cardinal(x) > 3 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..3');
      if cardinal(y) > 1 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..1');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*2 + y) * 4 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: single read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr2x4f read new Mtr2x4f(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0);
    
    public property Row0: Vec4f read new Vec4f(self.val00, self.val01, self.val02, self.val03) write begin self.val00 := value.val0; self.val01 := value.val1; self.val02 := value.val2; self.val03 := value.val3; end;
    public property Row1: Vec4f read new Vec4f(self.val10, self.val11, self.val12, self.val13) write begin self.val10 := value.val0; self.val11 := value.val1; self.val12 := value.val2; self.val13 := value.val3; end;
    public property Row[y: integer]: Vec4f read y=0?Row0:y=1?Row1:Arr&<Vec4f>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..1');
    end;
    
    public property Col0: Vec2f read new Vec2f(self.val00, self.val10) write begin self.val00 := value.val0; self.val10 := value.val1; end;
    public property Col1: Vec2f read new Vec2f(self.val01, self.val11) write begin self.val01 := value.val0; self.val11 := value.val1; end;
    public property Col2: Vec2f read new Vec2f(self.val02, self.val12) write begin self.val02 := value.val0; self.val12 := value.val1; end;
    public property Col3: Vec2f read new Vec2f(self.val03, self.val13) write begin self.val03 := value.val0; self.val13 := value.val1; end;
    public property Col[x: integer]: Vec2f read x=0?Col0:x=1?Col1:x=2?Col2:x=3?Col3:Arr&<Vec2f>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      2: Col2 := value;
      3: Col3 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..3');
    end;
    
    public property ColPtr0: ^Vec4f read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec4f read pointer(IntPtr(pointer(@self)) + 8);
    public property ColPtr[x: integer]: ^Vec4f read pointer(IntPtr(pointer(@self)) + x*8);
    
    public static function Scale(k: double): Mtr2x4f := new Mtr2x4f(k, 0.0, 0.0, 0.0, 0.0, k, 0.0, 0.0);
    
    public static function Traslate(X, Y: single): Mtr2x4f := new Mtr2x4f(1.0, 0.0, 0.0, X, 0.0, 1.0, 0.0, Y);
    public static function TraslateTransposed(X: single): Mtr2x4f := new Mtr2x4f(1.0, 0.0, 0.0, 0.0, X, 1.0, 0.0, 0.0);
    
    public static function RotateXYcw(rot: double): Mtr2x4f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr2x4f(
         cr, +sr, 0.0, 0.0,
        -sr,  cr, 0.0, 0.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr2x4f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr2x4f(
         cr, -sr, 0.0, 0.0,
        +sr,  cr, 0.0, 0.0
      );
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[2,4];
      for var y := 0 to 2-1 do
        for var x := 0 to 4-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*4 + 8; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr2x4f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr2x4f; v: Vec4f): Vec2f := new Vec2f(m.val00*v.val0+m.val01*v.val1+m.val02*v.val2+m.val03*v.val3, m.val10*v.val0+m.val11*v.val1+m.val12*v.val2+m.val13*v.val3);
    public static function operator*(v: Vec2f; m: Mtr2x4f): Vec4f := new Vec4f(m.val00*v.val0+m.val10*v.val1, m.val01*v.val0+m.val11*v.val1, m.val02*v.val0+m.val12*v.val1, m.val03*v.val0+m.val13*v.val1);
    
    public static function operator implicit(m: Mtr2x2f): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0);
    public static function operator implicit(m: Mtr2x4f): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0);
    public static function operator implicit(m: Mtr2x4f): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x4f): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13);
    public static function operator implicit(m: Mtr2x4f): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3f): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0);
    public static function operator implicit(m: Mtr2x4f): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    
    public static function operator implicit(m: Mtr3x2f): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0);
    public static function operator implicit(m: Mtr2x4f): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0);
    
  end;
  
  Mtr4x2f = record
    public val00, val10, val20, val30: single;
    public val01, val11, val21, val31: single;
    
    public constructor(val00, val01, val10, val11, val20, val21, val30, val31: single);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val10 := val10;
      self.val11 := val11;
      self.val20 := val20;
      self.val21 := val21;
      self.val30 := val30;
      self.val31 := val31;
    end;
    
    private function GetValAt(y,x: integer): single;
    begin
      if cardinal(x) > 1 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..1');
      if cardinal(y) > 3 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..3');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*4 + y) * 4 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: single);
    begin
      if cardinal(x) > 1 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..1');
      if cardinal(y) > 3 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..3');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*4 + y) * 4 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: single read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr4x2f read new Mtr4x2f(1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0);
    
    public property Row0: Vec2f read new Vec2f(self.val00, self.val01) write begin self.val00 := value.val0; self.val01 := value.val1; end;
    public property Row1: Vec2f read new Vec2f(self.val10, self.val11) write begin self.val10 := value.val0; self.val11 := value.val1; end;
    public property Row2: Vec2f read new Vec2f(self.val20, self.val21) write begin self.val20 := value.val0; self.val21 := value.val1; end;
    public property Row3: Vec2f read new Vec2f(self.val30, self.val31) write begin self.val30 := value.val0; self.val31 := value.val1; end;
    public property Row[y: integer]: Vec2f read y=0?Row0:y=1?Row1:y=2?Row2:y=3?Row3:Arr&<Vec2f>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      2: Row2 := value;
      3: Row3 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..3');
    end;
    
    public property Col0: Vec4f read new Vec4f(self.val00, self.val10, self.val20, self.val30) write begin self.val00 := value.val0; self.val10 := value.val1; self.val20 := value.val2; self.val30 := value.val3; end;
    public property Col1: Vec4f read new Vec4f(self.val01, self.val11, self.val21, self.val31) write begin self.val01 := value.val0; self.val11 := value.val1; self.val21 := value.val2; self.val31 := value.val3; end;
    public property Col[x: integer]: Vec4f read x=0?Col0:x=1?Col1:Arr&<Vec4f>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..1');
    end;
    
    public property ColPtr0: ^Vec2f read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec2f read pointer(IntPtr(pointer(@self)) + 16);
    public property ColPtr2: ^Vec2f read pointer(IntPtr(pointer(@self)) + 32);
    public property ColPtr3: ^Vec2f read pointer(IntPtr(pointer(@self)) + 48);
    public property ColPtr[x: integer]: ^Vec2f read pointer(IntPtr(pointer(@self)) + x*16);
    
    public static function Scale(k: double): Mtr4x2f := new Mtr4x2f(k, 0.0, 0.0, k, 0.0, 0.0, 0.0, 0.0);
    
    public static function Traslate(X: single): Mtr4x2f := new Mtr4x2f(1.0, X, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0);
    public static function TraslateTransposed(X, Y: single): Mtr4x2f := new Mtr4x2f(1.0, 0.0, 0.0, 1.0, 0.0, 0.0, X, Y);
    
    public static function RotateXYcw(rot: double): Mtr4x2f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr4x2f(
         cr, +sr,
        -sr,  cr,
        0.0, 0.0,
        0.0, 0.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr4x2f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr4x2f(
         cr, -sr,
        +sr,  cr,
        0.0, 0.0,
        0.0, 0.0
      );
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[4,2];
      for var y := 0 to 4-1 do
        for var x := 0 to 2-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*2 + 4; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[2,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[3,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[3,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr4x2f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr4x2f; v: Vec2f): Vec4f := new Vec4f(m.val00*v.val0+m.val01*v.val1, m.val10*v.val0+m.val11*v.val1, m.val20*v.val0+m.val21*v.val1, m.val30*v.val0+m.val31*v.val1);
    public static function operator*(v: Vec4f; m: Mtr4x2f): Vec2f := new Vec2f(m.val00*v.val0+m.val10*v.val1+m.val20*v.val2+m.val30*v.val3, m.val01*v.val0+m.val11*v.val1+m.val21*v.val2+m.val31*v.val3);
    
    public static function operator implicit(m: Mtr2x2f): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2f): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2f): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0);
    
    public static function operator implicit(m: Mtr4x4f): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, m.val30, m.val31);
    public static function operator implicit(m: Mtr4x2f): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0, m.val30, m.val31, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3f): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2f): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0);
    
    public static function operator implicit(m: Mtr3x2f): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2f): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    
    public static function operator implicit(m: Mtr2x4f): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2f): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0);
    
  end;
  
  Mtr3x4f = record
    public val00, val10, val20: single;
    public val01, val11, val21: single;
    public val02, val12, val22: single;
    public val03, val13, val23: single;
    
    public constructor(val00, val01, val02, val03, val10, val11, val12, val13, val20, val21, val22, val23: single);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val02 := val02;
      self.val03 := val03;
      self.val10 := val10;
      self.val11 := val11;
      self.val12 := val12;
      self.val13 := val13;
      self.val20 := val20;
      self.val21 := val21;
      self.val22 := val22;
      self.val23 := val23;
    end;
    
    private function GetValAt(y,x: integer): single;
    begin
      if cardinal(x) > 3 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..3');
      if cardinal(y) > 2 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..2');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*3 + y) * 4 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: single);
    begin
      if cardinal(x) > 3 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..3');
      if cardinal(y) > 2 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..2');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*3 + y) * 4 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: single read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr3x4f read new Mtr3x4f(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);
    
    public property Row0: Vec4f read new Vec4f(self.val00, self.val01, self.val02, self.val03) write begin self.val00 := value.val0; self.val01 := value.val1; self.val02 := value.val2; self.val03 := value.val3; end;
    public property Row1: Vec4f read new Vec4f(self.val10, self.val11, self.val12, self.val13) write begin self.val10 := value.val0; self.val11 := value.val1; self.val12 := value.val2; self.val13 := value.val3; end;
    public property Row2: Vec4f read new Vec4f(self.val20, self.val21, self.val22, self.val23) write begin self.val20 := value.val0; self.val21 := value.val1; self.val22 := value.val2; self.val23 := value.val3; end;
    public property Row[y: integer]: Vec4f read y=0?Row0:y=1?Row1:y=2?Row2:Arr&<Vec4f>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      2: Row2 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..2');
    end;
    
    public property Col0: Vec3f read new Vec3f(self.val00, self.val10, self.val20) write begin self.val00 := value.val0; self.val10 := value.val1; self.val20 := value.val2; end;
    public property Col1: Vec3f read new Vec3f(self.val01, self.val11, self.val21) write begin self.val01 := value.val0; self.val11 := value.val1; self.val21 := value.val2; end;
    public property Col2: Vec3f read new Vec3f(self.val02, self.val12, self.val22) write begin self.val02 := value.val0; self.val12 := value.val1; self.val22 := value.val2; end;
    public property Col3: Vec3f read new Vec3f(self.val03, self.val13, self.val23) write begin self.val03 := value.val0; self.val13 := value.val1; self.val23 := value.val2; end;
    public property Col[x: integer]: Vec3f read x=0?Col0:x=1?Col1:x=2?Col2:x=3?Col3:Arr&<Vec3f>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      2: Col2 := value;
      3: Col3 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..3');
    end;
    
    public property ColPtr0: ^Vec4f read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec4f read pointer(IntPtr(pointer(@self)) + 12);
    public property ColPtr2: ^Vec4f read pointer(IntPtr(pointer(@self)) + 24);
    public property ColPtr[x: integer]: ^Vec4f read pointer(IntPtr(pointer(@self)) + x*12);
    
    public static function Scale(k: double): Mtr3x4f := new Mtr3x4f(k, 0.0, 0.0, 0.0, 0.0, k, 0.0, 0.0, 0.0, 0.0, k, 0.0);
    
    public static function Traslate(X, Y, Z: single): Mtr3x4f := new Mtr3x4f(1.0, 0.0, 0.0, X, 0.0, 1.0, 0.0, Y, 0.0, 0.0, 1.0, Z);
    public static function TraslateTransposed(X, Y: single): Mtr3x4f := new Mtr3x4f(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, X, Y, 1.0, 0.0);
    
    public static function RotateXYcw(rot: double): Mtr3x4f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr3x4f(
         cr, +sr, 0.0, 0.0,
        -sr,  cr, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr3x4f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr3x4f(
         cr, -sr, 0.0, 0.0,
        +sr,  cr, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0
      );
    end;
    
    public static function RotateYZcw(rot: double): Mtr3x4f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr3x4f(
        1.0, 0.0, 0.0, 0.0,
        0.0,  cr, +sr, 0.0,
        0.0, -sr,  cr, 0.0
      );
    end;
    public static function RotateYZccw(rot: double): Mtr3x4f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr3x4f(
        1.0, 0.0, 0.0, 0.0,
        0.0,  cr, -sr, 0.0,
        0.0, +sr,  cr, 0.0
      );
    end;
    
    public static function RotateZXcw(rot: double): Mtr3x4f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr3x4f(
         cr, 0.0, -sr, 0.0,
        0.0, 1.0, 0.0, 0.0,
        +sr, 0.0,  cr, 0.0
      );
    end;
    public static function RotateZXccw(rot: double): Mtr3x4f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr3x4f(
         cr, 0.0, +sr, 0.0,
        0.0, 1.0, 0.0, 0.0,
        -sr, 0.0,  cr, 0.0
      );
    end;
    
    public static function Rotate3Dcw(u: Vec3f; rot: double): Mtr3x4f;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := -k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := -k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := -k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
    end;
    
    public static function Rotate3Dccw(u: Vec3f; rot: double): Mtr3x4f;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := -k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := -k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := -k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[3,4];
      for var y := 0 to 3-1 do
        for var x := 0 to 4-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*4 + 8; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[2,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr3x4f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr3x4f; v: Vec4f): Vec3f := new Vec3f(m.val00*v.val0+m.val01*v.val1+m.val02*v.val2+m.val03*v.val3, m.val10*v.val0+m.val11*v.val1+m.val12*v.val2+m.val13*v.val3, m.val20*v.val0+m.val21*v.val1+m.val22*v.val2+m.val23*v.val3);
    public static function operator*(v: Vec3f; m: Mtr3x4f): Vec4f := new Vec4f(m.val00*v.val0+m.val10*v.val1+m.val20*v.val2, m.val01*v.val0+m.val11*v.val1+m.val21*v.val2, m.val02*v.val0+m.val12*v.val1+m.val22*v.val2, m.val03*v.val0+m.val13*v.val1+m.val23*v.val2);
    
    public static function operator implicit(m: Mtr2x2f): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4f): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0);
    public static function operator implicit(m: Mtr3x4f): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22);
    
    public static function operator implicit(m: Mtr4x4f): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, m.val20, m.val21, m.val22, m.val23);
    public static function operator implicit(m: Mtr3x4f): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, m.val20, m.val21, m.val22, m.val23, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3f): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4f): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    
    public static function operator implicit(m: Mtr3x2f): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4f): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    
    public static function operator implicit(m: Mtr2x4f): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4f): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13);
    
    public static function operator implicit(m: Mtr4x2f): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4f): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, 0.0, 0.0);
    
  end;
  
  Mtr4x3f = record
    public val00, val10, val20, val30: single;
    public val01, val11, val21, val31: single;
    public val02, val12, val22, val32: single;
    
    public constructor(val00, val01, val02, val10, val11, val12, val20, val21, val22, val30, val31, val32: single);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val02 := val02;
      self.val10 := val10;
      self.val11 := val11;
      self.val12 := val12;
      self.val20 := val20;
      self.val21 := val21;
      self.val22 := val22;
      self.val30 := val30;
      self.val31 := val31;
      self.val32 := val32;
    end;
    
    private function GetValAt(y,x: integer): single;
    begin
      if cardinal(x) > 2 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..2');
      if cardinal(y) > 3 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..3');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*4 + y) * 4 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: single);
    begin
      if cardinal(x) > 2 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..2');
      if cardinal(y) > 3 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..3');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*4 + y) * 4 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: single read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr4x3f read new Mtr4x3f(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0);
    
    public property Row0: Vec3f read new Vec3f(self.val00, self.val01, self.val02) write begin self.val00 := value.val0; self.val01 := value.val1; self.val02 := value.val2; end;
    public property Row1: Vec3f read new Vec3f(self.val10, self.val11, self.val12) write begin self.val10 := value.val0; self.val11 := value.val1; self.val12 := value.val2; end;
    public property Row2: Vec3f read new Vec3f(self.val20, self.val21, self.val22) write begin self.val20 := value.val0; self.val21 := value.val1; self.val22 := value.val2; end;
    public property Row3: Vec3f read new Vec3f(self.val30, self.val31, self.val32) write begin self.val30 := value.val0; self.val31 := value.val1; self.val32 := value.val2; end;
    public property Row[y: integer]: Vec3f read y=0?Row0:y=1?Row1:y=2?Row2:y=3?Row3:Arr&<Vec3f>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      2: Row2 := value;
      3: Row3 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..3');
    end;
    
    public property Col0: Vec4f read new Vec4f(self.val00, self.val10, self.val20, self.val30) write begin self.val00 := value.val0; self.val10 := value.val1; self.val20 := value.val2; self.val30 := value.val3; end;
    public property Col1: Vec4f read new Vec4f(self.val01, self.val11, self.val21, self.val31) write begin self.val01 := value.val0; self.val11 := value.val1; self.val21 := value.val2; self.val31 := value.val3; end;
    public property Col2: Vec4f read new Vec4f(self.val02, self.val12, self.val22, self.val32) write begin self.val02 := value.val0; self.val12 := value.val1; self.val22 := value.val2; self.val32 := value.val3; end;
    public property Col[x: integer]: Vec4f read x=0?Col0:x=1?Col1:x=2?Col2:Arr&<Vec4f>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      2: Col2 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..2');
    end;
    
    public property ColPtr0: ^Vec3f read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec3f read pointer(IntPtr(pointer(@self)) + 16);
    public property ColPtr2: ^Vec3f read pointer(IntPtr(pointer(@self)) + 32);
    public property ColPtr3: ^Vec3f read pointer(IntPtr(pointer(@self)) + 48);
    public property ColPtr[x: integer]: ^Vec3f read pointer(IntPtr(pointer(@self)) + x*16);
    
    public static function Scale(k: double): Mtr4x3f := new Mtr4x3f(k, 0.0, 0.0, 0.0, k, 0.0, 0.0, 0.0, k, 0.0, 0.0, 0.0);
    
    public static function Traslate(X, Y: single): Mtr4x3f := new Mtr4x3f(1.0, 0.0, X, 0.0, 1.0, Y, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0);
    public static function TraslateTransposed(X, Y, Z: single): Mtr4x3f := new Mtr4x3f(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, X, Y, Z);
    
    public static function RotateXYcw(rot: double): Mtr4x3f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr4x3f(
         cr, +sr, 0.0,
        -sr,  cr, 0.0,
        0.0, 0.0, 1.0,
        0.0, 0.0, 0.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr4x3f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr4x3f(
         cr, -sr, 0.0,
        +sr,  cr, 0.0,
        0.0, 0.0, 1.0,
        0.0, 0.0, 0.0
      );
    end;
    
    public static function RotateYZcw(rot: double): Mtr4x3f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr4x3f(
        1.0, 0.0, 0.0,
        0.0,  cr, +sr,
        0.0, -sr,  cr,
        0.0, 0.0, 0.0
      );
    end;
    public static function RotateYZccw(rot: double): Mtr4x3f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr4x3f(
        1.0, 0.0, 0.0,
        0.0,  cr, -sr,
        0.0, +sr,  cr,
        0.0, 0.0, 0.0
      );
    end;
    
    public static function RotateZXcw(rot: double): Mtr4x3f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr4x3f(
         cr, 0.0, -sr,
        0.0, 1.0, 0.0,
        +sr, 0.0,  cr,
        0.0, 0.0, 0.0
      );
    end;
    public static function RotateZXccw(rot: double): Mtr4x3f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr4x3f(
         cr, 0.0, +sr,
        0.0, 1.0, 0.0,
        -sr, 0.0,  cr,
        0.0, 0.0, 0.0
      );
    end;
    
    public static function Rotate3Dcw(u: Vec3f; rot: double): Mtr4x3f;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := -k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := -k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := -k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
    end;
    
    public static function Rotate3Dccw(u: Vec3f; rot: double): Mtr4x3f;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := -k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := -k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := -k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[4,3];
      for var y := 0 to 4-1 do
        for var x := 0 to 3-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*3 + 6; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[2,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[3,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[3,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[3,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr4x3f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr4x3f; v: Vec3f): Vec4f := new Vec4f(m.val00*v.val0+m.val01*v.val1+m.val02*v.val2, m.val10*v.val0+m.val11*v.val1+m.val12*v.val2, m.val20*v.val0+m.val21*v.val1+m.val22*v.val2, m.val30*v.val0+m.val31*v.val1+m.val32*v.val2);
    public static function operator*(v: Vec4f; m: Mtr4x3f): Vec3f := new Vec3f(m.val00*v.val0+m.val10*v.val1+m.val20*v.val2+m.val30*v.val3, m.val01*v.val0+m.val11*v.val1+m.val21*v.val2+m.val31*v.val3, m.val02*v.val0+m.val12*v.val1+m.val22*v.val2+m.val32*v.val3);
    
    public static function operator implicit(m: Mtr2x2f): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3f): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3f): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22);
    
    public static function operator implicit(m: Mtr4x4f): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22, m.val30, m.val31, m.val32);
    public static function operator implicit(m: Mtr4x3f): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0, m.val30, m.val31, m.val32, 0.0);
    
    public static function operator implicit(m: Mtr2x3f): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3f): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    
    public static function operator implicit(m: Mtr3x2f): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3f): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    
    public static function operator implicit(m: Mtr2x4f): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3f): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0);
    
    public static function operator implicit(m: Mtr4x2f): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0, m.val30, m.val31, 0.0);
    public static function operator implicit(m: Mtr4x3f): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, m.val30, m.val31);
    
    public static function operator implicit(m: Mtr3x4f): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3f): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0);
    
  end;
  
  Mtr2x2d = record
    public val00, val10: double;
    public val01, val11: double;
    
    public constructor(val00, val01, val10, val11: double);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val10 := val10;
      self.val11 := val11;
    end;
    
    private function GetValAt(y,x: integer): double;
    begin
      if cardinal(x) > 1 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..1');
      if cardinal(y) > 1 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..1');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*2 + y) * 8 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: double);
    begin
      if cardinal(x) > 1 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..1');
      if cardinal(y) > 1 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..1');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*2 + y) * 8 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: double read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr2x2d read new Mtr2x2d(1.0, 0.0, 0.0, 1.0);
    
    public property Row0: Vec2d read new Vec2d(self.val00, self.val01) write begin self.val00 := value.val0; self.val01 := value.val1; end;
    public property Row1: Vec2d read new Vec2d(self.val10, self.val11) write begin self.val10 := value.val0; self.val11 := value.val1; end;
    public property Row[y: integer]: Vec2d read y=0?Row0:y=1?Row1:Arr&<Vec2d>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..1');
    end;
    
    public property Col0: Vec2d read new Vec2d(self.val00, self.val10) write begin self.val00 := value.val0; self.val10 := value.val1; end;
    public property Col1: Vec2d read new Vec2d(self.val01, self.val11) write begin self.val01 := value.val0; self.val11 := value.val1; end;
    public property Col[x: integer]: Vec2d read x=0?Col0:x=1?Col1:Arr&<Vec2d>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..1');
    end;
    
    public property ColPtr0: ^Vec2d read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec2d read pointer(IntPtr(pointer(@self)) + 16);
    public property ColPtr[x: integer]: ^Vec2d read pointer(IntPtr(pointer(@self)) + x*16);
    
    public static function Scale(k: double): Mtr2x2d := new Mtr2x2d(k, 0.0, 0.0, k);
    
    public static function Traslate(X: double): Mtr2x2d := new Mtr2x2d(1.0, X, 0.0, 1.0);
    public static function TraslateTransposed(X: double): Mtr2x2d := new Mtr2x2d(1.0, 0.0, X, 1.0);
    
    public static function RotateXYcw(rot: double): Mtr2x2d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr2x2d(
         cr, +sr,
        -sr,  cr
      );
    end;
    public static function RotateXYccw(rot: double): Mtr2x2d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr2x2d(
         cr, -sr,
        +sr,  cr
      );
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[2,2];
      for var y := 0 to 2-1 do
        for var x := 0 to 2-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*2 + 4; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr2x2d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr2x2d; v: Vec2d): Vec2d := new Vec2d(m.val00*v.val0+m.val01*v.val1, m.val10*v.val0+m.val11*v.val1);
    public static function operator*(v: Vec2d; m: Mtr2x2d): Vec2d := new Vec2d(m.val00*v.val0+m.val10*v.val1, m.val01*v.val0+m.val11*v.val1);
    
    public static function operator implicit(m: Mtr2x2f): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    public static function operator implicit(m: Mtr2x2d): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    public static function operator implicit(m: Mtr2x2d): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x4f): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    public static function operator implicit(m: Mtr2x2d): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3f): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    public static function operator implicit(m: Mtr2x2d): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0);
    
    public static function operator implicit(m: Mtr3x2f): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    public static function operator implicit(m: Mtr2x2d): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x4f): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    public static function operator implicit(m: Mtr2x2d): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x2f): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    public static function operator implicit(m: Mtr2x2d): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr3x4f): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    public static function operator implicit(m: Mtr2x2d): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x3f): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    public static function operator implicit(m: Mtr2x2d): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    
  end;
  Mtr2d = Mtr2x2d;
  
  Mtr3x3d = record
    public val00, val10, val20: double;
    public val01, val11, val21: double;
    public val02, val12, val22: double;
    
    public constructor(val00, val01, val02, val10, val11, val12, val20, val21, val22: double);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val02 := val02;
      self.val10 := val10;
      self.val11 := val11;
      self.val12 := val12;
      self.val20 := val20;
      self.val21 := val21;
      self.val22 := val22;
    end;
    
    private function GetValAt(y,x: integer): double;
    begin
      if cardinal(x) > 2 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..2');
      if cardinal(y) > 2 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..2');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*3 + y) * 8 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: double);
    begin
      if cardinal(x) > 2 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..2');
      if cardinal(y) > 2 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..2');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*3 + y) * 8 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: double read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr3x3d read new Mtr3x3d(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);
    
    public property Row0: Vec3d read new Vec3d(self.val00, self.val01, self.val02) write begin self.val00 := value.val0; self.val01 := value.val1; self.val02 := value.val2; end;
    public property Row1: Vec3d read new Vec3d(self.val10, self.val11, self.val12) write begin self.val10 := value.val0; self.val11 := value.val1; self.val12 := value.val2; end;
    public property Row2: Vec3d read new Vec3d(self.val20, self.val21, self.val22) write begin self.val20 := value.val0; self.val21 := value.val1; self.val22 := value.val2; end;
    public property Row[y: integer]: Vec3d read y=0?Row0:y=1?Row1:y=2?Row2:Arr&<Vec3d>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      2: Row2 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..2');
    end;
    
    public property Col0: Vec3d read new Vec3d(self.val00, self.val10, self.val20) write begin self.val00 := value.val0; self.val10 := value.val1; self.val20 := value.val2; end;
    public property Col1: Vec3d read new Vec3d(self.val01, self.val11, self.val21) write begin self.val01 := value.val0; self.val11 := value.val1; self.val21 := value.val2; end;
    public property Col2: Vec3d read new Vec3d(self.val02, self.val12, self.val22) write begin self.val02 := value.val0; self.val12 := value.val1; self.val22 := value.val2; end;
    public property Col[x: integer]: Vec3d read x=0?Col0:x=1?Col1:x=2?Col2:Arr&<Vec3d>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      2: Col2 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..2');
    end;
    
    public property ColPtr0: ^Vec3d read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec3d read pointer(IntPtr(pointer(@self)) + 24);
    public property ColPtr2: ^Vec3d read pointer(IntPtr(pointer(@self)) + 48);
    public property ColPtr[x: integer]: ^Vec3d read pointer(IntPtr(pointer(@self)) + x*24);
    
    public static function Scale(k: double): Mtr3x3d := new Mtr3x3d(k, 0.0, 0.0, 0.0, k, 0.0, 0.0, 0.0, k);
    
    public static function Traslate(X, Y: double): Mtr3x3d := new Mtr3x3d(1.0, 0.0, X, 0.0, 1.0, Y, 0.0, 0.0, 1.0);
    public static function TraslateTransposed(X, Y: double): Mtr3x3d := new Mtr3x3d(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, X, Y, 1.0);
    
    public static function RotateXYcw(rot: double): Mtr3x3d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr3x3d(
         cr, +sr, 0.0,
        -sr,  cr, 0.0,
        0.0, 0.0, 1.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr3x3d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr3x3d(
         cr, -sr, 0.0,
        +sr,  cr, 0.0,
        0.0, 0.0, 1.0
      );
    end;
    
    public static function RotateYZcw(rot: double): Mtr3x3d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr3x3d(
        1.0, 0.0, 0.0,
        0.0,  cr, +sr,
        0.0, -sr,  cr
      );
    end;
    public static function RotateYZccw(rot: double): Mtr3x3d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr3x3d(
        1.0, 0.0, 0.0,
        0.0,  cr, -sr,
        0.0, +sr,  cr
      );
    end;
    
    public static function RotateZXcw(rot: double): Mtr3x3d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr3x3d(
         cr, 0.0, -sr,
        0.0, 1.0, 0.0,
        +sr, 0.0,  cr
      );
    end;
    public static function RotateZXccw(rot: double): Mtr3x3d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr3x3d(
         cr, 0.0, +sr,
        0.0, 1.0, 0.0,
        -sr, 0.0,  cr
      );
    end;
    
    public static function Rotate3Dcw(u: Vec3d; rot: double): Mtr3x3d;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := -k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := -k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := -k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
    end;
    
    public static function Rotate3Dccw(u: Vec3d; rot: double): Mtr3x3d;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := -k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := -k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := -k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[3,3];
      for var y := 0 to 3-1 do
        for var x := 0 to 3-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*3 + 6; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[2,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr3x3d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr3x3d; v: Vec3d): Vec3d := new Vec3d(m.val00*v.val0+m.val01*v.val1+m.val02*v.val2, m.val10*v.val0+m.val11*v.val1+m.val12*v.val2, m.val20*v.val0+m.val21*v.val1+m.val22*v.val2);
    public static function operator*(v: Vec3d; m: Mtr3x3d): Vec3d := new Vec3d(m.val00*v.val0+m.val10*v.val1+m.val20*v.val2, m.val01*v.val0+m.val11*v.val1+m.val21*v.val2, m.val02*v.val0+m.val12*v.val1+m.val22*v.val2);
    
    public static function operator implicit(m: Mtr2x2f): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x3d): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22);
    public static function operator implicit(m: Mtr3x3d): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22);
    
    public static function operator implicit(m: Mtr4x4f): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22);
    public static function operator implicit(m: Mtr3x3d): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3f): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x3d): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    
    public static function operator implicit(m: Mtr3x2f): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0);
    public static function operator implicit(m: Mtr3x3d): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    
    public static function operator implicit(m: Mtr2x4f): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x3d): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0);
    
    public static function operator implicit(m: Mtr4x2f): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0);
    public static function operator implicit(m: Mtr3x3d): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr3x4f): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22);
    public static function operator implicit(m: Mtr3x3d): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0);
    
    public static function operator implicit(m: Mtr4x3f): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22);
    public static function operator implicit(m: Mtr3x3d): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x2d): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x3d): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    
  end;
  Mtr3d = Mtr3x3d;
  
  Mtr4x4d = record
    public val00, val10, val20, val30: double;
    public val01, val11, val21, val31: double;
    public val02, val12, val22, val32: double;
    public val03, val13, val23, val33: double;
    
    public constructor(val00, val01, val02, val03, val10, val11, val12, val13, val20, val21, val22, val23, val30, val31, val32, val33: double);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val02 := val02;
      self.val03 := val03;
      self.val10 := val10;
      self.val11 := val11;
      self.val12 := val12;
      self.val13 := val13;
      self.val20 := val20;
      self.val21 := val21;
      self.val22 := val22;
      self.val23 := val23;
      self.val30 := val30;
      self.val31 := val31;
      self.val32 := val32;
      self.val33 := val33;
    end;
    
    private function GetValAt(y,x: integer): double;
    begin
      if cardinal(x) > 3 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..3');
      if cardinal(y) > 3 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..3');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*4 + y) * 8 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: double);
    begin
      if cardinal(x) > 3 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..3');
      if cardinal(y) > 3 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..3');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*4 + y) * 8 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: double read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr4x4d read new Mtr4x4d(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);
    
    public property Row0: Vec4d read new Vec4d(self.val00, self.val01, self.val02, self.val03) write begin self.val00 := value.val0; self.val01 := value.val1; self.val02 := value.val2; self.val03 := value.val3; end;
    public property Row1: Vec4d read new Vec4d(self.val10, self.val11, self.val12, self.val13) write begin self.val10 := value.val0; self.val11 := value.val1; self.val12 := value.val2; self.val13 := value.val3; end;
    public property Row2: Vec4d read new Vec4d(self.val20, self.val21, self.val22, self.val23) write begin self.val20 := value.val0; self.val21 := value.val1; self.val22 := value.val2; self.val23 := value.val3; end;
    public property Row3: Vec4d read new Vec4d(self.val30, self.val31, self.val32, self.val33) write begin self.val30 := value.val0; self.val31 := value.val1; self.val32 := value.val2; self.val33 := value.val3; end;
    public property Row[y: integer]: Vec4d read y=0?Row0:y=1?Row1:y=2?Row2:y=3?Row3:Arr&<Vec4d>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      2: Row2 := value;
      3: Row3 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..3');
    end;
    
    public property Col0: Vec4d read new Vec4d(self.val00, self.val10, self.val20, self.val30) write begin self.val00 := value.val0; self.val10 := value.val1; self.val20 := value.val2; self.val30 := value.val3; end;
    public property Col1: Vec4d read new Vec4d(self.val01, self.val11, self.val21, self.val31) write begin self.val01 := value.val0; self.val11 := value.val1; self.val21 := value.val2; self.val31 := value.val3; end;
    public property Col2: Vec4d read new Vec4d(self.val02, self.val12, self.val22, self.val32) write begin self.val02 := value.val0; self.val12 := value.val1; self.val22 := value.val2; self.val32 := value.val3; end;
    public property Col3: Vec4d read new Vec4d(self.val03, self.val13, self.val23, self.val33) write begin self.val03 := value.val0; self.val13 := value.val1; self.val23 := value.val2; self.val33 := value.val3; end;
    public property Col[x: integer]: Vec4d read x=0?Col0:x=1?Col1:x=2?Col2:x=3?Col3:Arr&<Vec4d>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      2: Col2 := value;
      3: Col3 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..3');
    end;
    
    public property ColPtr0: ^Vec4d read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec4d read pointer(IntPtr(pointer(@self)) + 32);
    public property ColPtr2: ^Vec4d read pointer(IntPtr(pointer(@self)) + 64);
    public property ColPtr3: ^Vec4d read pointer(IntPtr(pointer(@self)) + 96);
    public property ColPtr[x: integer]: ^Vec4d read pointer(IntPtr(pointer(@self)) + x*32);
    
    public static function Scale(k: double): Mtr4x4d := new Mtr4x4d(k, 0.0, 0.0, 0.0, 0.0, k, 0.0, 0.0, 0.0, 0.0, k, 0.0, 0.0, 0.0, 0.0, k);
    
    public static function Traslate(X, Y, Z: double): Mtr4x4d := new Mtr4x4d(1.0, 0.0, 0.0, X, 0.0, 1.0, 0.0, Y, 0.0, 0.0, 1.0, Z, 0.0, 0.0, 0.0, 1.0);
    public static function TraslateTransposed(X, Y, Z: double): Mtr4x4d := new Mtr4x4d(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, X, Y, Z, 1.0);
    
    public static function RotateXYcw(rot: double): Mtr4x4d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr4x4d(
         cr, +sr, 0.0, 0.0,
        -sr,  cr, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0,
        0.0, 0.0, 0.0, 1.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr4x4d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr4x4d(
         cr, -sr, 0.0, 0.0,
        +sr,  cr, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0,
        0.0, 0.0, 0.0, 1.0
      );
    end;
    
    public static function RotateYZcw(rot: double): Mtr4x4d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr4x4d(
        1.0, 0.0, 0.0, 0.0,
        0.0,  cr, +sr, 0.0,
        0.0, -sr,  cr, 0.0,
        0.0, 0.0, 0.0, 1.0
      );
    end;
    public static function RotateYZccw(rot: double): Mtr4x4d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr4x4d(
        1.0, 0.0, 0.0, 0.0,
        0.0,  cr, -sr, 0.0,
        0.0, +sr,  cr, 0.0,
        0.0, 0.0, 0.0, 1.0
      );
    end;
    
    public static function RotateZXcw(rot: double): Mtr4x4d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr4x4d(
         cr, 0.0, -sr, 0.0,
        0.0, 1.0, 0.0, 0.0,
        +sr, 0.0,  cr, 0.0,
        0.0, 0.0, 0.0, 1.0
      );
    end;
    public static function RotateZXccw(rot: double): Mtr4x4d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr4x4d(
         cr, 0.0, +sr, 0.0,
        0.0, 1.0, 0.0, 0.0,
        -sr, 0.0,  cr, 0.0,
        0.0, 0.0, 0.0, 1.0
      );
    end;
    
    public static function Rotate3Dcw(u: Vec3d; rot: double): Mtr4x4d;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := -k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := -k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := -k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
      Result.val33 := 1;
    end;
    
    public static function Rotate3Dccw(u: Vec3d; rot: double): Mtr4x4d;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := -k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := -k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := -k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
      Result.val33 := 1;
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[4,4];
      for var y := 0 to 4-1 do
        for var x := 0 to 4-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*4 + 8; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[2,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[3,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[3,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[3,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[3,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr4x4d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr4x4d; v: Vec4d): Vec4d := new Vec4d(m.val00*v.val0+m.val01*v.val1+m.val02*v.val2+m.val03*v.val3, m.val10*v.val0+m.val11*v.val1+m.val12*v.val2+m.val13*v.val3, m.val20*v.val0+m.val21*v.val1+m.val22*v.val2+m.val23*v.val3, m.val30*v.val0+m.val31*v.val1+m.val32*v.val2+m.val33*v.val3);
    public static function operator*(v: Vec4d; m: Mtr4x4d): Vec4d := new Vec4d(m.val00*v.val0+m.val10*v.val1+m.val20*v.val2+m.val30*v.val3, m.val01*v.val0+m.val11*v.val1+m.val21*v.val2+m.val31*v.val3, m.val02*v.val0+m.val12*v.val1+m.val22*v.val2+m.val32*v.val3, m.val03*v.val0+m.val13*v.val1+m.val23*v.val2+m.val33*v.val3);
    
    public static function operator implicit(m: Mtr2x2f): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x4d): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x4d): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22);
    
    public static function operator implicit(m: Mtr4x4f): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, m.val20, m.val21, m.val22, m.val23, m.val30, m.val31, m.val32, m.val33);
    public static function operator implicit(m: Mtr4x4d): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, m.val20, m.val21, m.val22, m.val23, m.val30, m.val31, m.val32, m.val33);
    
    public static function operator implicit(m: Mtr2x3f): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x4d): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    
    public static function operator implicit(m: Mtr3x2f): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x4d): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    
    public static function operator implicit(m: Mtr2x4f): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x4d): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13);
    
    public static function operator implicit(m: Mtr4x2f): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0, m.val30, m.val31, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x4d): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, m.val30, m.val31);
    
    public static function operator implicit(m: Mtr3x4f): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, m.val20, m.val21, m.val22, m.val23, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x4d): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, m.val20, m.val21, m.val22, m.val23);
    
    public static function operator implicit(m: Mtr4x3f): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0, m.val30, m.val31, m.val32, 0.0);
    public static function operator implicit(m: Mtr4x4d): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22, m.val30, m.val31, m.val32);
    
    public static function operator implicit(m: Mtr2x2d): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x4d): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3d): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x4d): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22);
    
  end;
  Mtr4d = Mtr4x4d;
  
  Mtr2x3d = record
    public val00, val10: double;
    public val01, val11: double;
    public val02, val12: double;
    
    public constructor(val00, val01, val02, val10, val11, val12: double);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val02 := val02;
      self.val10 := val10;
      self.val11 := val11;
      self.val12 := val12;
    end;
    
    private function GetValAt(y,x: integer): double;
    begin
      if cardinal(x) > 2 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..2');
      if cardinal(y) > 1 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..1');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*2 + y) * 8 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: double);
    begin
      if cardinal(x) > 2 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..2');
      if cardinal(y) > 1 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..1');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*2 + y) * 8 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: double read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr2x3d read new Mtr2x3d(1.0, 0.0, 0.0, 0.0, 1.0, 0.0);
    
    public property Row0: Vec3d read new Vec3d(self.val00, self.val01, self.val02) write begin self.val00 := value.val0; self.val01 := value.val1; self.val02 := value.val2; end;
    public property Row1: Vec3d read new Vec3d(self.val10, self.val11, self.val12) write begin self.val10 := value.val0; self.val11 := value.val1; self.val12 := value.val2; end;
    public property Row[y: integer]: Vec3d read y=0?Row0:y=1?Row1:Arr&<Vec3d>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..1');
    end;
    
    public property Col0: Vec2d read new Vec2d(self.val00, self.val10) write begin self.val00 := value.val0; self.val10 := value.val1; end;
    public property Col1: Vec2d read new Vec2d(self.val01, self.val11) write begin self.val01 := value.val0; self.val11 := value.val1; end;
    public property Col2: Vec2d read new Vec2d(self.val02, self.val12) write begin self.val02 := value.val0; self.val12 := value.val1; end;
    public property Col[x: integer]: Vec2d read x=0?Col0:x=1?Col1:x=2?Col2:Arr&<Vec2d>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      2: Col2 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..2');
    end;
    
    public property ColPtr0: ^Vec3d read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec3d read pointer(IntPtr(pointer(@self)) + 16);
    public property ColPtr[x: integer]: ^Vec3d read pointer(IntPtr(pointer(@self)) + x*16);
    
    public static function Scale(k: double): Mtr2x3d := new Mtr2x3d(k, 0.0, 0.0, 0.0, k, 0.0);
    
    public static function Traslate(X, Y: double): Mtr2x3d := new Mtr2x3d(1.0, 0.0, X, 0.0, 1.0, Y);
    public static function TraslateTransposed(X: double): Mtr2x3d := new Mtr2x3d(1.0, 0.0, 0.0, X, 1.0, 0.0);
    
    public static function RotateXYcw(rot: double): Mtr2x3d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr2x3d(
         cr, +sr, 0.0,
        -sr,  cr, 0.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr2x3d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr2x3d(
         cr, -sr, 0.0,
        +sr,  cr, 0.0
      );
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[2,3];
      for var y := 0 to 2-1 do
        for var x := 0 to 3-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*3 + 6; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr2x3d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr2x3d; v: Vec3d): Vec2d := new Vec2d(m.val00*v.val0+m.val01*v.val1+m.val02*v.val2, m.val10*v.val0+m.val11*v.val1+m.val12*v.val2);
    public static function operator*(v: Vec2d; m: Mtr2x3d): Vec3d := new Vec3d(m.val00*v.val0+m.val10*v.val1, m.val01*v.val0+m.val11*v.val1, m.val02*v.val0+m.val12*v.val1);
    
    public static function operator implicit(m: Mtr2x2f): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0);
    public static function operator implicit(m: Mtr2x3d): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    public static function operator implicit(m: Mtr2x3d): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x4f): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    public static function operator implicit(m: Mtr2x3d): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3f): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    public static function operator implicit(m: Mtr2x3d): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    
    public static function operator implicit(m: Mtr3x2f): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0);
    public static function operator implicit(m: Mtr2x3d): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x4f): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    public static function operator implicit(m: Mtr2x3d): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0);
    
    public static function operator implicit(m: Mtr4x2f): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0);
    public static function operator implicit(m: Mtr2x3d): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr3x4f): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    public static function operator implicit(m: Mtr2x3d): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x3f): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    public static function operator implicit(m: Mtr2x3d): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x2d): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0);
    public static function operator implicit(m: Mtr2x3d): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3d): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    public static function operator implicit(m: Mtr2x3d): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x4d): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    public static function operator implicit(m: Mtr2x3d): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    
  end;
  
  Mtr3x2d = record
    public val00, val10, val20: double;
    public val01, val11, val21: double;
    
    public constructor(val00, val01, val10, val11, val20, val21: double);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val10 := val10;
      self.val11 := val11;
      self.val20 := val20;
      self.val21 := val21;
    end;
    
    private function GetValAt(y,x: integer): double;
    begin
      if cardinal(x) > 1 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..1');
      if cardinal(y) > 2 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..2');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*3 + y) * 8 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: double);
    begin
      if cardinal(x) > 1 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..1');
      if cardinal(y) > 2 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..2');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*3 + y) * 8 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: double read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr3x2d read new Mtr3x2d(1.0, 0.0, 0.0, 1.0, 0.0, 0.0);
    
    public property Row0: Vec2d read new Vec2d(self.val00, self.val01) write begin self.val00 := value.val0; self.val01 := value.val1; end;
    public property Row1: Vec2d read new Vec2d(self.val10, self.val11) write begin self.val10 := value.val0; self.val11 := value.val1; end;
    public property Row2: Vec2d read new Vec2d(self.val20, self.val21) write begin self.val20 := value.val0; self.val21 := value.val1; end;
    public property Row[y: integer]: Vec2d read y=0?Row0:y=1?Row1:y=2?Row2:Arr&<Vec2d>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      2: Row2 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..2');
    end;
    
    public property Col0: Vec3d read new Vec3d(self.val00, self.val10, self.val20) write begin self.val00 := value.val0; self.val10 := value.val1; self.val20 := value.val2; end;
    public property Col1: Vec3d read new Vec3d(self.val01, self.val11, self.val21) write begin self.val01 := value.val0; self.val11 := value.val1; self.val21 := value.val2; end;
    public property Col[x: integer]: Vec3d read x=0?Col0:x=1?Col1:Arr&<Vec3d>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..1');
    end;
    
    public property ColPtr0: ^Vec2d read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec2d read pointer(IntPtr(pointer(@self)) + 24);
    public property ColPtr2: ^Vec2d read pointer(IntPtr(pointer(@self)) + 48);
    public property ColPtr[x: integer]: ^Vec2d read pointer(IntPtr(pointer(@self)) + x*24);
    
    public static function Scale(k: double): Mtr3x2d := new Mtr3x2d(k, 0.0, 0.0, k, 0.0, 0.0);
    
    public static function Traslate(X: double): Mtr3x2d := new Mtr3x2d(1.0, X, 0.0, 1.0, 0.0, 0.0);
    public static function TraslateTransposed(X, Y: double): Mtr3x2d := new Mtr3x2d(1.0, 0.0, 0.0, 1.0, X, Y);
    
    public static function RotateXYcw(rot: double): Mtr3x2d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr3x2d(
         cr, +sr,
        -sr,  cr,
        0.0, 0.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr3x2d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr3x2d(
         cr, -sr,
        +sr,  cr,
        0.0, 0.0
      );
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[3,2];
      for var y := 0 to 3-1 do
        for var x := 0 to 2-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*2 + 4; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[2,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr3x2d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr3x2d; v: Vec2d): Vec3d := new Vec3d(m.val00*v.val0+m.val01*v.val1, m.val10*v.val0+m.val11*v.val1, m.val20*v.val0+m.val21*v.val1);
    public static function operator*(v: Vec3d; m: Mtr3x2d): Vec2d := new Vec2d(m.val00*v.val0+m.val10*v.val1+m.val20*v.val2, m.val01*v.val0+m.val11*v.val1+m.val21*v.val2);
    
    public static function operator implicit(m: Mtr2x2f): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x2d): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    public static function operator implicit(m: Mtr3x2d): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0);
    
    public static function operator implicit(m: Mtr4x4f): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    public static function operator implicit(m: Mtr3x2d): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3f): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x2d): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0);
    
    public static function operator implicit(m: Mtr3x2f): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    public static function operator implicit(m: Mtr3x2d): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    
    public static function operator implicit(m: Mtr2x4f): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x2d): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x2f): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    public static function operator implicit(m: Mtr3x2d): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr3x4f): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    public static function operator implicit(m: Mtr3x2d): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x3f): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    public static function operator implicit(m: Mtr3x2d): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x2d): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x2d): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3d): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    public static function operator implicit(m: Mtr3x2d): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0);
    
    public static function operator implicit(m: Mtr4x4d): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    public static function operator implicit(m: Mtr3x2d): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3d): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x2d): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0);
    
  end;
  
  Mtr2x4d = record
    public val00, val10: double;
    public val01, val11: double;
    public val02, val12: double;
    public val03, val13: double;
    
    public constructor(val00, val01, val02, val03, val10, val11, val12, val13: double);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val02 := val02;
      self.val03 := val03;
      self.val10 := val10;
      self.val11 := val11;
      self.val12 := val12;
      self.val13 := val13;
    end;
    
    private function GetValAt(y,x: integer): double;
    begin
      if cardinal(x) > 3 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..3');
      if cardinal(y) > 1 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..1');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*2 + y) * 8 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: double);
    begin
      if cardinal(x) > 3 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..3');
      if cardinal(y) > 1 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..1');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*2 + y) * 8 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: double read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr2x4d read new Mtr2x4d(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0);
    
    public property Row0: Vec4d read new Vec4d(self.val00, self.val01, self.val02, self.val03) write begin self.val00 := value.val0; self.val01 := value.val1; self.val02 := value.val2; self.val03 := value.val3; end;
    public property Row1: Vec4d read new Vec4d(self.val10, self.val11, self.val12, self.val13) write begin self.val10 := value.val0; self.val11 := value.val1; self.val12 := value.val2; self.val13 := value.val3; end;
    public property Row[y: integer]: Vec4d read y=0?Row0:y=1?Row1:Arr&<Vec4d>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..1');
    end;
    
    public property Col0: Vec2d read new Vec2d(self.val00, self.val10) write begin self.val00 := value.val0; self.val10 := value.val1; end;
    public property Col1: Vec2d read new Vec2d(self.val01, self.val11) write begin self.val01 := value.val0; self.val11 := value.val1; end;
    public property Col2: Vec2d read new Vec2d(self.val02, self.val12) write begin self.val02 := value.val0; self.val12 := value.val1; end;
    public property Col3: Vec2d read new Vec2d(self.val03, self.val13) write begin self.val03 := value.val0; self.val13 := value.val1; end;
    public property Col[x: integer]: Vec2d read x=0?Col0:x=1?Col1:x=2?Col2:x=3?Col3:Arr&<Vec2d>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      2: Col2 := value;
      3: Col3 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..3');
    end;
    
    public property ColPtr0: ^Vec4d read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec4d read pointer(IntPtr(pointer(@self)) + 16);
    public property ColPtr[x: integer]: ^Vec4d read pointer(IntPtr(pointer(@self)) + x*16);
    
    public static function Scale(k: double): Mtr2x4d := new Mtr2x4d(k, 0.0, 0.0, 0.0, 0.0, k, 0.0, 0.0);
    
    public static function Traslate(X, Y: double): Mtr2x4d := new Mtr2x4d(1.0, 0.0, 0.0, X, 0.0, 1.0, 0.0, Y);
    public static function TraslateTransposed(X: double): Mtr2x4d := new Mtr2x4d(1.0, 0.0, 0.0, 0.0, X, 1.0, 0.0, 0.0);
    
    public static function RotateXYcw(rot: double): Mtr2x4d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr2x4d(
         cr, +sr, 0.0, 0.0,
        -sr,  cr, 0.0, 0.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr2x4d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr2x4d(
         cr, -sr, 0.0, 0.0,
        +sr,  cr, 0.0, 0.0
      );
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[2,4];
      for var y := 0 to 2-1 do
        for var x := 0 to 4-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*4 + 8; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr2x4d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr2x4d; v: Vec4d): Vec2d := new Vec2d(m.val00*v.val0+m.val01*v.val1+m.val02*v.val2+m.val03*v.val3, m.val10*v.val0+m.val11*v.val1+m.val12*v.val2+m.val13*v.val3);
    public static function operator*(v: Vec2d; m: Mtr2x4d): Vec4d := new Vec4d(m.val00*v.val0+m.val10*v.val1, m.val01*v.val0+m.val11*v.val1, m.val02*v.val0+m.val12*v.val1, m.val03*v.val0+m.val13*v.val1);
    
    public static function operator implicit(m: Mtr2x2f): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0);
    public static function operator implicit(m: Mtr2x4d): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0);
    public static function operator implicit(m: Mtr2x4d): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x4f): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13);
    public static function operator implicit(m: Mtr2x4d): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3f): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0);
    public static function operator implicit(m: Mtr2x4d): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    
    public static function operator implicit(m: Mtr3x2f): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0);
    public static function operator implicit(m: Mtr2x4d): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x4f): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13);
    public static function operator implicit(m: Mtr2x4d): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13);
    
    public static function operator implicit(m: Mtr4x2f): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0);
    public static function operator implicit(m: Mtr2x4d): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr3x4f): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13);
    public static function operator implicit(m: Mtr2x4d): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x3f): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0);
    public static function operator implicit(m: Mtr2x4d): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x2d): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0);
    public static function operator implicit(m: Mtr2x4d): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3d): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0);
    public static function operator implicit(m: Mtr2x4d): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x4d): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13);
    public static function operator implicit(m: Mtr2x4d): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3d): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0);
    public static function operator implicit(m: Mtr2x4d): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    
    public static function operator implicit(m: Mtr3x2d): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0);
    public static function operator implicit(m: Mtr2x4d): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0);
    
  end;
  
  Mtr4x2d = record
    public val00, val10, val20, val30: double;
    public val01, val11, val21, val31: double;
    
    public constructor(val00, val01, val10, val11, val20, val21, val30, val31: double);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val10 := val10;
      self.val11 := val11;
      self.val20 := val20;
      self.val21 := val21;
      self.val30 := val30;
      self.val31 := val31;
    end;
    
    private function GetValAt(y,x: integer): double;
    begin
      if cardinal(x) > 1 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..1');
      if cardinal(y) > 3 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..3');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*4 + y) * 8 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: double);
    begin
      if cardinal(x) > 1 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..1');
      if cardinal(y) > 3 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..3');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*4 + y) * 8 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: double read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr4x2d read new Mtr4x2d(1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0);
    
    public property Row0: Vec2d read new Vec2d(self.val00, self.val01) write begin self.val00 := value.val0; self.val01 := value.val1; end;
    public property Row1: Vec2d read new Vec2d(self.val10, self.val11) write begin self.val10 := value.val0; self.val11 := value.val1; end;
    public property Row2: Vec2d read new Vec2d(self.val20, self.val21) write begin self.val20 := value.val0; self.val21 := value.val1; end;
    public property Row3: Vec2d read new Vec2d(self.val30, self.val31) write begin self.val30 := value.val0; self.val31 := value.val1; end;
    public property Row[y: integer]: Vec2d read y=0?Row0:y=1?Row1:y=2?Row2:y=3?Row3:Arr&<Vec2d>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      2: Row2 := value;
      3: Row3 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..3');
    end;
    
    public property Col0: Vec4d read new Vec4d(self.val00, self.val10, self.val20, self.val30) write begin self.val00 := value.val0; self.val10 := value.val1; self.val20 := value.val2; self.val30 := value.val3; end;
    public property Col1: Vec4d read new Vec4d(self.val01, self.val11, self.val21, self.val31) write begin self.val01 := value.val0; self.val11 := value.val1; self.val21 := value.val2; self.val31 := value.val3; end;
    public property Col[x: integer]: Vec4d read x=0?Col0:x=1?Col1:Arr&<Vec4d>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..1');
    end;
    
    public property ColPtr0: ^Vec2d read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec2d read pointer(IntPtr(pointer(@self)) + 32);
    public property ColPtr2: ^Vec2d read pointer(IntPtr(pointer(@self)) + 64);
    public property ColPtr3: ^Vec2d read pointer(IntPtr(pointer(@self)) + 96);
    public property ColPtr[x: integer]: ^Vec2d read pointer(IntPtr(pointer(@self)) + x*32);
    
    public static function Scale(k: double): Mtr4x2d := new Mtr4x2d(k, 0.0, 0.0, k, 0.0, 0.0, 0.0, 0.0);
    
    public static function Traslate(X: double): Mtr4x2d := new Mtr4x2d(1.0, X, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0);
    public static function TraslateTransposed(X, Y: double): Mtr4x2d := new Mtr4x2d(1.0, 0.0, 0.0, 1.0, 0.0, 0.0, X, Y);
    
    public static function RotateXYcw(rot: double): Mtr4x2d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr4x2d(
         cr, +sr,
        -sr,  cr,
        0.0, 0.0,
        0.0, 0.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr4x2d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr4x2d(
         cr, -sr,
        +sr,  cr,
        0.0, 0.0,
        0.0, 0.0
      );
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[4,2];
      for var y := 0 to 4-1 do
        for var x := 0 to 2-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*2 + 4; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[2,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[3,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[3,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr4x2d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr4x2d; v: Vec2d): Vec4d := new Vec4d(m.val00*v.val0+m.val01*v.val1, m.val10*v.val0+m.val11*v.val1, m.val20*v.val0+m.val21*v.val1, m.val30*v.val0+m.val31*v.val1);
    public static function operator*(v: Vec4d; m: Mtr4x2d): Vec2d := new Vec2d(m.val00*v.val0+m.val10*v.val1+m.val20*v.val2+m.val30*v.val3, m.val01*v.val0+m.val11*v.val1+m.val21*v.val2+m.val31*v.val3);
    
    public static function operator implicit(m: Mtr2x2f): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2d): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2d): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0);
    
    public static function operator implicit(m: Mtr4x4f): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, m.val30, m.val31);
    public static function operator implicit(m: Mtr4x2d): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0, m.val30, m.val31, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3f): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2d): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0);
    
    public static function operator implicit(m: Mtr3x2f): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2d): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    
    public static function operator implicit(m: Mtr2x4f): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2d): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x2f): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, m.val30, m.val31);
    public static function operator implicit(m: Mtr4x2d): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, m.val30, m.val31);
    
    public static function operator implicit(m: Mtr3x4f): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2d): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x3f): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, m.val30, m.val31);
    public static function operator implicit(m: Mtr4x2d): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0, m.val30, m.val31, 0.0);
    
    public static function operator implicit(m: Mtr2x2d): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2d): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3d): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2d): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0);
    
    public static function operator implicit(m: Mtr4x4d): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, m.val30, m.val31);
    public static function operator implicit(m: Mtr4x2d): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0, m.val30, m.val31, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3d): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2d): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0);
    
    public static function operator implicit(m: Mtr3x2d): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2d): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    
    public static function operator implicit(m: Mtr2x4d): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2d): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0);
    
  end;
  
  Mtr3x4d = record
    public val00, val10, val20: double;
    public val01, val11, val21: double;
    public val02, val12, val22: double;
    public val03, val13, val23: double;
    
    public constructor(val00, val01, val02, val03, val10, val11, val12, val13, val20, val21, val22, val23: double);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val02 := val02;
      self.val03 := val03;
      self.val10 := val10;
      self.val11 := val11;
      self.val12 := val12;
      self.val13 := val13;
      self.val20 := val20;
      self.val21 := val21;
      self.val22 := val22;
      self.val23 := val23;
    end;
    
    private function GetValAt(y,x: integer): double;
    begin
      if cardinal(x) > 3 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..3');
      if cardinal(y) > 2 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..2');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*3 + y) * 8 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: double);
    begin
      if cardinal(x) > 3 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..3');
      if cardinal(y) > 2 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..2');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*3 + y) * 8 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: double read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr3x4d read new Mtr3x4d(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);
    
    public property Row0: Vec4d read new Vec4d(self.val00, self.val01, self.val02, self.val03) write begin self.val00 := value.val0; self.val01 := value.val1; self.val02 := value.val2; self.val03 := value.val3; end;
    public property Row1: Vec4d read new Vec4d(self.val10, self.val11, self.val12, self.val13) write begin self.val10 := value.val0; self.val11 := value.val1; self.val12 := value.val2; self.val13 := value.val3; end;
    public property Row2: Vec4d read new Vec4d(self.val20, self.val21, self.val22, self.val23) write begin self.val20 := value.val0; self.val21 := value.val1; self.val22 := value.val2; self.val23 := value.val3; end;
    public property Row[y: integer]: Vec4d read y=0?Row0:y=1?Row1:y=2?Row2:Arr&<Vec4d>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      2: Row2 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..2');
    end;
    
    public property Col0: Vec3d read new Vec3d(self.val00, self.val10, self.val20) write begin self.val00 := value.val0; self.val10 := value.val1; self.val20 := value.val2; end;
    public property Col1: Vec3d read new Vec3d(self.val01, self.val11, self.val21) write begin self.val01 := value.val0; self.val11 := value.val1; self.val21 := value.val2; end;
    public property Col2: Vec3d read new Vec3d(self.val02, self.val12, self.val22) write begin self.val02 := value.val0; self.val12 := value.val1; self.val22 := value.val2; end;
    public property Col3: Vec3d read new Vec3d(self.val03, self.val13, self.val23) write begin self.val03 := value.val0; self.val13 := value.val1; self.val23 := value.val2; end;
    public property Col[x: integer]: Vec3d read x=0?Col0:x=1?Col1:x=2?Col2:x=3?Col3:Arr&<Vec3d>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      2: Col2 := value;
      3: Col3 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..3');
    end;
    
    public property ColPtr0: ^Vec4d read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec4d read pointer(IntPtr(pointer(@self)) + 24);
    public property ColPtr2: ^Vec4d read pointer(IntPtr(pointer(@self)) + 48);
    public property ColPtr[x: integer]: ^Vec4d read pointer(IntPtr(pointer(@self)) + x*24);
    
    public static function Scale(k: double): Mtr3x4d := new Mtr3x4d(k, 0.0, 0.0, 0.0, 0.0, k, 0.0, 0.0, 0.0, 0.0, k, 0.0);
    
    public static function Traslate(X, Y, Z: double): Mtr3x4d := new Mtr3x4d(1.0, 0.0, 0.0, X, 0.0, 1.0, 0.0, Y, 0.0, 0.0, 1.0, Z);
    public static function TraslateTransposed(X, Y: double): Mtr3x4d := new Mtr3x4d(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, X, Y, 1.0, 0.0);
    
    public static function RotateXYcw(rot: double): Mtr3x4d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr3x4d(
         cr, +sr, 0.0, 0.0,
        -sr,  cr, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr3x4d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr3x4d(
         cr, -sr, 0.0, 0.0,
        +sr,  cr, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0
      );
    end;
    
    public static function RotateYZcw(rot: double): Mtr3x4d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr3x4d(
        1.0, 0.0, 0.0, 0.0,
        0.0,  cr, +sr, 0.0,
        0.0, -sr,  cr, 0.0
      );
    end;
    public static function RotateYZccw(rot: double): Mtr3x4d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr3x4d(
        1.0, 0.0, 0.0, 0.0,
        0.0,  cr, -sr, 0.0,
        0.0, +sr,  cr, 0.0
      );
    end;
    
    public static function RotateZXcw(rot: double): Mtr3x4d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr3x4d(
         cr, 0.0, -sr, 0.0,
        0.0, 1.0, 0.0, 0.0,
        +sr, 0.0,  cr, 0.0
      );
    end;
    public static function RotateZXccw(rot: double): Mtr3x4d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr3x4d(
         cr, 0.0, +sr, 0.0,
        0.0, 1.0, 0.0, 0.0,
        -sr, 0.0,  cr, 0.0
      );
    end;
    
    public static function Rotate3Dcw(u: Vec3d; rot: double): Mtr3x4d;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := -k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := -k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := -k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
    end;
    
    public static function Rotate3Dccw(u: Vec3d; rot: double): Mtr3x4d;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := -k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := -k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := -k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[3,4];
      for var y := 0 to 3-1 do
        for var x := 0 to 4-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*4 + 8; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[2,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr3x4d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr3x4d; v: Vec4d): Vec3d := new Vec3d(m.val00*v.val0+m.val01*v.val1+m.val02*v.val2+m.val03*v.val3, m.val10*v.val0+m.val11*v.val1+m.val12*v.val2+m.val13*v.val3, m.val20*v.val0+m.val21*v.val1+m.val22*v.val2+m.val23*v.val3);
    public static function operator*(v: Vec3d; m: Mtr3x4d): Vec4d := new Vec4d(m.val00*v.val0+m.val10*v.val1+m.val20*v.val2, m.val01*v.val0+m.val11*v.val1+m.val21*v.val2, m.val02*v.val0+m.val12*v.val1+m.val22*v.val2, m.val03*v.val0+m.val13*v.val1+m.val23*v.val2);
    
    public static function operator implicit(m: Mtr2x2f): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4d): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0);
    public static function operator implicit(m: Mtr3x4d): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22);
    
    public static function operator implicit(m: Mtr4x4f): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, m.val20, m.val21, m.val22, m.val23);
    public static function operator implicit(m: Mtr3x4d): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, m.val20, m.val21, m.val22, m.val23, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3f): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4d): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    
    public static function operator implicit(m: Mtr3x2f): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4d): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    
    public static function operator implicit(m: Mtr2x4f): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4d): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13);
    
    public static function operator implicit(m: Mtr4x2f): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4d): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr3x4f): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, m.val20, m.val21, m.val22, m.val23);
    public static function operator implicit(m: Mtr3x4d): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, m.val20, m.val21, m.val22, m.val23);
    
    public static function operator implicit(m: Mtr4x3f): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0);
    public static function operator implicit(m: Mtr3x4d): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x2d): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4d): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3d): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0);
    public static function operator implicit(m: Mtr3x4d): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22);
    
    public static function operator implicit(m: Mtr4x4d): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, m.val20, m.val21, m.val22, m.val23);
    public static function operator implicit(m: Mtr3x4d): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, m.val20, m.val21, m.val22, m.val23, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3d): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4d): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    
    public static function operator implicit(m: Mtr3x2d): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4d): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    
    public static function operator implicit(m: Mtr2x4d): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4d): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13);
    
    public static function operator implicit(m: Mtr4x2d): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4d): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, 0.0, 0.0);
    
  end;
  
  Mtr4x3d = record
    public val00, val10, val20, val30: double;
    public val01, val11, val21, val31: double;
    public val02, val12, val22, val32: double;
    
    public constructor(val00, val01, val02, val10, val11, val12, val20, val21, val22, val30, val31, val32: double);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val02 := val02;
      self.val10 := val10;
      self.val11 := val11;
      self.val12 := val12;
      self.val20 := val20;
      self.val21 := val21;
      self.val22 := val22;
      self.val30 := val30;
      self.val31 := val31;
      self.val32 := val32;
    end;
    
    private function GetValAt(y,x: integer): double;
    begin
      if cardinal(x) > 2 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..2');
      if cardinal(y) > 3 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..3');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*4 + y) * 8 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: double);
    begin
      if cardinal(x) > 2 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..2');
      if cardinal(y) > 3 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..3');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*4 + y) * 8 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: double read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr4x3d read new Mtr4x3d(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0);
    
    public property Row0: Vec3d read new Vec3d(self.val00, self.val01, self.val02) write begin self.val00 := value.val0; self.val01 := value.val1; self.val02 := value.val2; end;
    public property Row1: Vec3d read new Vec3d(self.val10, self.val11, self.val12) write begin self.val10 := value.val0; self.val11 := value.val1; self.val12 := value.val2; end;
    public property Row2: Vec3d read new Vec3d(self.val20, self.val21, self.val22) write begin self.val20 := value.val0; self.val21 := value.val1; self.val22 := value.val2; end;
    public property Row3: Vec3d read new Vec3d(self.val30, self.val31, self.val32) write begin self.val30 := value.val0; self.val31 := value.val1; self.val32 := value.val2; end;
    public property Row[y: integer]: Vec3d read y=0?Row0:y=1?Row1:y=2?Row2:y=3?Row3:Arr&<Vec3d>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      2: Row2 := value;
      3: Row3 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..3');
    end;
    
    public property Col0: Vec4d read new Vec4d(self.val00, self.val10, self.val20, self.val30) write begin self.val00 := value.val0; self.val10 := value.val1; self.val20 := value.val2; self.val30 := value.val3; end;
    public property Col1: Vec4d read new Vec4d(self.val01, self.val11, self.val21, self.val31) write begin self.val01 := value.val0; self.val11 := value.val1; self.val21 := value.val2; self.val31 := value.val3; end;
    public property Col2: Vec4d read new Vec4d(self.val02, self.val12, self.val22, self.val32) write begin self.val02 := value.val0; self.val12 := value.val1; self.val22 := value.val2; self.val32 := value.val3; end;
    public property Col[x: integer]: Vec4d read x=0?Col0:x=1?Col1:x=2?Col2:Arr&<Vec4d>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      2: Col2 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..2');
    end;
    
    public property ColPtr0: ^Vec3d read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec3d read pointer(IntPtr(pointer(@self)) + 32);
    public property ColPtr2: ^Vec3d read pointer(IntPtr(pointer(@self)) + 64);
    public property ColPtr3: ^Vec3d read pointer(IntPtr(pointer(@self)) + 96);
    public property ColPtr[x: integer]: ^Vec3d read pointer(IntPtr(pointer(@self)) + x*32);
    
    public static function Scale(k: double): Mtr4x3d := new Mtr4x3d(k, 0.0, 0.0, 0.0, k, 0.0, 0.0, 0.0, k, 0.0, 0.0, 0.0);
    
    public static function Traslate(X, Y: double): Mtr4x3d := new Mtr4x3d(1.0, 0.0, X, 0.0, 1.0, Y, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0);
    public static function TraslateTransposed(X, Y, Z: double): Mtr4x3d := new Mtr4x3d(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, X, Y, Z);
    
    public static function RotateXYcw(rot: double): Mtr4x3d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr4x3d(
         cr, +sr, 0.0,
        -sr,  cr, 0.0,
        0.0, 0.0, 1.0,
        0.0, 0.0, 0.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr4x3d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr4x3d(
         cr, -sr, 0.0,
        +sr,  cr, 0.0,
        0.0, 0.0, 1.0,
        0.0, 0.0, 0.0
      );
    end;
    
    public static function RotateYZcw(rot: double): Mtr4x3d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr4x3d(
        1.0, 0.0, 0.0,
        0.0,  cr, +sr,
        0.0, -sr,  cr,
        0.0, 0.0, 0.0
      );
    end;
    public static function RotateYZccw(rot: double): Mtr4x3d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr4x3d(
        1.0, 0.0, 0.0,
        0.0,  cr, -sr,
        0.0, +sr,  cr,
        0.0, 0.0, 0.0
      );
    end;
    
    public static function RotateZXcw(rot: double): Mtr4x3d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr4x3d(
         cr, 0.0, -sr,
        0.0, 1.0, 0.0,
        +sr, 0.0,  cr,
        0.0, 0.0, 0.0
      );
    end;
    public static function RotateZXccw(rot: double): Mtr4x3d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr4x3d(
         cr, 0.0, +sr,
        0.0, 1.0, 0.0,
        -sr, 0.0,  cr,
        0.0, 0.0, 0.0
      );
    end;
    
    public static function Rotate3Dcw(u: Vec3d; rot: double): Mtr4x3d;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := -k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := -k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := -k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
    end;
    
    public static function Rotate3Dccw(u: Vec3d; rot: double): Mtr4x3d;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := -k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := -k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := -k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[4,3];
      for var y := 0 to 4-1 do
        for var x := 0 to 3-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*3 + 6; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[2,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[3,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[3,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[3,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr4x3d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr4x3d; v: Vec3d): Vec4d := new Vec4d(m.val00*v.val0+m.val01*v.val1+m.val02*v.val2, m.val10*v.val0+m.val11*v.val1+m.val12*v.val2, m.val20*v.val0+m.val21*v.val1+m.val22*v.val2, m.val30*v.val0+m.val31*v.val1+m.val32*v.val2);
    public static function operator*(v: Vec4d; m: Mtr4x3d): Vec3d := new Vec3d(m.val00*v.val0+m.val10*v.val1+m.val20*v.val2+m.val30*v.val3, m.val01*v.val0+m.val11*v.val1+m.val21*v.val2+m.val31*v.val3, m.val02*v.val0+m.val12*v.val1+m.val22*v.val2+m.val32*v.val3);
    
    public static function operator implicit(m: Mtr2x2f): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3d): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3d): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22);
    
    public static function operator implicit(m: Mtr4x4f): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22, m.val30, m.val31, m.val32);
    public static function operator implicit(m: Mtr4x3d): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0, m.val30, m.val31, m.val32, 0.0);
    
    public static function operator implicit(m: Mtr2x3f): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3d): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    
    public static function operator implicit(m: Mtr3x2f): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3d): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    
    public static function operator implicit(m: Mtr2x4f): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3d): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0);
    
    public static function operator implicit(m: Mtr4x2f): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0, m.val30, m.val31, 0.0);
    public static function operator implicit(m: Mtr4x3d): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, m.val30, m.val31);
    
    public static function operator implicit(m: Mtr3x4f): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3d): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0);
    
    public static function operator implicit(m: Mtr4x3f): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22, m.val30, m.val31, m.val32);
    public static function operator implicit(m: Mtr4x3d): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22, m.val30, m.val31, m.val32);
    
    public static function operator implicit(m: Mtr2x2d): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3d): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3d): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3d): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22);
    
    public static function operator implicit(m: Mtr4x4d): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22, m.val30, m.val31, m.val32);
    public static function operator implicit(m: Mtr4x3d): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0, m.val30, m.val31, m.val32, 0.0);
    
    public static function operator implicit(m: Mtr2x3d): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3d): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    
    public static function operator implicit(m: Mtr3x2d): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3d): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    
    public static function operator implicit(m: Mtr2x4d): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3d): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0);
    
    public static function operator implicit(m: Mtr4x2d): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0, m.val30, m.val31, 0.0);
    public static function operator implicit(m: Mtr4x3d): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, m.val30, m.val31);
    
    public static function operator implicit(m: Mtr3x4d): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3d): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0);
    
  end;
  
  {$endregion Mtr}
  
  {$region MtrMlt}
    
    function operator*(m1: Mtr2x2f; m2: Mtr2x2f): Mtr2x2f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
    end;
    
    function operator*(m1: Mtr2x2f; m2: Mtr2x3f): Mtr2x3f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
    end;
    
    function operator*(m1: Mtr2x2f; m2: Mtr2x4f): Mtr2x4f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
      Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
      Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13;
    end;
    
    function operator*(m1: Mtr2x2f; m2: Mtr2x2d): Mtr2x2f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
    end;
    
    function operator*(m1: Mtr2x2f; m2: Mtr2x3d): Mtr2x3f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
    end;
    
    function operator*(m1: Mtr2x2f; m2: Mtr2x4d): Mtr2x4f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
      Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
      Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13;
    end;
    
    function operator*(m1: Mtr3x3f; m2: Mtr3x3f): Mtr3x3f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
    end;
    
    function operator*(m1: Mtr3x3f; m2: Mtr3x2f): Mtr3x2f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
    end;
    
    function operator*(m1: Mtr3x3f; m2: Mtr3x4f): Mtr3x4f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
      Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
      Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
      Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23;
    end;
    
    function operator*(m1: Mtr3x3f; m2: Mtr3x3d): Mtr3x3f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
    end;
    
    function operator*(m1: Mtr3x3f; m2: Mtr3x2d): Mtr3x2f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
    end;
    
    function operator*(m1: Mtr3x3f; m2: Mtr3x4d): Mtr3x4f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
      Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
      Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
      Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23;
    end;
    
    function operator*(m1: Mtr4x4f; m2: Mtr4x4f): Mtr4x4f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
      Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23 + m1.val03*m2.val33;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
      Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23 + m1.val13*m2.val33;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
      Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23 + m1.val23*m2.val33;
      Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20 + m1.val33*m2.val30;
      Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21 + m1.val33*m2.val31;
      Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22 + m1.val33*m2.val32;
      Result.val33 := m1.val30*m2.val03 + m1.val31*m2.val13 + m1.val32*m2.val23 + m1.val33*m2.val33;
    end;
    
    function operator*(m1: Mtr4x4f; m2: Mtr4x2f): Mtr4x2f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
      Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20 + m1.val33*m2.val30;
      Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21 + m1.val33*m2.val31;
    end;
    
    function operator*(m1: Mtr4x4f; m2: Mtr4x3f): Mtr4x3f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
      Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20 + m1.val33*m2.val30;
      Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21 + m1.val33*m2.val31;
      Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22 + m1.val33*m2.val32;
    end;
    
    function operator*(m1: Mtr4x4f; m2: Mtr4x4d): Mtr4x4f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
      Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23 + m1.val03*m2.val33;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
      Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23 + m1.val13*m2.val33;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
      Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23 + m1.val23*m2.val33;
      Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20 + m1.val33*m2.val30;
      Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21 + m1.val33*m2.val31;
      Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22 + m1.val33*m2.val32;
      Result.val33 := m1.val30*m2.val03 + m1.val31*m2.val13 + m1.val32*m2.val23 + m1.val33*m2.val33;
    end;
    
    function operator*(m1: Mtr4x4f; m2: Mtr4x2d): Mtr4x2f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
      Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20 + m1.val33*m2.val30;
      Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21 + m1.val33*m2.val31;
    end;
    
    function operator*(m1: Mtr4x4f; m2: Mtr4x3d): Mtr4x3f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
      Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20 + m1.val33*m2.val30;
      Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21 + m1.val33*m2.val31;
      Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22 + m1.val33*m2.val32;
    end;
    
    function operator*(m1: Mtr2x3f; m2: Mtr3x3f): Mtr2x3f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
    end;
    
    function operator*(m1: Mtr2x3f; m2: Mtr3x2f): Mtr2x2f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
    end;
    
    function operator*(m1: Mtr2x3f; m2: Mtr3x4f): Mtr2x4f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
      Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
      Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23;
    end;
    
    function operator*(m1: Mtr2x3f; m2: Mtr3x3d): Mtr2x3f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
    end;
    
    function operator*(m1: Mtr2x3f; m2: Mtr3x2d): Mtr2x2f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
    end;
    
    function operator*(m1: Mtr2x3f; m2: Mtr3x4d): Mtr2x4f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
      Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
      Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23;
    end;
    
    function operator*(m1: Mtr3x2f; m2: Mtr2x2f): Mtr3x2f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
    end;
    
    function operator*(m1: Mtr3x2f; m2: Mtr2x3f): Mtr3x3f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
    end;
    
    function operator*(m1: Mtr3x2f; m2: Mtr2x4f): Mtr3x4f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
      Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
      Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
      Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13;
    end;
    
    function operator*(m1: Mtr3x2f; m2: Mtr2x2d): Mtr3x2f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
    end;
    
    function operator*(m1: Mtr3x2f; m2: Mtr2x3d): Mtr3x3f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
    end;
    
    function operator*(m1: Mtr3x2f; m2: Mtr2x4d): Mtr3x4f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
      Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
      Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
      Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13;
    end;
    
    function operator*(m1: Mtr2x4f; m2: Mtr4x4f): Mtr2x4f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
      Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23 + m1.val03*m2.val33;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
      Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23 + m1.val13*m2.val33;
    end;
    
    function operator*(m1: Mtr2x4f; m2: Mtr4x2f): Mtr2x2f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
    end;
    
    function operator*(m1: Mtr2x4f; m2: Mtr4x3f): Mtr2x3f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
    end;
    
    function operator*(m1: Mtr2x4f; m2: Mtr4x4d): Mtr2x4f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
      Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23 + m1.val03*m2.val33;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
      Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23 + m1.val13*m2.val33;
    end;
    
    function operator*(m1: Mtr2x4f; m2: Mtr4x2d): Mtr2x2f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
    end;
    
    function operator*(m1: Mtr2x4f; m2: Mtr4x3d): Mtr2x3f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
    end;
    
    function operator*(m1: Mtr4x2f; m2: Mtr2x2f): Mtr4x2f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
      Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10;
      Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11;
    end;
    
    function operator*(m1: Mtr4x2f; m2: Mtr2x3f): Mtr4x3f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
      Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10;
      Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11;
      Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12;
    end;
    
    function operator*(m1: Mtr4x2f; m2: Mtr2x4f): Mtr4x4f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
      Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
      Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
      Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13;
      Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10;
      Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11;
      Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12;
      Result.val33 := m1.val30*m2.val03 + m1.val31*m2.val13;
    end;
    
    function operator*(m1: Mtr4x2f; m2: Mtr2x2d): Mtr4x2f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
      Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10;
      Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11;
    end;
    
    function operator*(m1: Mtr4x2f; m2: Mtr2x3d): Mtr4x3f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
      Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10;
      Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11;
      Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12;
    end;
    
    function operator*(m1: Mtr4x2f; m2: Mtr2x4d): Mtr4x4f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
      Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
      Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
      Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13;
      Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10;
      Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11;
      Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12;
      Result.val33 := m1.val30*m2.val03 + m1.val31*m2.val13;
    end;
    
    function operator*(m1: Mtr3x4f; m2: Mtr4x4f): Mtr3x4f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
      Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23 + m1.val03*m2.val33;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
      Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23 + m1.val13*m2.val33;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
      Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23 + m1.val23*m2.val33;
    end;
    
    function operator*(m1: Mtr3x4f; m2: Mtr4x2f): Mtr3x2f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
    end;
    
    function operator*(m1: Mtr3x4f; m2: Mtr4x3f): Mtr3x3f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
    end;
    
    function operator*(m1: Mtr3x4f; m2: Mtr4x4d): Mtr3x4f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
      Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23 + m1.val03*m2.val33;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
      Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23 + m1.val13*m2.val33;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
      Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23 + m1.val23*m2.val33;
    end;
    
    function operator*(m1: Mtr3x4f; m2: Mtr4x2d): Mtr3x2f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
    end;
    
    function operator*(m1: Mtr3x4f; m2: Mtr4x3d): Mtr3x3f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
    end;
    
    function operator*(m1: Mtr4x3f; m2: Mtr3x3f): Mtr4x3f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
      Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20;
      Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21;
      Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22;
    end;
    
    function operator*(m1: Mtr4x3f; m2: Mtr3x2f): Mtr4x2f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
      Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20;
      Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21;
    end;
    
    function operator*(m1: Mtr4x3f; m2: Mtr3x4f): Mtr4x4f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
      Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
      Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
      Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23;
      Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20;
      Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21;
      Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22;
      Result.val33 := m1.val30*m2.val03 + m1.val31*m2.val13 + m1.val32*m2.val23;
    end;
    
    function operator*(m1: Mtr4x3f; m2: Mtr3x3d): Mtr4x3f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
      Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20;
      Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21;
      Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22;
    end;
    
    function operator*(m1: Mtr4x3f; m2: Mtr3x2d): Mtr4x2f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
      Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20;
      Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21;
    end;
    
    function operator*(m1: Mtr4x3f; m2: Mtr3x4d): Mtr4x4f; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
      Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
      Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
      Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23;
      Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20;
      Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21;
      Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22;
      Result.val33 := m1.val30*m2.val03 + m1.val31*m2.val13 + m1.val32*m2.val23;
    end;
    
    function operator*(m1: Mtr2x2d; m2: Mtr2x2f): Mtr2x2d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
    end;
    
    function operator*(m1: Mtr2x2d; m2: Mtr2x3f): Mtr2x3d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
    end;
    
    function operator*(m1: Mtr2x2d; m2: Mtr2x4f): Mtr2x4d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
      Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
      Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13;
    end;
    
    function operator*(m1: Mtr2x2d; m2: Mtr2x2d): Mtr2x2d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
    end;
    
    function operator*(m1: Mtr2x2d; m2: Mtr2x3d): Mtr2x3d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
    end;
    
    function operator*(m1: Mtr2x2d; m2: Mtr2x4d): Mtr2x4d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
      Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
      Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13;
    end;
    
    function operator*(m1: Mtr3x3d; m2: Mtr3x3f): Mtr3x3d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
    end;
    
    function operator*(m1: Mtr3x3d; m2: Mtr3x2f): Mtr3x2d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
    end;
    
    function operator*(m1: Mtr3x3d; m2: Mtr3x4f): Mtr3x4d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
      Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
      Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
      Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23;
    end;
    
    function operator*(m1: Mtr3x3d; m2: Mtr3x3d): Mtr3x3d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
    end;
    
    function operator*(m1: Mtr3x3d; m2: Mtr3x2d): Mtr3x2d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
    end;
    
    function operator*(m1: Mtr3x3d; m2: Mtr3x4d): Mtr3x4d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
      Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
      Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
      Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23;
    end;
    
    function operator*(m1: Mtr4x4d; m2: Mtr4x4f): Mtr4x4d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
      Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23 + m1.val03*m2.val33;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
      Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23 + m1.val13*m2.val33;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
      Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23 + m1.val23*m2.val33;
      Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20 + m1.val33*m2.val30;
      Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21 + m1.val33*m2.val31;
      Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22 + m1.val33*m2.val32;
      Result.val33 := m1.val30*m2.val03 + m1.val31*m2.val13 + m1.val32*m2.val23 + m1.val33*m2.val33;
    end;
    
    function operator*(m1: Mtr4x4d; m2: Mtr4x2f): Mtr4x2d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
      Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20 + m1.val33*m2.val30;
      Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21 + m1.val33*m2.val31;
    end;
    
    function operator*(m1: Mtr4x4d; m2: Mtr4x3f): Mtr4x3d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
      Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20 + m1.val33*m2.val30;
      Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21 + m1.val33*m2.val31;
      Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22 + m1.val33*m2.val32;
    end;
    
    function operator*(m1: Mtr4x4d; m2: Mtr4x4d): Mtr4x4d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
      Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23 + m1.val03*m2.val33;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
      Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23 + m1.val13*m2.val33;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
      Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23 + m1.val23*m2.val33;
      Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20 + m1.val33*m2.val30;
      Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21 + m1.val33*m2.val31;
      Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22 + m1.val33*m2.val32;
      Result.val33 := m1.val30*m2.val03 + m1.val31*m2.val13 + m1.val32*m2.val23 + m1.val33*m2.val33;
    end;
    
    function operator*(m1: Mtr4x4d; m2: Mtr4x2d): Mtr4x2d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
      Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20 + m1.val33*m2.val30;
      Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21 + m1.val33*m2.val31;
    end;
    
    function operator*(m1: Mtr4x4d; m2: Mtr4x3d): Mtr4x3d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
      Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20 + m1.val33*m2.val30;
      Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21 + m1.val33*m2.val31;
      Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22 + m1.val33*m2.val32;
    end;
    
    function operator*(m1: Mtr2x3d; m2: Mtr3x3f): Mtr2x3d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
    end;
    
    function operator*(m1: Mtr2x3d; m2: Mtr3x2f): Mtr2x2d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
    end;
    
    function operator*(m1: Mtr2x3d; m2: Mtr3x4f): Mtr2x4d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
      Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
      Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23;
    end;
    
    function operator*(m1: Mtr2x3d; m2: Mtr3x3d): Mtr2x3d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
    end;
    
    function operator*(m1: Mtr2x3d; m2: Mtr3x2d): Mtr2x2d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
    end;
    
    function operator*(m1: Mtr2x3d; m2: Mtr3x4d): Mtr2x4d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
      Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
      Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23;
    end;
    
    function operator*(m1: Mtr3x2d; m2: Mtr2x2f): Mtr3x2d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
    end;
    
    function operator*(m1: Mtr3x2d; m2: Mtr2x3f): Mtr3x3d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
    end;
    
    function operator*(m1: Mtr3x2d; m2: Mtr2x4f): Mtr3x4d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
      Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
      Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
      Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13;
    end;
    
    function operator*(m1: Mtr3x2d; m2: Mtr2x2d): Mtr3x2d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
    end;
    
    function operator*(m1: Mtr3x2d; m2: Mtr2x3d): Mtr3x3d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
    end;
    
    function operator*(m1: Mtr3x2d; m2: Mtr2x4d): Mtr3x4d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
      Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
      Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
      Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13;
    end;
    
    function operator*(m1: Mtr2x4d; m2: Mtr4x4f): Mtr2x4d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
      Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23 + m1.val03*m2.val33;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
      Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23 + m1.val13*m2.val33;
    end;
    
    function operator*(m1: Mtr2x4d; m2: Mtr4x2f): Mtr2x2d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
    end;
    
    function operator*(m1: Mtr2x4d; m2: Mtr4x3f): Mtr2x3d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
    end;
    
    function operator*(m1: Mtr2x4d; m2: Mtr4x4d): Mtr2x4d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
      Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23 + m1.val03*m2.val33;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
      Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23 + m1.val13*m2.val33;
    end;
    
    function operator*(m1: Mtr2x4d; m2: Mtr4x2d): Mtr2x2d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
    end;
    
    function operator*(m1: Mtr2x4d; m2: Mtr4x3d): Mtr2x3d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
    end;
    
    function operator*(m1: Mtr4x2d; m2: Mtr2x2f): Mtr4x2d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
      Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10;
      Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11;
    end;
    
    function operator*(m1: Mtr4x2d; m2: Mtr2x3f): Mtr4x3d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
      Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10;
      Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11;
      Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12;
    end;
    
    function operator*(m1: Mtr4x2d; m2: Mtr2x4f): Mtr4x4d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
      Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
      Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
      Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13;
      Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10;
      Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11;
      Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12;
      Result.val33 := m1.val30*m2.val03 + m1.val31*m2.val13;
    end;
    
    function operator*(m1: Mtr4x2d; m2: Mtr2x2d): Mtr4x2d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
      Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10;
      Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11;
    end;
    
    function operator*(m1: Mtr4x2d; m2: Mtr2x3d): Mtr4x3d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
      Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10;
      Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11;
      Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12;
    end;
    
    function operator*(m1: Mtr4x2d; m2: Mtr2x4d): Mtr4x4d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
      Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
      Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
      Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13;
      Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10;
      Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11;
      Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12;
      Result.val33 := m1.val30*m2.val03 + m1.val31*m2.val13;
    end;
    
    function operator*(m1: Mtr3x4d; m2: Mtr4x4f): Mtr3x4d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
      Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23 + m1.val03*m2.val33;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
      Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23 + m1.val13*m2.val33;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
      Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23 + m1.val23*m2.val33;
    end;
    
    function operator*(m1: Mtr3x4d; m2: Mtr4x2f): Mtr3x2d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
    end;
    
    function operator*(m1: Mtr3x4d; m2: Mtr4x3f): Mtr3x3d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
    end;
    
    function operator*(m1: Mtr3x4d; m2: Mtr4x4d): Mtr3x4d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
      Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23 + m1.val03*m2.val33;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
      Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23 + m1.val13*m2.val33;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
      Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23 + m1.val23*m2.val33;
    end;
    
    function operator*(m1: Mtr3x4d; m2: Mtr4x2d): Mtr3x2d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
    end;
    
    function operator*(m1: Mtr3x4d; m2: Mtr4x3d): Mtr3x3d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
    end;
    
    function operator*(m1: Mtr4x3d; m2: Mtr3x3f): Mtr4x3d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
      Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20;
      Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21;
      Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22;
    end;
    
    function operator*(m1: Mtr4x3d; m2: Mtr3x2f): Mtr4x2d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
      Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20;
      Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21;
    end;
    
    function operator*(m1: Mtr4x3d; m2: Mtr3x4f): Mtr4x4d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
      Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
      Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
      Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23;
      Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20;
      Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21;
      Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22;
      Result.val33 := m1.val30*m2.val03 + m1.val31*m2.val13 + m1.val32*m2.val23;
    end;
    
    function operator*(m1: Mtr4x3d; m2: Mtr3x3d): Mtr4x3d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
      Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20;
      Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21;
      Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22;
    end;
    
    function operator*(m1: Mtr4x3d; m2: Mtr3x2d): Mtr4x2d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
      Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20;
      Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21;
    end;
    
    function operator*(m1: Mtr4x3d; m2: Mtr3x4d): Mtr4x4d; extensionmethod;
    begin
      Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
      Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
      Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
      Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23;
      Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
      Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
      Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
      Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23;
      Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
      Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
      Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
      Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23;
      Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20;
      Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21;
      Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22;
      Result.val33 := m1.val30*m2.val03 + m1.val31*m2.val13 + m1.val32*m2.val23;
    end;
  
  {$endregion MtrMlt}
  
  {$region MtrTranspose}
  
  function Transpose(self: Mtr2x2f); extensionmethod :=
  new Mtr2x2f(self.val00, self.val10, self.val01, self.val11);
  
  function Transpose(self: Mtr3x3f); extensionmethod :=
  new Mtr3x3f(self.val00, self.val10, self.val20, self.val01, self.val11, self.val21, self.val02, self.val12, self.val22);
  
  function Transpose(self: Mtr4x4f); extensionmethod :=
  new Mtr4x4f(self.val00, self.val10, self.val20, self.val30, self.val01, self.val11, self.val21, self.val31, self.val02, self.val12, self.val22, self.val32, self.val03, self.val13, self.val23, self.val33);
  
  function Transpose(self: Mtr2x3f); extensionmethod :=
  new Mtr3x2f(self.val00, self.val10, self.val01, self.val11, self.val02, self.val12);
  function Transpose(self: Mtr3x2f); extensionmethod :=
  new Mtr2x3f(self.val00, self.val10, self.val20, self.val01, self.val11, self.val21);
  
  function Transpose(self: Mtr2x4f); extensionmethod :=
  new Mtr4x2f(self.val00, self.val10, self.val01, self.val11, self.val02, self.val12, self.val03, self.val13);
  function Transpose(self: Mtr4x2f); extensionmethod :=
  new Mtr2x4f(self.val00, self.val10, self.val20, self.val30, self.val01, self.val11, self.val21, self.val31);
  
  function Transpose(self: Mtr3x4f); extensionmethod :=
  new Mtr4x3f(self.val00, self.val10, self.val20, self.val01, self.val11, self.val21, self.val02, self.val12, self.val22, self.val03, self.val13, self.val23);
  function Transpose(self: Mtr4x3f); extensionmethod :=
  new Mtr3x4f(self.val00, self.val10, self.val20, self.val30, self.val01, self.val11, self.val21, self.val31, self.val02, self.val12, self.val22, self.val32);
  
  function Transpose(self: Mtr2x2d); extensionmethod :=
  new Mtr2x2d(self.val00, self.val10, self.val01, self.val11);
  
  function Transpose(self: Mtr3x3d); extensionmethod :=
  new Mtr3x3d(self.val00, self.val10, self.val20, self.val01, self.val11, self.val21, self.val02, self.val12, self.val22);
  
  function Transpose(self: Mtr4x4d); extensionmethod :=
  new Mtr4x4d(self.val00, self.val10, self.val20, self.val30, self.val01, self.val11, self.val21, self.val31, self.val02, self.val12, self.val22, self.val32, self.val03, self.val13, self.val23, self.val33);
  
  function Transpose(self: Mtr2x3d); extensionmethod :=
  new Mtr3x2d(self.val00, self.val10, self.val01, self.val11, self.val02, self.val12);
  function Transpose(self: Mtr3x2d); extensionmethod :=
  new Mtr2x3d(self.val00, self.val10, self.val20, self.val01, self.val11, self.val21);
  
  function Transpose(self: Mtr2x4d); extensionmethod :=
  new Mtr4x2d(self.val00, self.val10, self.val01, self.val11, self.val02, self.val12, self.val03, self.val13);
  function Transpose(self: Mtr4x2d); extensionmethod :=
  new Mtr2x4d(self.val00, self.val10, self.val20, self.val30, self.val01, self.val11, self.val21, self.val31);
  
  function Transpose(self: Mtr3x4d); extensionmethod :=
  new Mtr4x3d(self.val00, self.val10, self.val20, self.val01, self.val11, self.val21, self.val02, self.val12, self.val22, self.val03, self.val13, self.val23);
  function Transpose(self: Mtr4x3d); extensionmethod :=
  new Mtr3x4d(self.val00, self.val10, self.val20, self.val30, self.val01, self.val11, self.val21, self.val31, self.val02, self.val12, self.val22, self.val32);
  
  {$endregion MtrTranspose}
  
  {$region Misc} type
  
  [StructLayout(LayoutKind.&Explicit)]
  IntFloatUnion = record
    public [FieldOffset(0)] i: integer;
    public [FieldOffset(0)] f: single;
    
    public constructor(i: integer) := self.i := i;
    public constructor(f: single) := self.f := f;
    
  end;
  
  DrawArraysIndirectCommand = record
    public count:         UInt32;
    public instanceCount: UInt32;
    public first:         UInt32;
    public baseInstance:  UInt32;
    
    public constructor(count, instanceCount, first, baseInstance: UInt32);
    begin
      self.count := count;
      self.instanceCount := instanceCount;
      self.first := first;
      self.baseInstance := baseInstance;
    end;
    
  end;
  
  //ToDo функции принемающие single - бывает, принимают и fixed
  fixed = record
    {private} val: UInt32;
    
    //ToDo реализовать простейшие операции, с инкапсуляцией но разрешить обращатся к val через свойство
    
  end;
  
  half = record
    {private} val: UInt16;
    
    //ToDo реализовать простейшие операции, с инкапсуляцией но разрешить обращатся к val через свойство
    
  end;
  
  GDI_PixelFormatDescriptor = record
    nSize:            UInt16 := sizeof(GDI_PixelFormatDescriptor);
    nVersion:         UInt16 := 1;
    
    dwFlags:          GDI_PixelFormatFlags;
    iPixelType:       GDI_PixelDataType;
    
    cColorBits:       Byte; // кол-во битов для R+G+B
    
    cRedBits:         Byte; // похоже, если оставить нулями - их автоматом заполнит
    cRedShift:        Byte;
    cGreenBits:       Byte;
    cGreenShift:      Byte;
    cBlueBits:        Byte;
    cBlueShift:       Byte;
    cAlphaBits:       Byte; // последние 2 не работают на Windows
    cAlphaShift:      Byte;
    
    cAccumBits:       Byte;
    cAccumRedBits:    Byte;
    cAccumGreenBits:  Byte;
    cAccumBlueBits:   Byte;
    cAccumAlphaBits:  Byte;
    
    cDepthBits:       Byte;
    cStencilBits:     Byte;
    cAuxBuffers:      Byte; // устарело
    
    iLayerType:       GDI_LayerType; // устарело
    bLayersSize:      Byte; // разделено на 2 числа по 4 бита, и бесполезно без iLayerType, то есть оно тоже устарело
    
    // не смог найти нормального описания последних 3, но все присваивают им нолики
    dwLayerMask:      UInt32;
    dwVisibleMask:    UInt32;
    dwDamageMask:     UInt32;
    
  end;
  
  {$endregion Misc}
  
{$endregion Записи}

type
  
  /// Ядро OpenGL
  /// Все функции отсотированы по разрелу спецификации в исходниках
  gl = static class
    
    {$region 2.0 - OpenGL Fundamentals}
    
    {$region 2.3 - Command Execution}
    
    // 2.3.1
    
    public static function GetError: ErrorCode;
    external 'opengl32.dll' name 'glGetError';
    
    // 2.3.2
    
    static function GetGraphicsResetStatus: ErrorCode;
    external 'opengl32.dll' name 'glGetGraphicsResetStatus';
    
    // 2.3.3
    
    static procedure Finish;
    external 'opengl32.dll' name 'glFinish';
    
    static procedure Flush;
    external 'opengl32.dll' name 'glFlush';
    
    {$endregion 2.3 - Command Execution}
    
    {$endregion 2.0 - OpenGL Fundamentals}
    
    {$region 4.0 - Event Model}
    
    {$region 4.1 - Sync Objects and Fences}
    
    static function FenceSync(condition: FenceCondition; flags: ReservedFlags): GLsync;
    external 'opengl32.dll' name 'glFenceSync';
    
    static procedure DeleteSync(sync: GLsync);
    external 'opengl32.dll' name 'glDeleteSync';
    
    // 4.1.1
    
    static function ClientWaitSync(sync: GLsync; flags: CommandFlushingBehaviorFlags; timeout: TimeSpan): ClientWaitSyncResult;
    external 'opengl32.dll' name 'glClientWaitSync';
    static function ClientWaitSync(sync: GLsync; flags: CommandFlushingBehaviorFlags; timeout: UInt64): ClientWaitSyncResult;
    external 'opengl32.dll' name 'glClientWaitSync';
    
    static procedure WaitSync(sync: GLsync; flags: ReservedFlags; timeout: ReservedTimeoutMode);
    external 'opengl32.dll' name 'glWaitSync';
    
    // 4.1.3
    
    static procedure GetSynciv(sync: GLsync; pname: SyncObjInfoType; bufSize: Int32; var length: Int32; var values: SyncObjectType);
    external 'opengl32.dll' name 'glGetSynciv';
    static procedure GetSynciv(sync: GLsync; pname: SyncObjInfoType; bufSize: Int32; var length: Int32; var values: FenceStatus);
    external 'opengl32.dll' name 'glGetSynciv';
    static procedure GetSynciv(sync: GLsync; pname: SyncObjInfoType; bufSize: Int32; var length: Int32; var values: FenceCondition);
    external 'opengl32.dll' name 'glGetSynciv';
    static procedure GetSynciv(sync: GLsync; pname: SyncObjInfoType; bufSize: Int32; var length: Int32; var values: Int32);
    external 'opengl32.dll' name 'glGetSynciv';
    static procedure GetSynciv(sync: GLsync; pname: SyncObjInfoType; bufSize: Int32; length: pointer; values: pointer);
    external 'opengl32.dll' name 'glGetSynciv';
    
    static function IsSync(sync: GLsync): boolean;
    external 'opengl32.dll' name 'glIsSync';
    
    {$endregion 4.1 - Sync Objects and Fences}
    
    {$region 4.2 - Query Objects and Asynchronous Queries}
    
    // 4.2.2
    
    static procedure GenQueries(n: Int32; [MarshalAs(UnmanagedType.LPArray)] ids: array of QueryName);
    external 'opengl32.dll' name 'glGenQueries';
    static procedure GenQueries(n: Int32; var ids: QueryName);
    external 'opengl32.dll' name 'glGenQueries';
    static procedure GenQueries(n: Int32; ids: pointer);
    external 'opengl32.dll' name 'glGenQueries';
    
    static procedure CreateQueries(target: QueryTargetType; n: Int32; [MarshalAs(UnmanagedType.LPArray)] ids: array of QueryName);
    external 'opengl32.dll' name 'glCreateQueries';
    static procedure CreateQueries(target: QueryTargetType; n: Int32; var ids: QueryName);
    external 'opengl32.dll' name 'glCreateQueries';
    static procedure CreateQueries(target: QueryTargetType; n: Int32; ids: pointer);
    external 'opengl32.dll' name 'glCreateQueries';
    
    static procedure DeleteQueries(n: Int32; [MarshalAs(UnmanagedType.LPArray)] ids: array of QueryName);
    external 'opengl32.dll' name 'glDeleteQueries';
    static procedure DeleteQueries(n: Int32; var ids: QueryName);
    external 'opengl32.dll' name 'glDeleteQueries';
    static procedure DeleteQueries(n: Int32; ids: pointer);
    external 'opengl32.dll' name 'glDeleteQueries';
    
    static procedure BeginQueryIndexed(target: QueryTargetType; index: UInt32; id: QueryName);
    external 'opengl32.dll' name 'glBeginQueryIndexed';
    static procedure BeginQuery(target: QueryTargetType; id: QueryName);
    external 'opengl32.dll' name 'glBeginQuery';
    
    static procedure EndQueryIndexed(target: QueryTargetType; index: UInt32);
    external 'opengl32.dll' name 'glEndQueryIndexed';
    static procedure EndQuery(target: QueryTargetType);
    external 'opengl32.dll' name 'glEndQuery';
    
    // 4.2.3
    
    static function IsQuery(id: QueryName): boolean;
    external 'opengl32.dll' name 'glIsQuery';
    
    static procedure GetQueryIndexediv(target: QueryTargetType; index: UInt32; pname: GetQueryInfoName; var &params: QueryName);
    external 'opengl32.dll' name 'glGetQueryIndexediv';
    static procedure GetQueryIndexediv(target: QueryTargetType; index: UInt32; pname: GetQueryInfoName; var &params: Int32);
    external 'opengl32.dll' name 'glGetQueryIndexediv';
    static procedure GetQueryIndexediv(target: QueryTargetType; index: UInt32; pname: GetQueryInfoName; var &params: boolean);
    external 'opengl32.dll' name 'glGetQueryIndexediv';
    static procedure GetQueryIndexediv(target: QueryTargetType; index: UInt32; pname: GetQueryInfoName; var &params: TimeSpan);
    external 'opengl32.dll' name 'glGetQueryIndexediv';
    static procedure GetQueryIndexediv(target: QueryTargetType; index: UInt32; pname: GetQueryInfoName; var &params: DateTime);
    external 'opengl32.dll' name 'glGetQueryIndexediv';
    static procedure GetQueryIndexediv(target: QueryTargetType; index: UInt32; pname: GetQueryInfoName; &params: pointer);
    external 'opengl32.dll' name 'glGetQueryIndexediv';
    
    static procedure GetQueryiv(target: QueryTargetType; pname: GetQueryInfoName; var &params: QueryName);
    external 'opengl32.dll' name 'glGetQueryiv';
    static procedure GetQueryiv(target: QueryTargetType; pname: GetQueryInfoName; var &params: Int32);
    external 'opengl32.dll' name 'glGetQueryiv';
    static procedure GetQueryiv(target: QueryTargetType; pname: GetQueryInfoName; var &params: boolean);
    external 'opengl32.dll' name 'glGetQueryiv';
    static procedure GetQueryiv(target: QueryTargetType; pname: GetQueryInfoName; var &params: TimeSpan);
    external 'opengl32.dll' name 'glGetQueryiv';
    static procedure GetQueryiv(target: QueryTargetType; pname: GetQueryInfoName; var &params: DateTime);
    external 'opengl32.dll' name 'glGetQueryiv';
    static procedure GetQueryiv(target: QueryTargetType; pname: GetQueryInfoName; &params: pointer);
    external 'opengl32.dll' name 'glGetQueryiv';
    
    static procedure GetQueryObjectiv(id: QueryName; pname: GetQueryObjectInfoName; var &params: Int32);
    external 'opengl32.dll' name 'glGetQueryObjectiv';
    static procedure GetQueryObjectiv(id: QueryName; pname: GetQueryObjectInfoName; var &params: boolean);
    external 'opengl32.dll' name 'glGetQueryObjectiv';
    static procedure GetQueryObjectiv(id: QueryName; pname: GetQueryObjectInfoName; &params: pointer);
    external 'opengl32.dll' name 'glGetQueryObjectiv';
    
    static procedure GetQueryObjectuiv(id: QueryName; pname: GetQueryObjectInfoName; var &params: UInt32); // QueryName=UInt32, поэтому его можно сюда же передавать
    external 'opengl32.dll' name 'glGetQueryObjectuiv';
    static procedure GetQueryObjectuiv(id: QueryName; pname: GetQueryObjectInfoName; &params: pointer);
    external 'opengl32.dll' name 'glGetQueryObjectuiv';
    
    static procedure GetQueryObjecti64v(id: QueryName; pname: GetQueryObjectInfoName; var &params: Int64);
    external 'opengl32.dll' name 'glGetQueryObjecti64v';
    static procedure GetQueryObjecti64v(id: QueryName; pname: GetQueryObjectInfoName; &params: pointer);
    external 'opengl32.dll' name 'glGetQueryObjecti64v';
    
    static procedure GetQueryObjectui64v(id: QueryName; pname: GetQueryObjectInfoName; var &params: TimeSpan);
    external 'opengl32.dll' name 'glGetQueryObjectui64v';
    static procedure GetQueryObjectui64v(id: QueryName; pname: GetQueryObjectInfoName; var &params: DateTime);
    external 'opengl32.dll' name 'glGetQueryObjectui64v';
    static procedure GetQueryObjectui64v(id: QueryName; pname: GetQueryObjectInfoName; var &params: UInt64);
    external 'opengl32.dll' name 'glGetQueryObjectui64v';
    static procedure GetQueryObjectui64v(id: QueryName; pname: GetQueryObjectInfoName; &params: pointer);
    external 'opengl32.dll' name 'glGetQueryObjectui64v';
    
    static procedure GetQueryBufferObjectiv(id: QueryName; buffer: BufferName; pname: GetQueryObjectInfoName; offset: IntPtr);
    external 'opengl32.dll' name 'glGetQueryBufferObjectiv';
    
    static procedure GetQueryBufferObjectuiv(id: QueryName; buffer: BufferName; pname: GetQueryObjectInfoName; offset: IntPtr);
    external 'opengl32.dll' name 'glGetQueryBufferObjectuiv';
    
    static procedure GetQueryBufferObjecti64v(id: QueryName; buffer: BufferName; pname: GetQueryObjectInfoName; offset: IntPtr);
    external 'opengl32.dll' name 'glGetQueryBufferObjecti64v';
    
    static procedure GetQueryBufferObjectui64v(id: QueryName; buffer: BufferName; pname: GetQueryObjectInfoName; offset: IntPtr);
    external 'opengl32.dll' name 'glGetQueryBufferObjectui64v';
    
    {$endregion 4.2 - Query Objects and Asynchronous Queries}
    
    {$region 4.3 - Time Queries}
    
    static procedure QueryCounter(id: QueryName; target: QueryTargetType);
    external 'opengl32.dll' name 'glQueryCounter';
    
    {$endregion 4.3 - Time Queries}
    
    {$endregion 4.0 - Event Model}
    
    {$region 6.0 - Buffer Objects}
    
    static procedure GenBuffers(n: Int32; [MarshalAs(UnmanagedType.LPArray)] buffers: array of BufferName);
    external 'opengl32.dll' name 'glGenBuffers';
    static procedure GenBuffers(n: Int32; var buffers: BufferName);
    external 'opengl32.dll' name 'glGenBuffers';
    static procedure GenBuffers(n: Int32; buffers: pointer);
    external 'opengl32.dll' name 'glGenBuffers';
    
    static procedure CreateBuffers(n: Int32; [MarshalAs(UnmanagedType.LPArray)] buffers: array of BufferName);
    external 'opengl32.dll' name 'glCreateBuffers';
    static procedure CreateBuffers(n: Int32; var buffers: BufferName);
    external 'opengl32.dll' name 'glCreateBuffers';
    static procedure CreateBuffers(n: Int32; buffers: pointer);
    external 'opengl32.dll' name 'glCreateBuffers';
    
    static procedure DeleteBuffers(n: Int32; [MarshalAs(UnmanagedType.LPArray)] buffers: array of BufferName);
    external 'opengl32.dll' name 'glDeleteBuffers';
    static procedure DeleteBuffers(n: Int32; var buffers: BufferName);
    external 'opengl32.dll' name 'glDeleteBuffers';
    static procedure DeleteBuffers(n: Int32; buffers: pointer);
    external 'opengl32.dll' name 'glDeleteBuffers';
    
    static function IsBuffer(buffer: BufferName): boolean;
    external 'opengl32.dll' name 'glIsBuffer';
    
    {$region 6.1 - Creating and Binding Buffer Objects}
    
    static procedure BindBuffer(target: BufferBindType; buffer: BufferName);
    external 'opengl32.dll' name 'glBindBuffer';
    
    // 6.1.1
    
    static procedure BindBufferRange(target: BufferBindType; index: UInt32; buffer: BufferName; offset: IntPtr; size: UIntPtr);
    external 'opengl32.dll' name 'glBindBufferRange';
    
    static procedure BindBufferBase(target: BufferBindType; index: UInt32; buffer: BufferName);
    external 'opengl32.dll' name 'glBindBufferBase';
    
    static procedure BindBuffersBase(target: BufferBindType; first: UInt32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] buffers: array of BufferName);
    external 'opengl32.dll' name 'glBindBuffersBase';
    static procedure BindBuffersBase(target: BufferBindType; first: UInt32; count: Int32; var buffers: BufferName);
    external 'opengl32.dll' name 'glBindBuffersBase';
    static procedure BindBuffersBase(target: BufferBindType; first: UInt32; count: Int32; buffers: pointer);
    external 'opengl32.dll' name 'glBindBuffersBase';
    
    static procedure BindBuffersRange(target: BufferBindType; first: UInt32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] buffers: array of BufferName; [MarshalAs(UnmanagedType.LPArray)] offsets: array of IntPtr; [MarshalAs(UnmanagedType.LPArray)] sizes: array of UIntPtr);
    external 'opengl32.dll' name 'glBindBuffersRange';
    static procedure BindBuffersRange(target: BufferBindType; first: UInt32; count: Int32; var buffers: BufferName; var offsets: IntPtr; var sizes: UIntPtr);
    external 'opengl32.dll' name 'glBindBuffersRange';
    static procedure BindBuffersRange(target: BufferBindType; first: UInt32; count: Int32; buffers: pointer; offsets: pointer; sizes: pointer);
    external 'opengl32.dll' name 'glBindBuffersRange';
    
    {$endregion 6.1 - Creating and Binding Buffer Objects}
    
    {$region 6.2 - Creating and Modifying Buffer Object Data Stores}
    
    static procedure BufferStorage(target: BufferBindType; size: UIntPtr; data: IntPtr; flags: BufferStorageFlags);
    external 'opengl32.dll' name 'glBufferStorage';
    static procedure BufferStorage(target: BufferBindType; size: UIntPtr; data: pointer; flags: BufferStorageFlags);
    external 'opengl32.dll' name 'glBufferStorage';
    
    static procedure NamedBufferStorage(buffer: BufferName; size: UIntPtr; data: IntPtr; flags: BufferStorageFlags);
    external 'opengl32.dll' name 'glNamedBufferStorage';
    static procedure NamedBufferStorage(buffer: BufferName; size: UIntPtr; data: pointer; flags: BufferStorageFlags);
    external 'opengl32.dll' name 'glNamedBufferStorage';
    
    static procedure BufferData(target: BufferBindType; size: UIntPtr; data: IntPtr; usage: BufferDataUsage);
    external 'opengl32.dll' name 'glBufferData';
    static procedure BufferData(target: BufferBindType; size: UIntPtr; data: pointer; usage: BufferDataUsage);
    external 'opengl32.dll' name 'glBufferData';
    
    static procedure NamedBufferData(buffer: BufferName; size: UIntPtr; data: IntPtr; usage: BufferDataUsage);
    external 'opengl32.dll' name 'glNamedBufferData';
    static procedure NamedBufferData(buffer: BufferName; size: UIntPtr; data: pointer; usage: BufferDataUsage);
    external 'opengl32.dll' name 'glNamedBufferData';
    
    static procedure BufferSubData(target: BufferBindType; offset: IntPtr; size: UIntPtr; data: IntPtr);
    external 'opengl32.dll' name 'glBufferSubData';
    static procedure BufferSubData(target: BufferBindType; offset: IntPtr; size: UIntPtr; data: pointer);
    external 'opengl32.dll' name 'glBufferSubData';
    
    static procedure NamedBufferSubData(buffer: BufferName; offset: IntPtr; size: UIntPtr; data: IntPtr);
    external 'opengl32.dll' name 'glNamedBufferSubData';
    static procedure NamedBufferSubData(buffer: BufferName; offset: IntPtr; size: UIntPtr; data: pointer);
    external 'opengl32.dll' name 'glNamedBufferSubData';
    
    static procedure ClearBufferSubData(target: BufferBindType; internalformat: InternalDataFormat; offset: IntPtr; size: UIntPtr; format: DataFormat; &type: DataType; data: IntPtr);
    external 'opengl32.dll' name 'glClearBufferSubData';
    static procedure ClearBufferSubData(target: BufferBindType; internalformat: InternalDataFormat; offset: IntPtr; size: UIntPtr; format: DataFormat; &type: DataType; data: pointer);
    external 'opengl32.dll' name 'glClearBufferSubData';
    
    static procedure ClearNamedBufferSubData(buffer: BufferName; internalformat: InternalDataFormat; offset: IntPtr; size: UIntPtr; format: DataFormat; &type: DataType; data: IntPtr);
    external 'opengl32.dll' name 'glClearNamedBufferSubData';
    static procedure ClearNamedBufferSubData(buffer: BufferName; internalformat: InternalDataFormat; offset: IntPtr; size: UIntPtr; format: DataFormat; &type: DataType; data: pointer);
    external 'opengl32.dll' name 'glClearNamedBufferSubData';
    
    static procedure ClearBufferData(target: BufferBindType; internalformat: InternalDataFormat; format: DataFormat; &type: DataType; data: IntPtr);
    external 'opengl32.dll' name 'glClearBufferData';
    static procedure ClearBufferData(target: BufferBindType; internalformat: InternalDataFormat; format: DataFormat; &type: DataType; data: pointer);
    external 'opengl32.dll' name 'glClearBufferData';
    
    static procedure ClearNamedBufferData(buffer: BufferName; internalformat: InternalDataFormat; format: DataFormat; &type: DataType; data: IntPtr);
    external 'opengl32.dll' name 'glClearNamedBufferData';
    static procedure ClearNamedBufferData(buffer: BufferName; internalformat: InternalDataFormat; format: DataFormat; &type: DataType; data: pointer);
    external 'opengl32.dll' name 'glClearNamedBufferData';
    
    {$endregion 6.2 - Creating and Modifying Buffer Object Data Stores}
    
    {$region 6.3 - Mapping and Unmapping Buffer Data}
    
    static function MapBufferRange(target: BufferBindType; offset: IntPtr; length: UIntPtr; access: BufferMapFlags): IntPtr;
    external 'opengl32.dll' name 'glMapBufferRange';
    static function MapNamedBufferRange(buffer: BufferName; offset: IntPtr; length: UIntPtr; access: BufferMapFlags): IntPtr;
    external 'opengl32.dll' name 'glMapNamedBufferRange';
    
    static function MapBuffer(target: BufferBindType; access: BufferMapFlags): IntPtr;
    external 'opengl32.dll' name 'glMapBuffer';
    static function MapNamedBuffer(buffer: BufferName; access: BufferMapFlags): IntPtr;
    external 'opengl32.dll' name 'glMapNamedBuffer';
    
    static procedure FlushMappedBufferRange(target: BufferBindType; offset: IntPtr; length: UIntPtr);
    external 'opengl32.dll' name 'glFlushMappedBufferRange';
    static procedure FlushMappedNamedBufferRange(buffer: BufferName; offset: IntPtr; length: UIntPtr);
    external 'opengl32.dll' name 'glFlushMappedNamedBufferRange';
    
    // 6.3.1
    
    static function UnmapBuffer(target: BufferBindType): boolean;
    external 'opengl32.dll' name 'glUnmapBuffer';
    static function UnmapNamedBuffer(buffer: BufferName): boolean;
    external 'opengl32.dll' name 'glUnmapNamedBuffer';
    
    {$endregion 6.3 - Mapping and Unmapping Buffer Data}
    
    {$region 6.5 - Invalidating Buffer Data}
    
    static procedure InvalidateBufferSubData(buffer: BufferName; offset: IntPtr; length: UIntPtr);
    external 'opengl32.dll' name 'glInvalidateBufferSubData';
    
    static procedure InvalidateBufferData(buffer: BufferName);
    external 'opengl32.dll' name 'glInvalidateBufferData';
    
    {$endregion 6.5 - Invalidating Buffer Data}
    
    {$region 6.6 - Copying Between Buffers}
    
    static procedure CopyBufferSubData(readTarget, writeTarget: BufferBindType; readOffset, writeOffset: IntPtr; size: UIntPtr);
    external 'opengl32.dll' name 'glCopyBufferSubData';
    static procedure CopyNamedBufferSubData(readBuffer, writeBuffer: BufferName; readOffset, writeOffset: IntPtr; size: UIntPtr);
    external 'opengl32.dll' name 'glCopyNamedBufferSubData';
    
    {$endregion 6.6 - Copying Between Buffers}
    
    {$region 6.7 - Buffer Object Queries}
    
    static procedure GetBufferParameteriv(target: BufferBindType; pname: BufferInfoType; var &params: BufferDataUsage);
    external 'opengl32.dll' name 'glGetBufferParameteriv';
    static procedure GetBufferParameteriv(target: BufferBindType; pname: BufferInfoType; var &params: AccessType);
    external 'opengl32.dll' name 'glGetBufferParameteriv';
    static procedure GetBufferParameteriv(target: BufferBindType; pname: BufferInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetBufferParameteriv';
    static procedure GetBufferParameteriv(target: BufferBindType; pname: BufferInfoType; var &params: boolean);
    external 'opengl32.dll' name 'glGetBufferParameteriv';
    static procedure GetBufferParameteriv(target: BufferBindType; pname: BufferInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetBufferParameteriv';
    
    static procedure GetBufferParameteri64v(target: BufferBindType; pname: BufferInfoType; var &params: Int64);
    external 'opengl32.dll' name 'glGetBufferParameteri64v';
    static procedure GetBufferParameteri64v(target: BufferBindType; pname: BufferInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetBufferParameteri64v';
    
    static procedure GetNamedBufferParameteriv(target: BufferName; pname: BufferInfoType; var &params: BufferDataUsage);
    external 'opengl32.dll' name 'glGetNamedBufferParameteriv';
    static procedure GetNamedBufferParameteriv(target: BufferName; pname: BufferInfoType; var &params: AccessType);
    external 'opengl32.dll' name 'glGetNamedBufferParameteriv';
    static procedure GetNamedBufferParameteriv(target: BufferName; pname: BufferInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetNamedBufferParameteriv';
    static procedure GetNamedBufferParameteriv(target: BufferName; pname: BufferInfoType; var &params: boolean);
    external 'opengl32.dll' name 'glGetNamedBufferParameteriv';
    static procedure GetNamedBufferParameteriv(target: BufferName; pname: BufferInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetNamedBufferParameteriv';
    
    static procedure GetNamedBufferParameteri64v(target: BufferName; pname: BufferInfoType; var &params: Int64);
    external 'opengl32.dll' name 'glGetNamedBufferParameteri64v';
    static procedure GetNamedBufferParameteri64v(target: BufferName; pname: BufferInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetNamedBufferParameteri64v';
    
    static procedure GetBufferSubData(target: BufferBindType; offset: IntPtr; size: UIntPtr; data: IntPtr);
    external 'opengl32.dll' name 'glGetBufferSubData';
    static procedure GetBufferSubData(target: BufferBindType; offset: IntPtr; size: UIntPtr; data: pointer);
    external 'opengl32.dll' name 'glGetBufferSubData';
    
    static procedure GetNamedBufferSubData(buffer: BufferName; offset: IntPtr; size: UIntPtr; data: IntPtr);
    external 'opengl32.dll' name 'glGetNamedBufferSubData';
    static procedure GetNamedBufferSubData(buffer: BufferName; offset: IntPtr; size: UIntPtr; data: pointer);
    external 'opengl32.dll' name 'glGetNamedBufferSubData';
    
    static procedure GetBufferPointerv(target: BufferBindType; pname: BufferInfoType; var &params: IntPtr);
    external 'opengl32.dll' name 'glGetBufferPointerv';
    static procedure GetBufferPointerv(target: BufferBindType; pname: BufferInfoType; var &params: pointer);
    external 'opengl32.dll' name 'glGetBufferPointerv';
    static procedure GetBufferPointerv(target: BufferBindType; pname: BufferInfoType; &params: ^IntPtr);
    external 'opengl32.dll' name 'glGetBufferPointerv';
    
    static procedure GetNamedBufferPointerv(buffer: BufferName; pname: BufferInfoType; var &params: IntPtr);
    external 'opengl32.dll' name 'glGetNamedBufferPointerv';
    static procedure GetNamedBufferPointerv(buffer: BufferName; pname: BufferInfoType; var &params: pointer);
    external 'opengl32.dll' name 'glGetNamedBufferPointerv';
    static procedure GetNamedBufferPointerv(buffer: BufferName; pname: BufferInfoType; &params: ^IntPtr);
    external 'opengl32.dll' name 'glGetNamedBufferPointerv';
    
    {$endregion 6.7 - Buffer Object Queries}
    
    {$endregion 6.0 - Buffer Objects}
    
    {$region 7.0 - Programs and Shaders}
    
    {$region 7.1 - Shader Objects}
    
    static function CreateShader(&type: ShaderType): ShaderName;
    external 'opengl32.dll' name 'glCreateShader';
    
    static procedure ShaderSource(shader: ShaderName; count: Int32; [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.LPStr)] strings: array of string; [MarshalAs(UnmanagedType.LPArray)] lengths: array of Int32);
    external 'opengl32.dll' name 'glShaderSource';
    static procedure ShaderSource(shader: ShaderName; count: Int32; [MarshalAs(UnmanagedType.SysInt, ArraySubType = UnmanagedType.LPStr)] var strings: string; var lengths: Int32);
    external 'opengl32.dll' name 'glShaderSource';
    static procedure ShaderSource(shader: ShaderName; count: Int32; var strings: IntPtr; var lengths: Int32);
    external 'opengl32.dll' name 'glShaderSource';
    static procedure ShaderSource(shader: ShaderName; count: Int32; strings: pointer; lengths: pointer);
    external 'opengl32.dll' name 'glShaderSource';
    
    static procedure CompileShader(shader: ShaderName);
    external 'opengl32.dll' name 'glCompileShader';
    
    static procedure ReleaseShaderCompiler;
    external 'opengl32.dll' name 'glReleaseShaderCompiler';
    
    static procedure DeleteShader(shader: ShaderName);
    external 'opengl32.dll' name 'glDeleteShader';
    
    static function IsShader(shader: ShaderName): boolean;
    external 'opengl32.dll' name 'glIsShader';
    
    {$endregion 7.1 - Shader Objects}
    
    {$region 7.2 - Shader Binaries}
    
    // для получения binaryformat
    // надо вызвать gl.Get... с параметрами:
    // GLGetQueries.NUM_SHADER_BINARY_FORMATS
    // GLGetQueries.SHADER_BINARY_FORMATS
    static procedure ShaderBinary(count: Int32; [MarshalAs(UnmanagedType.LPArray)] shaders: array of ShaderName; binaryformat: ShaderBinaryFormat; [MarshalAs(UnmanagedType.LPArray)] binary: array of byte; length: Int32);
    external 'opengl32.dll' name 'glShaderBinary';
    static procedure ShaderBinary(count: Int32; [MarshalAs(UnmanagedType.LPArray)] shaders: array of ShaderName; binaryformat: ShaderBinaryFormat; binary: IntPtr; length: Int32);
    external 'opengl32.dll' name 'glShaderBinary';
    static procedure ShaderBinary(count: Int32; var shaders: ShaderName; binaryformat: ShaderBinaryFormat; [MarshalAs(UnmanagedType.LPArray)] binary: array of byte; length: Int32);
    external 'opengl32.dll' name 'glShaderBinary';
    static procedure ShaderBinary(count: Int32; var shaders: ShaderName; binaryformat: ShaderBinaryFormat; binary: IntPtr; length: Int32);
    external 'opengl32.dll' name 'glShaderBinary';
    static procedure ShaderBinary(count: Int32; shaders: pointer; binaryformat: ShaderBinaryFormat; [MarshalAs(UnmanagedType.LPArray)] binary: array of byte; length: Int32);
    external 'opengl32.dll' name 'glShaderBinary';
    static procedure ShaderBinary(count: Int32; shaders: pointer; binaryformat: ShaderBinaryFormat; binary: IntPtr; length: Int32);
    external 'opengl32.dll' name 'glShaderBinary';
    
    // 7.2.1
    
    static procedure SpecializeShader(shader: ShaderName; [MarshalAs(UnmanagedType.LPStr)] pEntryPoint: string; numSpecializationConstants: UInt32; [MarshalAs(UnmanagedType.LPArray)] pConstantIndex: array of UInt32; [MarshalAs(UnmanagedType.LPArray)] pConstantValue: array of IntFloatUnion);
    external 'opengl32.dll' name 'glSpecializeShader';
    static procedure SpecializeShader(shader: ShaderName; [MarshalAs(UnmanagedType.LPStr)] pEntryPoint: string; numSpecializationConstants: UInt32; [MarshalAs(UnmanagedType.LPArray)] pConstantIndex: array of UInt32; [MarshalAs(UnmanagedType.LPArray)] pConstantValue: array of Int32);
    external 'opengl32.dll' name 'glSpecializeShader';
    static procedure SpecializeShader(shader: ShaderName; [MarshalAs(UnmanagedType.LPStr)] pEntryPoint: string; numSpecializationConstants: UInt32; [MarshalAs(UnmanagedType.LPArray)] pConstantIndex: array of UInt32; [MarshalAs(UnmanagedType.LPArray)] pConstantValue: array of single);
    external 'opengl32.dll' name 'glSpecializeShader';
    static procedure SpecializeShader(shader: ShaderName; [MarshalAs(UnmanagedType.LPStr)] pEntryPoint: string; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; var pConstantValue: IntFloatUnion);
    external 'opengl32.dll' name 'glSpecializeShader';
    static procedure SpecializeShader(shader: ShaderName; [MarshalAs(UnmanagedType.LPStr)] pEntryPoint: string; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; var pConstantValue: Int32);
    external 'opengl32.dll' name 'glSpecializeShader';
    static procedure SpecializeShader(shader: ShaderName; [MarshalAs(UnmanagedType.LPStr)] pEntryPoint: string; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; var pConstantValue: single);
    external 'opengl32.dll' name 'glSpecializeShader';
    static procedure SpecializeShader(shader: ShaderName; [MarshalAs(UnmanagedType.LPStr)] pEntryPoint: string; numSpecializationConstants: UInt32; pConstantIndex: pointer; pConstantValue: pointer);
    external 'opengl32.dll' name 'glSpecializeShader';
    static procedure SpecializeShader(shader: ShaderName; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; [MarshalAs(UnmanagedType.LPArray)] pConstantIndex: array of UInt32; [MarshalAs(UnmanagedType.LPArray)] pConstantValue: array of IntFloatUnion);
    external 'opengl32.dll' name 'glSpecializeShader';
    static procedure SpecializeShader(shader: ShaderName; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; [MarshalAs(UnmanagedType.LPArray)] pConstantIndex: array of UInt32; [MarshalAs(UnmanagedType.LPArray)] pConstantValue: array of Int32);
    external 'opengl32.dll' name 'glSpecializeShader';
    static procedure SpecializeShader(shader: ShaderName; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; [MarshalAs(UnmanagedType.LPArray)] pConstantIndex: array of UInt32; [MarshalAs(UnmanagedType.LPArray)] pConstantValue: array of single);
    external 'opengl32.dll' name 'glSpecializeShader';
    static procedure SpecializeShader(shader: ShaderName; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; var pConstantValue: IntFloatUnion);
    external 'opengl32.dll' name 'glSpecializeShader';
    static procedure SpecializeShader(shader: ShaderName; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; var pConstantValue: Int32);
    external 'opengl32.dll' name 'glSpecializeShader';
    static procedure SpecializeShader(shader: ShaderName; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; var pConstantValue: single);
    external 'opengl32.dll' name 'glSpecializeShader';
    static procedure SpecializeShader(shader: ShaderName; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; pConstantIndex: pointer; pConstantValue: pointer);
    external 'opengl32.dll' name 'glSpecializeShader';
    
    {$endregion 7.2 - Shader Binaries}
    
    {$region 7.3 - Program Objects}
    
    static function CreateProgram: ProgramName;
    external 'opengl32.dll' name 'glCreateProgram';
    
    static procedure AttachShader(&program: ProgramName; shader: ShaderName);
    external 'opengl32.dll' name 'glAttachShader';
    
    static procedure DetachShader(&program: ProgramName; shader: ShaderName);
    external 'opengl32.dll' name 'glDetachShader';
    
    static procedure LinkProgram(&program: ProgramName);
    external 'opengl32.dll' name 'glLinkProgram';
    
    static procedure UseProgram(&program: ProgramName);
    external 'opengl32.dll' name 'glUseProgram';
    
    static procedure ProgramParameteri(&program: ProgramName; pname: ProgramParameterType; value: Int32);
    external 'opengl32.dll' name 'glProgramParameteri';
    
    static procedure DeleteProgram(&program: ProgramName);
    external 'opengl32.dll' name 'glDeleteProgram';
    
    static function IsProgram(&program: ProgramName): boolean;
    external 'opengl32.dll' name 'glIsProgram';
    
    static function CreateShaderProgramv(&type: ShaderType; count: Int32; [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.LPStr)] strings: array of string): ProgramName;
    external 'opengl32.dll' name 'glCreateShaderProgramv';
    static function CreateShaderProgramv(&type: ShaderType; count: Int32; [MarshalAs(UnmanagedType.LPArray)] strings: array of IntPtr): ProgramName;
    external 'opengl32.dll' name 'glCreateShaderProgramv';
    static function CreateShaderProgramv(&type: ShaderType; count: Int32; [MarshalAs(UnmanagedType.SysInt, ArraySubType = UnmanagedType.LPStr)] var strings: string): ProgramName;
    external 'opengl32.dll' name 'glCreateShaderProgramv';
    static function CreateShaderProgramv(&type: ShaderType; count: Int32; var strings: IntPtr): ProgramName;
    external 'opengl32.dll' name 'glCreateShaderProgramv';
    static function CreateShaderProgramv(&type: ShaderType; count: Int32; strings: pointer): ProgramName;
    external 'opengl32.dll' name 'glCreateShaderProgramv';
    
    // 7.3.1
    
    // 7.3.1.1
    
    static procedure GetProgramInterfaceiv(&program: ProgramName; programInterface: ProgramInterfaceType; pname: ProgramInterfaceInfoType; [MarshalAs(UnmanagedType.LPArray)] &params: array of Int32);
    external 'opengl32.dll' name 'glGetProgramInterfaceiv';
    static procedure GetProgramInterfaceiv(&program: ProgramName; programInterface: ProgramInterfaceType; pname: ProgramInterfaceInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetProgramInterfaceiv';
    static procedure GetProgramInterfaceiv(&program: ProgramName; programInterface: ProgramInterfaceType; pname: ProgramInterfaceInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetProgramInterfaceiv';
    
    static function GetProgramResourceIndex(&program: ProgramName; programInterface: ProgramInterfaceType; [MarshalAs(UnmanagedType.LPStr)] name: string): ProgramResourceIndex;
    external 'opengl32.dll' name 'glGetProgramResourceIndex';
    static function GetProgramResourceIndex(&program: ProgramName; programInterface: ProgramInterfaceType; name: IntPtr): ProgramResourceIndex;
    external 'opengl32.dll' name 'glGetProgramResourceIndex';
    
    static procedure GetProgramResourceName(&program: ProgramName; programInterface: ProgramInterfaceType; index: ProgramResourceIndex; bufSize: Int32; var length: Int32; [MarshalAs(UnmanagedType.LPStr)] name: string);
    external 'opengl32.dll' name 'glGetProgramResourceName';
    static procedure GetProgramResourceName(&program: ProgramName; programInterface: ProgramInterfaceType; index: ProgramResourceIndex; bufSize: Int32; var length: Int32; name: IntPtr);
    external 'opengl32.dll' name 'glGetProgramResourceName';
    static procedure GetProgramResourceName(&program: ProgramName; programInterface: ProgramInterfaceType; index: ProgramResourceIndex; bufSize: Int32; length: pointer; [MarshalAs(UnmanagedType.LPStr)] name: string);
    external 'opengl32.dll' name 'glGetProgramResourceName';
    static procedure GetProgramResourceName(&program: ProgramName; programInterface: ProgramInterfaceType; index: ProgramResourceIndex; bufSize: Int32; length: pointer; name: IntPtr);
    external 'opengl32.dll' name 'glGetProgramResourceName';
    
    static procedure GetProgramResourceiv(&program: ProgramName; programInterface: ProgramInterfaceType; index: ProgramResourceIndex; propCount: Int32; [MarshalAs(UnmanagedType.LPArray)] props: array of ProgramInterfaceProperty; bufSize: Int32; var length: Int32; [MarshalAs(UnmanagedType.LPArray)] &params: array of Int32);
    external 'opengl32.dll' name 'glGetProgramResourceiv';
    static procedure GetProgramResourceiv(&program: ProgramName; programInterface: ProgramInterfaceType; index: ProgramResourceIndex; propCount: Int32; var props: ProgramInterfaceProperty; bufSize: Int32; var length: Int32; var &params: ShadingLanguageTypeToken);
    external 'opengl32.dll' name 'glGetProgramResourceiv';
    static procedure GetProgramResourceiv(&program: ProgramName; programInterface: ProgramInterfaceType; index: ProgramResourceIndex; propCount: Int32; var props: ProgramInterfaceProperty; bufSize: Int32; var length: Int32; var &params: Int32);
    external 'opengl32.dll' name 'glGetProgramResourceiv';
    static procedure GetProgramResourceiv(&program: ProgramName; programInterface: ProgramInterfaceType; index: ProgramResourceIndex; propCount: Int32; props: pointer; bufSize: Int32; length: pointer; &params: pointer);
    external 'opengl32.dll' name 'glGetProgramResourceiv';
    
    static function GetProgramResourceLocation(&program: ProgramName; programInterface: ProgramInterfaceType; [MarshalAs(UnmanagedType.LPStr)] name: string): Int32;
    external 'opengl32.dll' name 'glGetProgramResourceLocation';
    static function GetProgramResourceLocation(&program: ProgramName; programInterface: ProgramInterfaceType; name: IntPtr): Int32;
    external 'opengl32.dll' name 'glGetProgramResourceLocation';
    
    static function GetProgramResourceLocationIndex(&program: ProgramName; programInterface: ProgramInterfaceType; [MarshalAs(UnmanagedType.LPStr)] name: string): Int32;
    external 'opengl32.dll' name 'glGetProgramResourceLocationIndex';
    static function GetProgramResourceLocationIndex(&program: ProgramName; programInterface: ProgramInterfaceType; name: IntPtr): Int32;
    external 'opengl32.dll' name 'glGetProgramResourceLocationIndex';
    
    {$endregion 7.3 - Program Objects}
    
    {$region 7.4 - Program Pipeline Objects}
    
    static procedure GenProgramPipelines(n: Int32; [MarshalAs(UnmanagedType.LPArray)] pipelines: array of ProgramPipelineName);
    external 'opengl32.dll' name 'glGenProgramPipelines';
    static procedure GenProgramPipelines(n: Int32; var pipelines: ProgramPipelineName);
    external 'opengl32.dll' name 'glGenProgramPipelines';
    static procedure GenProgramPipelines(n: Int32; pipelines: pointer);
    external 'opengl32.dll' name 'glGenProgramPipelines';
    
    static procedure DeleteProgramPipelines(n: Int32; [MarshalAs(UnmanagedType.LPArray)] pipelines: array of ProgramPipelineName);
    external 'opengl32.dll' name 'glDeleteProgramPipelines';
    static procedure DeleteProgramPipelines(n: Int32; var pipelines: ProgramPipelineName);
    external 'opengl32.dll' name 'glDeleteProgramPipelines';
    static procedure DeleteProgramPipelines(n: Int32; pipelines: pointer);
    external 'opengl32.dll' name 'glDeleteProgramPipelines';
    
    static function IsProgramPipeline(pipeline: ProgramPipelineName): boolean;
    external 'opengl32.dll' name 'glIsProgramPipeline';
    
    static procedure BindProgramPipeline(pipeline: ProgramPipelineName);
    external 'opengl32.dll' name 'glBindProgramPipeline';
    
    static procedure CreateProgramPipelines(n: Int32; [MarshalAs(UnmanagedType.LPArray)] pipelines: array of ProgramPipelineName);
    external 'opengl32.dll' name 'glCreateProgramPipelines';
    static procedure CreateProgramPipelines(n: Int32; var pipelines: ProgramPipelineName);
    external 'opengl32.dll' name 'glCreateProgramPipelines';
    static procedure CreateProgramPipelines(n: Int32; pipelines: pointer);
    external 'opengl32.dll' name 'glCreateProgramPipelines';
    
    static procedure UseProgramStages(pipeline: ProgramPipelineName; stages: ProgramStagesFlags; &program: ProgramName);
    external 'opengl32.dll' name 'glUseProgramStages';
    
    static procedure ActiveShaderProgram(pipeline: ProgramPipelineName; &program: ProgramName);
    external 'opengl32.dll' name 'glActiveShaderProgram';
    
    {$endregion 7.4 - Program Pipeline Objects}
    
    {$region 7.5 - Program Binaries}
    
    static procedure GetProgramBinary(&program: ProgramName; bufSize: Int32; var length: Int32; var binaryFormat: ProgramBinaryFormat; [MarshalAs(UnmanagedType.LPArray)] binary: array of byte);
    external 'opengl32.dll' name 'glGetProgramBinary';
    static procedure GetProgramBinary(&program: ProgramName; bufSize: Int32; var length: Int32; var binaryFormat: ProgramBinaryFormat; binary: IntPtr);
    external 'opengl32.dll' name 'glGetProgramBinary';
    static procedure GetProgramBinary(&program: ProgramName; bufSize: Int32; length: pointer; binaryFormat: pointer; [MarshalAs(UnmanagedType.LPArray)] binary: array of byte);
    external 'opengl32.dll' name 'glGetProgramBinary';
    static procedure GetProgramBinary(&program: ProgramName; bufSize: Int32; length: pointer; binaryFormat: pointer; binary: IntPtr);
    external 'opengl32.dll' name 'glGetProgramBinary';
    
    static procedure ProgramBinary(&program: ProgramName; binaryFormat: ProgramBinaryFormat; [MarshalAs(UnmanagedType.LPArray)] binary: array of byte; length: Int32);
    external 'opengl32.dll' name 'glProgramBinary';
    static procedure ProgramBinary(&program: ProgramName; binaryFormat: ProgramBinaryFormat; binary: IntPtr; length: Int32);
    external 'opengl32.dll' name 'glProgramBinary';
    
    {$endregion 7.5 - Program Binaries}
    
    {$region 7.6 - Uniform Variables}
    
    static function GetUniformLocation(&program: ProgramName; [MarshalAs(UnmanagedType.LPStr)] name: string): Int32;
    external 'opengl32.dll' name 'glGetUniformLocation';
    static function GetUniformLocation(&program: ProgramName; name: IntPtr): Int32;
    external 'opengl32.dll' name 'glGetUniformLocation';
    
    static procedure GetActiveUniformName(&program: ProgramName; uniformIndex: UInt32; bufSize: Int32; var length: Int32; [MarshalAs(UnmanagedType.LPStr)] uniformName: string);
    external 'opengl32.dll' name 'glGetActiveUniformName';
    static procedure GetActiveUniformName(&program: ProgramName; uniformIndex: UInt32; bufSize: Int32; var length: Int32; uniformName: IntPtr);
    external 'opengl32.dll' name 'glGetActiveUniformName';
    static procedure GetActiveUniformName(&program: ProgramName; uniformIndex: UInt32; bufSize: Int32; length: pointer; [MarshalAs(UnmanagedType.LPStr)] uniformName: string);
    external 'opengl32.dll' name 'glGetActiveUniformName';
    static procedure GetActiveUniformName(&program: ProgramName; uniformIndex: UInt32; bufSize: Int32; length: pointer; uniformName: IntPtr);
    external 'opengl32.dll' name 'glGetActiveUniformName';
    
    static procedure GetUniformIndices(&program: ProgramName; uniformCount: Int32; [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.LPStr)] uniformNames: array of string; [MarshalAs(UnmanagedType.LPArray)] uniformIndices: array of UInt32);
    external 'opengl32.dll' name 'glGetUniformIndices';
    static procedure GetUniformIndices(&program: ProgramName; uniformCount: Int32; [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.LPStr)] uniformNames: array of string; var uniformIndices: UInt32);
    external 'opengl32.dll' name 'glGetUniformIndices';
    static procedure GetUniformIndices(&program: ProgramName; uniformCount: Int32; [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.LPStr)] uniformNames: array of string; uniformIndices: pointer);
    external 'opengl32.dll' name 'glGetUniformIndices';
    static procedure GetUniformIndices(&program: ProgramName; uniformCount: Int32; [MarshalAs(UnmanagedType.LPArray)] uniformNames: array of IntPtr; [MarshalAs(UnmanagedType.LPArray)] uniformIndices: array of UInt32);
    external 'opengl32.dll' name 'glGetUniformIndices';
    static procedure GetUniformIndices(&program: ProgramName; uniformCount: Int32; [MarshalAs(UnmanagedType.LPArray)] uniformNames: array of IntPtr; var uniformIndices: UInt32);
    external 'opengl32.dll' name 'glGetUniformIndices';
    static procedure GetUniformIndices(&program: ProgramName; uniformCount: Int32; [MarshalAs(UnmanagedType.LPArray)] uniformNames: array of IntPtr; uniformIndices: pointer);
    external 'opengl32.dll' name 'glGetUniformIndices';
    static procedure GetUniformIndices(&program: ProgramName; uniformCount: Int32; [MarshalAs(UnmanagedType.SysInt, ArraySubType = UnmanagedType.LPStr)] var uniformNames: string; [MarshalAs(UnmanagedType.LPArray)] uniformIndices: array of UInt32);
    external 'opengl32.dll' name 'glGetUniformIndices';
    static procedure GetUniformIndices(&program: ProgramName; uniformCount: Int32; [MarshalAs(UnmanagedType.SysInt, ArraySubType = UnmanagedType.LPStr)] var uniformNames: string; var uniformIndices: UInt32);
    external 'opengl32.dll' name 'glGetUniformIndices';
    static procedure GetUniformIndices(&program: ProgramName; uniformCount: Int32; [MarshalAs(UnmanagedType.SysInt, ArraySubType = UnmanagedType.LPStr)] var uniformNames: string; uniformIndices: pointer);
    external 'opengl32.dll' name 'glGetUniformIndices';
    static procedure GetUniformIndices(&program: ProgramName; uniformCount: Int32; var uniformNames: IntPtr; [MarshalAs(UnmanagedType.LPArray)] uniformIndices: array of UInt32);
    external 'opengl32.dll' name 'glGetUniformIndices';
    static procedure GetUniformIndices(&program: ProgramName; uniformCount: Int32; var uniformNames: IntPtr; var uniformIndices: UInt32);
    external 'opengl32.dll' name 'glGetUniformIndices';
    static procedure GetUniformIndices(&program: ProgramName; uniformCount: Int32; var uniformNames: IntPtr; uniformIndices: pointer);
    external 'opengl32.dll' name 'glGetUniformIndices';
    static procedure GetUniformIndices(&program: ProgramName; uniformCount: Int32; uniformNames: pointer; [MarshalAs(UnmanagedType.LPArray)] uniformIndices: array of UInt32);
    external 'opengl32.dll' name 'glGetUniformIndices';
    static procedure GetUniformIndices(&program: ProgramName; uniformCount: Int32; uniformNames: pointer; var uniformIndices: UInt32);
    external 'opengl32.dll' name 'glGetUniformIndices';
    static procedure GetUniformIndices(&program: ProgramName; uniformCount: Int32; uniformNames: pointer; uniformIndices: pointer);
    external 'opengl32.dll' name 'glGetUniformIndices';
    
    static procedure GetActiveUniform(&program: ProgramName; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: ShadingLanguageTypeToken; [MarshalAs(UnmanagedType.LPStr)] name: string);
    external 'opengl32.dll' name 'glGetActiveUniform';
    static procedure GetActiveUniform(&program: ProgramName; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: ShadingLanguageTypeToken; name: IntPtr);
    external 'opengl32.dll' name 'glGetActiveUniform';
    static procedure GetActiveUniform(&program: ProgramName; index: UInt32; bufSize: Int32; length: pointer; size: pointer; &type: pointer; [MarshalAs(UnmanagedType.LPStr)] name: string);
    external 'opengl32.dll' name 'glGetActiveUniform';
    static procedure GetActiveUniform(&program: ProgramName; index: UInt32; bufSize: Int32; length: pointer; size: pointer; &type: pointer; name: IntPtr);
    external 'opengl32.dll' name 'glGetActiveUniform';
    
    static procedure GetActiveUniformsiv(&program: ProgramName; uniformCount: Int32; [MarshalAs(UnmanagedType.LPArray)] uniformIndices: array of UInt32; pname: ProgramInterfaceProperty; [MarshalAs(UnmanagedType.LPArray)] &params: array of Int32);
    external 'opengl32.dll' name 'glGetActiveUniformsiv';
    static procedure GetActiveUniformsiv(&program: ProgramName; uniformCount: Int32; var uniformIndices: UInt32; pname: ProgramInterfaceProperty; var &params: ShadingLanguageTypeToken);
    external 'opengl32.dll' name 'glGetActiveUniformsiv';
    static procedure GetActiveUniformsiv(&program: ProgramName; uniformCount: Int32; var uniformIndices: UInt32; pname: ProgramInterfaceProperty; var &params: Int32);
    external 'opengl32.dll' name 'glGetActiveUniformsiv';
    static procedure GetActiveUniformsiv(&program: ProgramName; uniformCount: Int32; uniformIndices: pointer; pname: ProgramInterfaceProperty; &params: pointer);
    external 'opengl32.dll' name 'glGetActiveUniformsiv';
    
    static function GetUniformBlockIndex(&program: ProgramName; [MarshalAs(UnmanagedType.LPStr)] uniformBlockName: string): UInt32;
    external 'opengl32.dll' name 'glGetUniformBlockIndex';
    static function GetUniformBlockIndex(&program: ProgramName; uniformBlockName: IntPtr): UInt32;
    external 'opengl32.dll' name 'glGetUniformBlockIndex';
    
    static procedure GetActiveUniformBlockName(&program: ProgramName; uniformBlockIndex: UInt32; bufSize: Int32; var length: Int32; [MarshalAs(UnmanagedType.LPStr)] uniformBlockName: string);
    external 'opengl32.dll' name 'glGetActiveUniformBlockName';
    static procedure GetActiveUniformBlockName(&program: ProgramName; uniformBlockIndex: UInt32; bufSize: Int32; length: pointer; uniformBlockName: IntPtr);
    external 'opengl32.dll' name 'glGetActiveUniformBlockName';
    
    static procedure GetActiveUniformBlockiv(&program: ProgramName; uniformBlockIndex: UInt32; pname: ProgramInterfaceProperty; [MarshalAs(UnmanagedType.LPArray)] &params: array of Int32);
    external 'opengl32.dll' name 'glGetActiveUniformBlockiv';
    static procedure GetActiveUniformBlockiv(&program: ProgramName; uniformBlockIndex: UInt32; pname: ProgramInterfaceProperty; var &params: ShadingLanguageTypeToken);
    external 'opengl32.dll' name 'glGetActiveUniformBlockiv';
    static procedure GetActiveUniformBlockiv(&program: ProgramName; uniformBlockIndex: UInt32; pname: ProgramInterfaceProperty; var &params: Int32);
    external 'opengl32.dll' name 'glGetActiveUniformBlockiv';
    static procedure GetActiveUniformBlockiv(&program: ProgramName; uniformBlockIndex: UInt32; pname: ProgramInterfaceProperty; &params: pointer);
    external 'opengl32.dll' name 'glGetActiveUniformBlockiv';
    
    static procedure GetActiveAtomicCounterBufferiv(&program: ProgramName; bufferIndex: UInt32; pname: ProgramInterfaceProperty; [MarshalAs(UnmanagedType.LPArray)] &params: array of Int32);
    external 'opengl32.dll' name 'glGetActiveAtomicCounterBufferiv';
    static procedure GetActiveAtomicCounterBufferiv(&program: ProgramName; bufferIndex: UInt32; pname: ProgramInterfaceProperty; var &params: ShadingLanguageTypeToken);
    external 'opengl32.dll' name 'glGetActiveAtomicCounterBufferiv';
    static procedure GetActiveAtomicCounterBufferiv(&program: ProgramName; bufferIndex: UInt32; pname: ProgramInterfaceProperty; var &params: Int32);
    external 'opengl32.dll' name 'glGetActiveAtomicCounterBufferiv';
    static procedure GetActiveAtomicCounterBufferiv(&program: ProgramName; bufferIndex: UInt32; pname: ProgramInterfaceProperty; &params: pointer);
    external 'opengl32.dll' name 'glGetActiveAtomicCounterBufferiv';
    
    // 7.6.1
    
    {$region Uniform[1,2,3,4][i,f,d,ui]}
    
    static procedure Uniform1i(location: Int32; v0: Int32);
    external 'opengl32.dll' name 'glUniform1i';
    
    static procedure Uniform2i(location: Int32; v0: Int32; v1: Int32);
    external 'opengl32.dll' name 'glUniform2i';
    
    static procedure Uniform3i(location: Int32; v0: Int32; v1: Int32; v2: Int32);
    external 'opengl32.dll' name 'glUniform3i';
    
    static procedure Uniform4i(location: Int32; v0: Int32; v1: Int32; v2: Int32; v3: Int32);
    external 'opengl32.dll' name 'glUniform4i';
    
    static procedure Uniform1f(location: Int32; v0: single);
    external 'opengl32.dll' name 'glUniform1f';
    
    static procedure Uniform2f(location: Int32; v0: single; v1: single);
    external 'opengl32.dll' name 'glUniform2f';
    
    static procedure Uniform3f(location: Int32; v0: single; v1: single; v2: single);
    external 'opengl32.dll' name 'glUniform3f';
    
    static procedure Uniform4f(location: Int32; v0: single; v1: single; v2: single; v3: single);
    external 'opengl32.dll' name 'glUniform4f';
    
    static procedure Uniform1d(location: Int32; x: double);
    external 'opengl32.dll' name 'glUniform1d';
    
    static procedure Uniform2d(location: Int32; x: double; y: double);
    external 'opengl32.dll' name 'glUniform2d';
    
    static procedure Uniform3d(location: Int32; x: double; y: double; z: double);
    external 'opengl32.dll' name 'glUniform3d';
    
    static procedure Uniform4d(location: Int32; x: double; y: double; z: double; w: double);
    external 'opengl32.dll' name 'glUniform4d';
    
    static procedure Uniform1ui(location: Int32; v0: UInt32);
    external 'opengl32.dll' name 'glUniform1ui';
    
    static procedure Uniform2ui(location: Int32; v0: UInt32; v1: UInt32);
    external 'opengl32.dll' name 'glUniform2ui';
    
    static procedure Uniform3ui(location: Int32; v0: UInt32; v1: UInt32; v2: UInt32);
    external 'opengl32.dll' name 'glUniform3ui';
    
    static procedure Uniform4ui(location: Int32; v0: UInt32; v1: UInt32; v2: UInt32; v3: UInt32);
    external 'opengl32.dll' name 'glUniform4ui';
    
    {$endregion Uniform[1,2,3,4][i,f,d,ui]}
    
    {$region Uniform[1,2,3,4][i,f,d,ui]v}
    
    static procedure Uniform1iv(location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of Int32);
    external 'opengl32.dll' name 'glUniform1iv';
    static procedure Uniform1iv(location: Int32; count: Int32; var value: Int32);
    external 'opengl32.dll' name 'glUniform1iv';
    static procedure Uniform1iv(location: Int32; count: Int32; var value: Vec1i);
    external 'opengl32.dll' name 'glUniform1iv';
    static procedure Uniform1iv(location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glUniform1iv';
    
    static procedure Uniform2iv(location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of Int32);
    external 'opengl32.dll' name 'glUniform2iv';
    static procedure Uniform2iv(location: Int32; count: Int32; var value: Int32);
    external 'opengl32.dll' name 'glUniform2iv';
    static procedure Uniform2iv(location: Int32; count: Int32; var value: Vec2i);
    external 'opengl32.dll' name 'glUniform2iv';
    static procedure Uniform2iv(location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glUniform2iv';
    
    static procedure Uniform3iv(location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of Int32);
    external 'opengl32.dll' name 'glUniform3iv';
    static procedure Uniform3iv(location: Int32; count: Int32; var value: Int32);
    external 'opengl32.dll' name 'glUniform3iv';
    static procedure Uniform3iv(location: Int32; count: Int32; var value: Vec3i);
    external 'opengl32.dll' name 'glUniform3iv';
    static procedure Uniform3iv(location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glUniform3iv';
    
    static procedure Uniform4iv(location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of Int32);
    external 'opengl32.dll' name 'glUniform4iv';
    static procedure Uniform4iv(location: Int32; count: Int32; var value: Int32);
    external 'opengl32.dll' name 'glUniform4iv';
    static procedure Uniform4iv(location: Int32; count: Int32; var value: Vec4i);
    external 'opengl32.dll' name 'glUniform4iv';
    static procedure Uniform4iv(location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glUniform4iv';
    
    static procedure Uniform1fv(location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glUniform1fv';
    static procedure Uniform1fv(location: Int32; count: Int32; var value: single);
    external 'opengl32.dll' name 'glUniform1fv';
    static procedure Uniform1fv(location: Int32; count: Int32; var value: Vec1f);
    external 'opengl32.dll' name 'glUniform1fv';
    static procedure Uniform1fv(location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glUniform1fv';
    
    static procedure Uniform2fv(location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glUniform2fv';
    static procedure Uniform2fv(location: Int32; count: Int32; var value: single);
    external 'opengl32.dll' name 'glUniform2fv';
    static procedure Uniform2fv(location: Int32; count: Int32; var value: Vec2f);
    external 'opengl32.dll' name 'glUniform2fv';
    static procedure Uniform2fv(location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glUniform2fv';
    
    static procedure Uniform3fv(location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glUniform3fv';
    static procedure Uniform3fv(location: Int32; count: Int32; var value: single);
    external 'opengl32.dll' name 'glUniform3fv';
    static procedure Uniform3fv(location: Int32; count: Int32; var value: Vec3f);
    external 'opengl32.dll' name 'glUniform3fv';
    static procedure Uniform3fv(location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glUniform3fv';
    
    static procedure Uniform4fv(location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glUniform4fv';
    static procedure Uniform4fv(location: Int32; count: Int32; var value: single);
    external 'opengl32.dll' name 'glUniform4fv';
    static procedure Uniform4fv(location: Int32; count: Int32; var value: Vec4f);
    external 'opengl32.dll' name 'glUniform4fv';
    static procedure Uniform4fv(location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glUniform4fv';
    
    static procedure Uniform1dv(location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glUniform1dv';
    static procedure Uniform1dv(location: Int32; count: Int32; var value: double);
    external 'opengl32.dll' name 'glUniform1dv';
    static procedure Uniform1dv(location: Int32; count: Int32; var value: Vec1d);
    external 'opengl32.dll' name 'glUniform1dv';
    static procedure Uniform1dv(location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glUniform1dv';
    
    static procedure Uniform2dv(location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glUniform2dv';
    static procedure Uniform2dv(location: Int32; count: Int32; var value: double);
    external 'opengl32.dll' name 'glUniform2dv';
    static procedure Uniform2dv(location: Int32; count: Int32; var value: Vec2d);
    external 'opengl32.dll' name 'glUniform2dv';
    static procedure Uniform2dv(location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glUniform2dv';
    
    static procedure Uniform3dv(location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glUniform3dv';
    static procedure Uniform3dv(location: Int32; count: Int32; var value: double);
    external 'opengl32.dll' name 'glUniform3dv';
    static procedure Uniform3dv(location: Int32; count: Int32; var value: Vec3d);
    external 'opengl32.dll' name 'glUniform3dv';
    static procedure Uniform3dv(location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glUniform3dv';
    
    static procedure Uniform4dv(location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glUniform4dv';
    static procedure Uniform4dv(location: Int32; count: Int32; var value: double);
    external 'opengl32.dll' name 'glUniform4dv';
    static procedure Uniform4dv(location: Int32; count: Int32; var value: Vec4d);
    external 'opengl32.dll' name 'glUniform4dv';
    static procedure Uniform4dv(location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glUniform4dv';
    
    static procedure Uniform1uiv(location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of UInt32);
    external 'opengl32.dll' name 'glUniform1uiv';
    static procedure Uniform1uiv(location: Int32; count: Int32; var value: UInt32);
    external 'opengl32.dll' name 'glUniform1uiv';
    static procedure Uniform1uiv(location: Int32; count: Int32; var value: Vec1ui);
    external 'opengl32.dll' name 'glUniform1uiv';
    static procedure Uniform1uiv(location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glUniform1uiv';
    
    static procedure Uniform2uiv(location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of UInt32);
    external 'opengl32.dll' name 'glUniform2uiv';
    static procedure Uniform2uiv(location: Int32; count: Int32; var value: UInt32);
    external 'opengl32.dll' name 'glUniform2uiv';
    static procedure Uniform2uiv(location: Int32; count: Int32; var value: Vec2ui);
    external 'opengl32.dll' name 'glUniform2uiv';
    static procedure Uniform2uiv(location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glUniform2uiv';
    
    static procedure Uniform3uiv(location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of UInt32);
    external 'opengl32.dll' name 'glUniform3uiv';
    static procedure Uniform3uiv(location: Int32; count: Int32; var value: UInt32);
    external 'opengl32.dll' name 'glUniform3uiv';
    static procedure Uniform3uiv(location: Int32; count: Int32; var value: Vec3ui);
    external 'opengl32.dll' name 'glUniform3uiv';
    static procedure Uniform3uiv(location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glUniform3uiv';
    
    static procedure Uniform4uiv(location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of UInt32);
    external 'opengl32.dll' name 'glUniform4uiv';
    static procedure Uniform4uiv(location: Int32; count: Int32; var value: UInt32);
    external 'opengl32.dll' name 'glUniform4uiv';
    static procedure Uniform4uiv(location: Int32; count: Int32; var value: Vec4ui);
    external 'opengl32.dll' name 'glUniform4uiv';
    static procedure Uniform4uiv(location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glUniform4uiv';
    
    {$endregion Uniform[1,2,3,4][i,f,d,ui]v}
    
    {$region UniformMatrix[2,3,4][f,d]v}
    
    static procedure UniformMatrix2fv(location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glUniformMatrix2fv';
    static procedure UniformMatrix2fv(location: Int32; count: Int32; transpose: boolean; var value: single);
    external 'opengl32.dll' name 'glUniformMatrix2fv';
    static procedure UniformMatrix2fv(location: Int32; count: Int32; transpose: boolean; var value: Mtr2f);
    external 'opengl32.dll' name 'glUniformMatrix2fv';
    static procedure UniformMatrix2fv(location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glUniformMatrix2fv';
    
    static procedure UniformMatrix3fv(location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glUniformMatrix3fv';
    static procedure UniformMatrix3fv(location: Int32; count: Int32; transpose: boolean; var value: single);
    external 'opengl32.dll' name 'glUniformMatrix3fv';
    static procedure UniformMatrix3fv(location: Int32; count: Int32; transpose: boolean; var value: Mtr3f);
    external 'opengl32.dll' name 'glUniformMatrix3fv';
    static procedure UniformMatrix3fv(location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glUniformMatrix3fv';
    
    static procedure UniformMatrix4fv(location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glUniformMatrix4fv';
    static procedure UniformMatrix4fv(location: Int32; count: Int32; transpose: boolean; var value: single);
    external 'opengl32.dll' name 'glUniformMatrix4fv';
    static procedure UniformMatrix4fv(location: Int32; count: Int32; transpose: boolean; var value: Mtr4f);
    external 'opengl32.dll' name 'glUniformMatrix4fv';
    static procedure UniformMatrix4fv(location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glUniformMatrix4fv';
    
    static procedure UniformMatrix2dv(location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glUniformMatrix2dv';
    static procedure UniformMatrix2dv(location: Int32; count: Int32; transpose: boolean; var value: double);
    external 'opengl32.dll' name 'glUniformMatrix2dv';
    static procedure UniformMatrix2dv(location: Int32; count: Int32; transpose: boolean; var value: Mtr2d);
    external 'opengl32.dll' name 'glUniformMatrix2dv';
    static procedure UniformMatrix2dv(location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glUniformMatrix2dv';
    
    static procedure UniformMatrix3dv(location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glUniformMatrix3dv';
    static procedure UniformMatrix3dv(location: Int32; count: Int32; transpose: boolean; var value: double);
    external 'opengl32.dll' name 'glUniformMatrix3dv';
    static procedure UniformMatrix3dv(location: Int32; count: Int32; transpose: boolean; var value: Mtr3d);
    external 'opengl32.dll' name 'glUniformMatrix3dv';
    static procedure UniformMatrix3dv(location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glUniformMatrix3dv';
    
    static procedure UniformMatrix4dv(location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glUniformMatrix4dv';
    static procedure UniformMatrix4dv(location: Int32; count: Int32; transpose: boolean; var value: double);
    external 'opengl32.dll' name 'glUniformMatrix4dv';
    static procedure UniformMatrix4dv(location: Int32; count: Int32; transpose: boolean; var value: Mtr4d);
    external 'opengl32.dll' name 'glUniformMatrix4dv';
    static procedure UniformMatrix4dv(location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glUniformMatrix4dv';
    
    {$endregion UniformMatrix[2,3,4][f,d]v}
    
    {$region UniformMatrix[2x3,3x2,2x4,4x2,3x4,4x3][f,d]v}
    
    static procedure UniformMatrix2x3fv(location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glUniformMatrix2x3fv';
    static procedure UniformMatrix2x3fv(location: Int32; count: Int32; transpose: boolean; var value: single);
    external 'opengl32.dll' name 'glUniformMatrix2x3fv';
    static procedure UniformMatrix2x3fv(location: Int32; count: Int32; transpose: boolean; var value: Mtr2x3f);
    external 'opengl32.dll' name 'glUniformMatrix2x3fv';
    static procedure UniformMatrix2x3fv(location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glUniformMatrix2x3fv';
    
    static procedure UniformMatrix3x2fv(location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glUniformMatrix3x2fv';
    static procedure UniformMatrix3x2fv(location: Int32; count: Int32; transpose: boolean; var value: single);
    external 'opengl32.dll' name 'glUniformMatrix3x2fv';
    static procedure UniformMatrix3x2fv(location: Int32; count: Int32; transpose: boolean; var value: Mtr3x2f);
    external 'opengl32.dll' name 'glUniformMatrix3x2fv';
    static procedure UniformMatrix3x2fv(location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glUniformMatrix3x2fv';
    
    static procedure UniformMatrix2x4fv(location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glUniformMatrix2x4fv';
    static procedure UniformMatrix2x4fv(location: Int32; count: Int32; transpose: boolean; var value: single);
    external 'opengl32.dll' name 'glUniformMatrix2x4fv';
    static procedure UniformMatrix2x4fv(location: Int32; count: Int32; transpose: boolean; var value: Mtr2x4f);
    external 'opengl32.dll' name 'glUniformMatrix2x4fv';
    static procedure UniformMatrix2x4fv(location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glUniformMatrix2x4fv';
    
    static procedure UniformMatrix4x2fv(location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glUniformMatrix4x2fv';
    static procedure UniformMatrix4x2fv(location: Int32; count: Int32; transpose: boolean; var value: single);
    external 'opengl32.dll' name 'glUniformMatrix4x2fv';
    static procedure UniformMatrix4x2fv(location: Int32; count: Int32; transpose: boolean; var value: Mtr4x2f);
    external 'opengl32.dll' name 'glUniformMatrix4x2fv';
    static procedure UniformMatrix4x2fv(location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glUniformMatrix4x2fv';
    
    static procedure UniformMatrix3x4fv(location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glUniformMatrix3x4fv';
    static procedure UniformMatrix3x4fv(location: Int32; count: Int32; transpose: boolean; var value: single);
    external 'opengl32.dll' name 'glUniformMatrix3x4fv';
    static procedure UniformMatrix3x4fv(location: Int32; count: Int32; transpose: boolean; var value: Mtr3x4f);
    external 'opengl32.dll' name 'glUniformMatrix3x4fv';
    static procedure UniformMatrix3x4fv(location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glUniformMatrix3x4fv';
    
    static procedure UniformMatrix4x3fv(location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glUniformMatrix4x3fv';
    static procedure UniformMatrix4x3fv(location: Int32; count: Int32; transpose: boolean; var value: single);
    external 'opengl32.dll' name 'glUniformMatrix4x3fv';
    static procedure UniformMatrix4x3fv(location: Int32; count: Int32; transpose: boolean; var value: Mtr4x3f);
    external 'opengl32.dll' name 'glUniformMatrix4x3fv';
    static procedure UniformMatrix4x3fv(location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glUniformMatrix4x3fv';
    
    static procedure UniformMatrix2x3dv(location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glUniformMatrix2x3dv';
    static procedure UniformMatrix2x3dv(location: Int32; count: Int32; transpose: boolean; var value: double);
    external 'opengl32.dll' name 'glUniformMatrix2x3dv';
    static procedure UniformMatrix2x3dv(location: Int32; count: Int32; transpose: boolean; var value: Mtr2x3d);
    external 'opengl32.dll' name 'glUniformMatrix2x3dv';
    static procedure UniformMatrix2x3dv(location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glUniformMatrix2x3dv';
    
    static procedure UniformMatrix3x2dv(location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glUniformMatrix3x2dv';
    static procedure UniformMatrix3x2dv(location: Int32; count: Int32; transpose: boolean; var value: double);
    external 'opengl32.dll' name 'glUniformMatrix3x2dv';
    static procedure UniformMatrix3x2dv(location: Int32; count: Int32; transpose: boolean; var value: Mtr3x2d);
    external 'opengl32.dll' name 'glUniformMatrix3x2dv';
    static procedure UniformMatrix3x2dv(location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glUniformMatrix3x2dv';
    
    static procedure UniformMatrix2x4dv(location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glUniformMatrix2x4dv';
    static procedure UniformMatrix2x4dv(location: Int32; count: Int32; transpose: boolean; var value: double);
    external 'opengl32.dll' name 'glUniformMatrix2x4dv';
    static procedure UniformMatrix2x4dv(location: Int32; count: Int32; transpose: boolean; var value: Mtr2x4d);
    external 'opengl32.dll' name 'glUniformMatrix2x4dv';
    static procedure UniformMatrix2x4dv(location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glUniformMatrix2x4dv';
    
    static procedure UniformMatrix4x2dv(location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glUniformMatrix4x2dv';
    static procedure UniformMatrix4x2dv(location: Int32; count: Int32; transpose: boolean; var value: double);
    external 'opengl32.dll' name 'glUniformMatrix4x2dv';
    static procedure UniformMatrix4x2dv(location: Int32; count: Int32; transpose: boolean; var value: Mtr4x2d);
    external 'opengl32.dll' name 'glUniformMatrix4x2dv';
    static procedure UniformMatrix4x2dv(location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glUniformMatrix4x2dv';
    
    static procedure UniformMatrix3x4dv(location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glUniformMatrix3x4dv';
    static procedure UniformMatrix3x4dv(location: Int32; count: Int32; transpose: boolean; var value: double);
    external 'opengl32.dll' name 'glUniformMatrix3x4dv';
    static procedure UniformMatrix3x4dv(location: Int32; count: Int32; transpose: boolean; var value: Mtr3x4d);
    external 'opengl32.dll' name 'glUniformMatrix3x4dv';
    static procedure UniformMatrix3x4dv(location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glUniformMatrix3x4dv';
    
    static procedure UniformMatrix4x3dv(location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glUniformMatrix4x3dv';
    static procedure UniformMatrix4x3dv(location: Int32; count: Int32; transpose: boolean; var value: double);
    external 'opengl32.dll' name 'glUniformMatrix4x3dv';
    static procedure UniformMatrix4x3dv(location: Int32; count: Int32; transpose: boolean; var value: Mtr4x3d);
    external 'opengl32.dll' name 'glUniformMatrix4x3dv';
    static procedure UniformMatrix4x3dv(location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glUniformMatrix4x3dv';
    
    {$endregion UniformMatrix[2x3,3x2,2x4,4x2,3x4,4x3][f,d]v}
    
    {$region ProgramUniform[1,2,3,4][i,f,d,ui]}
    
    static procedure ProgramUniform1i(&program: ProgramName; location: Int32; v0: Int32);
    external 'opengl32.dll' name 'glProgramUniform1i';
    
    static procedure ProgramUniform2i(&program: ProgramName; location: Int32; v0: Int32; v1: Int32);
    external 'opengl32.dll' name 'glProgramUniform2i';
    
    static procedure ProgramUniform3i(&program: ProgramName; location: Int32; v0: Int32; v1: Int32; v2: Int32);
    external 'opengl32.dll' name 'glProgramUniform3i';
    
    static procedure ProgramUniform4i(&program: ProgramName; location: Int32; v0: Int32; v1: Int32; v2: Int32; v3: Int32);
    external 'opengl32.dll' name 'glProgramUniform4i';
    
    static procedure ProgramUniform1f(&program: ProgramName; location: Int32; v0: single);
    external 'opengl32.dll' name 'glProgramUniform1f';
    
    static procedure ProgramUniform2f(&program: ProgramName; location: Int32; v0: single; v1: single);
    external 'opengl32.dll' name 'glProgramUniform2f';
    
    static procedure ProgramUniform3f(&program: ProgramName; location: Int32; v0: single; v1: single; v2: single);
    external 'opengl32.dll' name 'glProgramUniform3f';
    
    static procedure ProgramUniform4f(&program: ProgramName; location: Int32; v0: single; v1: single; v2: single; v3: single);
    external 'opengl32.dll' name 'glProgramUniform4f';
    
    static procedure ProgramUniform1d(&program: ProgramName; location: Int32; x: double);
    external 'opengl32.dll' name 'glProgramUniform1d';
    
    static procedure ProgramUniform2d(&program: ProgramName; location: Int32; x: double; y: double);
    external 'opengl32.dll' name 'glProgramUniform2d';
    
    static procedure ProgramUniform3d(&program: ProgramName; location: Int32; x: double; y: double; z: double);
    external 'opengl32.dll' name 'glProgramUniform3d';
    
    static procedure ProgramUniform4d(&program: ProgramName; location: Int32; x: double; y: double; z: double; w: double);
    external 'opengl32.dll' name 'glProgramUniform4d';
    
    static procedure ProgramUniform1ui(&program: ProgramName; location: Int32; v0: UInt32);
    external 'opengl32.dll' name 'glProgramUniform1ui';
    
    static procedure ProgramUniform2ui(&program: ProgramName; location: Int32; v0: UInt32; v1: UInt32);
    external 'opengl32.dll' name 'glProgramUniform2ui';
    
    static procedure ProgramUniform3ui(&program: ProgramName; location: Int32; v0: UInt32; v1: UInt32; v2: UInt32);
    external 'opengl32.dll' name 'glProgramUniform3ui';
    
    static procedure ProgramUniform4ui(&program: ProgramName; location: Int32; v0: UInt32; v1: UInt32; v2: UInt32; v3: UInt32);
    external 'opengl32.dll' name 'glProgramUniform4ui';
    
    {$endregion ProgramUniform[1,2,3,4][i,f,d,ui]}
    
    {$region ProgramUniform[1,2,3,4][i,f,d,ui]v}
    
    static procedure ProgramUniform1iv(&program: ProgramName; location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of Int32);
    external 'opengl32.dll' name 'glProgramUniform1iv';
    static procedure ProgramUniform1iv(&program: ProgramName; location: Int32; count: Int32; var value: Int32);
    external 'opengl32.dll' name 'glProgramUniform1iv';
    static procedure ProgramUniform1iv(&program: ProgramName; location: Int32; count: Int32; var value: Vec1i);
    external 'opengl32.dll' name 'glProgramUniform1iv';
    static procedure ProgramUniform1iv(&program: ProgramName; location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glProgramUniform1iv';
    
    static procedure ProgramUniform2iv(&program: ProgramName; location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of Int32);
    external 'opengl32.dll' name 'glProgramUniform2iv';
    static procedure ProgramUniform2iv(&program: ProgramName; location: Int32; count: Int32; var value: Int32);
    external 'opengl32.dll' name 'glProgramUniform2iv';
    static procedure ProgramUniform2iv(&program: ProgramName; location: Int32; count: Int32; var value: Vec2i);
    external 'opengl32.dll' name 'glProgramUniform2iv';
    static procedure ProgramUniform2iv(&program: ProgramName; location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glProgramUniform2iv';
    
    static procedure ProgramUniform3iv(&program: ProgramName; location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of Int32);
    external 'opengl32.dll' name 'glProgramUniform3iv';
    static procedure ProgramUniform3iv(&program: ProgramName; location: Int32; count: Int32; var value: Int32);
    external 'opengl32.dll' name 'glProgramUniform3iv';
    static procedure ProgramUniform3iv(&program: ProgramName; location: Int32; count: Int32; var value: Vec3i);
    external 'opengl32.dll' name 'glProgramUniform3iv';
    static procedure ProgramUniform3iv(&program: ProgramName; location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glProgramUniform3iv';
    
    static procedure ProgramUniform4iv(&program: ProgramName; location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of Int32);
    external 'opengl32.dll' name 'glProgramUniform4iv';
    static procedure ProgramUniform4iv(&program: ProgramName; location: Int32; count: Int32; var value: Int32);
    external 'opengl32.dll' name 'glProgramUniform4iv';
    static procedure ProgramUniform4iv(&program: ProgramName; location: Int32; count: Int32; var value: Vec4i);
    external 'opengl32.dll' name 'glProgramUniform4iv';
    static procedure ProgramUniform4iv(&program: ProgramName; location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glProgramUniform4iv';
    
    static procedure ProgramUniform1fv(&program: ProgramName; location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glProgramUniform1fv';
    static procedure ProgramUniform1fv(&program: ProgramName; location: Int32; count: Int32; var value: single);
    external 'opengl32.dll' name 'glProgramUniform1fv';
    static procedure ProgramUniform1fv(&program: ProgramName; location: Int32; count: Int32; var value: Vec1f);
    external 'opengl32.dll' name 'glProgramUniform1fv';
    static procedure ProgramUniform1fv(&program: ProgramName; location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glProgramUniform1fv';
    
    static procedure ProgramUniform2fv(&program: ProgramName; location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glProgramUniform2fv';
    static procedure ProgramUniform2fv(&program: ProgramName; location: Int32; count: Int32; var value: single);
    external 'opengl32.dll' name 'glProgramUniform2fv';
    static procedure ProgramUniform2fv(&program: ProgramName; location: Int32; count: Int32; var value: Vec2f);
    external 'opengl32.dll' name 'glProgramUniform2fv';
    static procedure ProgramUniform2fv(&program: ProgramName; location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glProgramUniform2fv';
    
    static procedure ProgramUniform3fv(&program: ProgramName; location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glProgramUniform3fv';
    static procedure ProgramUniform3fv(&program: ProgramName; location: Int32; count: Int32; var value: single);
    external 'opengl32.dll' name 'glProgramUniform3fv';
    static procedure ProgramUniform3fv(&program: ProgramName; location: Int32; count: Int32; var value: Vec3f);
    external 'opengl32.dll' name 'glProgramUniform3fv';
    static procedure ProgramUniform3fv(&program: ProgramName; location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glProgramUniform3fv';
    
    static procedure ProgramUniform4fv(&program: ProgramName; location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glProgramUniform4fv';
    static procedure ProgramUniform4fv(&program: ProgramName; location: Int32; count: Int32; var value: single);
    external 'opengl32.dll' name 'glProgramUniform4fv';
    static procedure ProgramUniform4fv(&program: ProgramName; location: Int32; count: Int32; var value: Vec4f);
    external 'opengl32.dll' name 'glProgramUniform4fv';
    static procedure ProgramUniform4fv(&program: ProgramName; location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glProgramUniform4fv';
    
    static procedure ProgramUniform1dv(&program: ProgramName; location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glProgramUniform1dv';
    static procedure ProgramUniform1dv(&program: ProgramName; location: Int32; count: Int32; var value: double);
    external 'opengl32.dll' name 'glProgramUniform1dv';
    static procedure ProgramUniform1dv(&program: ProgramName; location: Int32; count: Int32; var value: Vec1d);
    external 'opengl32.dll' name 'glProgramUniform1dv';
    static procedure ProgramUniform1dv(&program: ProgramName; location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glProgramUniform1dv';
    
    static procedure ProgramUniform2dv(&program: ProgramName; location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glProgramUniform2dv';
    static procedure ProgramUniform2dv(&program: ProgramName; location: Int32; count: Int32; var value: double);
    external 'opengl32.dll' name 'glProgramUniform2dv';
    static procedure ProgramUniform2dv(&program: ProgramName; location: Int32; count: Int32; var value: Vec2d);
    external 'opengl32.dll' name 'glProgramUniform2dv';
    static procedure ProgramUniform2dv(&program: ProgramName; location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glProgramUniform2dv';
    
    static procedure ProgramUniform3dv(&program: ProgramName; location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glProgramUniform3dv';
    static procedure ProgramUniform3dv(&program: ProgramName; location: Int32; count: Int32; var value: double);
    external 'opengl32.dll' name 'glProgramUniform3dv';
    static procedure ProgramUniform3dv(&program: ProgramName; location: Int32; count: Int32; var value: Vec3d);
    external 'opengl32.dll' name 'glProgramUniform3dv';
    static procedure ProgramUniform3dv(&program: ProgramName; location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glProgramUniform3dv';
    
    static procedure ProgramUniform4dv(&program: ProgramName; location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glProgramUniform4dv';
    static procedure ProgramUniform4dv(&program: ProgramName; location: Int32; count: Int32; var value: double);
    external 'opengl32.dll' name 'glProgramUniform4dv';
    static procedure ProgramUniform4dv(&program: ProgramName; location: Int32; count: Int32; var value: Vec4d);
    external 'opengl32.dll' name 'glProgramUniform4dv';
    static procedure ProgramUniform4dv(&program: ProgramName; location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glProgramUniform4dv';
    
    static procedure ProgramUniform1uiv(&program: ProgramName; location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of UInt32);
    external 'opengl32.dll' name 'glProgramUniform1uiv';
    static procedure ProgramUniform1uiv(&program: ProgramName; location: Int32; count: Int32; var value: UInt32);
    external 'opengl32.dll' name 'glProgramUniform1uiv';
    static procedure ProgramUniform1uiv(&program: ProgramName; location: Int32; count: Int32; var value: Vec1ui);
    external 'opengl32.dll' name 'glProgramUniform1uiv';
    static procedure ProgramUniform1uiv(&program: ProgramName; location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glProgramUniform1uiv';
    
    static procedure ProgramUniform2uiv(&program: ProgramName; location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of UInt32);
    external 'opengl32.dll' name 'glProgramUniform2uiv';
    static procedure ProgramUniform2uiv(&program: ProgramName; location: Int32; count: Int32; var value: UInt32);
    external 'opengl32.dll' name 'glProgramUniform2uiv';
    static procedure ProgramUniform2uiv(&program: ProgramName; location: Int32; count: Int32; var value: Vec2ui);
    external 'opengl32.dll' name 'glProgramUniform2uiv';
    static procedure ProgramUniform2uiv(&program: ProgramName; location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glProgramUniform2uiv';
    
    static procedure ProgramUniform3uiv(&program: ProgramName; location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of UInt32);
    external 'opengl32.dll' name 'glProgramUniform3uiv';
    static procedure ProgramUniform3uiv(&program: ProgramName; location: Int32; count: Int32; var value: UInt32);
    external 'opengl32.dll' name 'glProgramUniform3uiv';
    static procedure ProgramUniform3uiv(&program: ProgramName; location: Int32; count: Int32; var value: Vec3ui);
    external 'opengl32.dll' name 'glProgramUniform3uiv';
    static procedure ProgramUniform3uiv(&program: ProgramName; location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glProgramUniform3uiv';
    
    static procedure ProgramUniform4uiv(&program: ProgramName; location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of UInt32);
    external 'opengl32.dll' name 'glProgramUniform4uiv';
    static procedure ProgramUniform4uiv(&program: ProgramName; location: Int32; count: Int32; var value: UInt32);
    external 'opengl32.dll' name 'glProgramUniform4uiv';
    static procedure ProgramUniform4uiv(&program: ProgramName; location: Int32; count: Int32; var value: Vec4ui);
    external 'opengl32.dll' name 'glProgramUniform4uiv';
    static procedure ProgramUniform4uiv(&program: ProgramName; location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glProgramUniform4uiv';
    
    {$endregion ProgramUniform[1,2,3,4][i,f,d,ui]v}
    
    {$region ProgramUniformMatrix[2,3,4][f,d]v}
    
    static procedure ProgramUniformMatrix2fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glProgramUniformMatrix2fv';
    static procedure ProgramUniformMatrix2fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: single);
    external 'opengl32.dll' name 'glProgramUniformMatrix2fv';
    static procedure ProgramUniformMatrix2fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr2f);
    external 'opengl32.dll' name 'glProgramUniformMatrix2fv';
    static procedure ProgramUniformMatrix2fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glProgramUniformMatrix2fv';
    
    static procedure ProgramUniformMatrix3fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glProgramUniformMatrix3fv';
    static procedure ProgramUniformMatrix3fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: single);
    external 'opengl32.dll' name 'glProgramUniformMatrix3fv';
    static procedure ProgramUniformMatrix3fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr3f);
    external 'opengl32.dll' name 'glProgramUniformMatrix3fv';
    static procedure ProgramUniformMatrix3fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glProgramUniformMatrix3fv';
    
    static procedure ProgramUniformMatrix4fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glProgramUniformMatrix4fv';
    static procedure ProgramUniformMatrix4fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: single);
    external 'opengl32.dll' name 'glProgramUniformMatrix4fv';
    static procedure ProgramUniformMatrix4fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr4f);
    external 'opengl32.dll' name 'glProgramUniformMatrix4fv';
    static procedure ProgramUniformMatrix4fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glProgramUniformMatrix4fv';
    
    static procedure ProgramUniformMatrix2dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glProgramUniformMatrix2dv';
    static procedure ProgramUniformMatrix2dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: double);
    external 'opengl32.dll' name 'glProgramUniformMatrix2dv';
    static procedure ProgramUniformMatrix2dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr2d);
    external 'opengl32.dll' name 'glProgramUniformMatrix2dv';
    static procedure ProgramUniformMatrix2dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glProgramUniformMatrix2dv';
    
    static procedure ProgramUniformMatrix3dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glProgramUniformMatrix3dv';
    static procedure ProgramUniformMatrix3dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: double);
    external 'opengl32.dll' name 'glProgramUniformMatrix3dv';
    static procedure ProgramUniformMatrix3dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr3d);
    external 'opengl32.dll' name 'glProgramUniformMatrix3dv';
    static procedure ProgramUniformMatrix3dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glProgramUniformMatrix3dv';
    
    static procedure ProgramUniformMatrix4dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glProgramUniformMatrix4dv';
    static procedure ProgramUniformMatrix4dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: double);
    external 'opengl32.dll' name 'glProgramUniformMatrix4dv';
    static procedure ProgramUniformMatrix4dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr4d);
    external 'opengl32.dll' name 'glProgramUniformMatrix4dv';
    static procedure ProgramUniformMatrix4dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glProgramUniformMatrix4dv';
    
    {$endregion ProgramUniformMatrix[2,3,4][f,d]v}
    
    {$region ProgramUniformMatrix[2x3,3x2,2x4,4x2,3x4,4x3][f,d]v}
    
    static procedure ProgramUniformMatrix2x3fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glProgramUniformMatrix2x3fv';
    static procedure ProgramUniformMatrix2x3fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: single);
    external 'opengl32.dll' name 'glProgramUniformMatrix2x3fv';
    static procedure ProgramUniformMatrix2x3fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr2x3f);
    external 'opengl32.dll' name 'glProgramUniformMatrix2x3fv';
    static procedure ProgramUniformMatrix2x3fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glProgramUniformMatrix2x3fv';
    
    static procedure ProgramUniformMatrix3x2fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glProgramUniformMatrix3x2fv';
    static procedure ProgramUniformMatrix3x2fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: single);
    external 'opengl32.dll' name 'glProgramUniformMatrix3x2fv';
    static procedure ProgramUniformMatrix3x2fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr3x2f);
    external 'opengl32.dll' name 'glProgramUniformMatrix3x2fv';
    static procedure ProgramUniformMatrix3x2fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glProgramUniformMatrix3x2fv';
    
    static procedure ProgramUniformMatrix2x4fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glProgramUniformMatrix2x4fv';
    static procedure ProgramUniformMatrix2x4fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: single);
    external 'opengl32.dll' name 'glProgramUniformMatrix2x4fv';
    static procedure ProgramUniformMatrix2x4fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr2x4f);
    external 'opengl32.dll' name 'glProgramUniformMatrix2x4fv';
    static procedure ProgramUniformMatrix2x4fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glProgramUniformMatrix2x4fv';
    
    static procedure ProgramUniformMatrix4x2fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glProgramUniformMatrix4x2fv';
    static procedure ProgramUniformMatrix4x2fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: single);
    external 'opengl32.dll' name 'glProgramUniformMatrix4x2fv';
    static procedure ProgramUniformMatrix4x2fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr4x2f);
    external 'opengl32.dll' name 'glProgramUniformMatrix4x2fv';
    static procedure ProgramUniformMatrix4x2fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glProgramUniformMatrix4x2fv';
    
    static procedure ProgramUniformMatrix3x4fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glProgramUniformMatrix3x4fv';
    static procedure ProgramUniformMatrix3x4fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: single);
    external 'opengl32.dll' name 'glProgramUniformMatrix3x4fv';
    static procedure ProgramUniformMatrix3x4fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr3x4f);
    external 'opengl32.dll' name 'glProgramUniformMatrix3x4fv';
    static procedure ProgramUniformMatrix3x4fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glProgramUniformMatrix3x4fv';
    
    static procedure ProgramUniformMatrix4x3fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glProgramUniformMatrix4x3fv';
    static procedure ProgramUniformMatrix4x3fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: single);
    external 'opengl32.dll' name 'glProgramUniformMatrix4x3fv';
    static procedure ProgramUniformMatrix4x3fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr4x3f);
    external 'opengl32.dll' name 'glProgramUniformMatrix4x3fv';
    static procedure ProgramUniformMatrix4x3fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glProgramUniformMatrix4x3fv';
    
    static procedure ProgramUniformMatrix2x3dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glProgramUniformMatrix2x3dv';
    static procedure ProgramUniformMatrix2x3dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: double);
    external 'opengl32.dll' name 'glProgramUniformMatrix2x3dv';
    static procedure ProgramUniformMatrix2x3dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr2x3d);
    external 'opengl32.dll' name 'glProgramUniformMatrix2x3dv';
    static procedure ProgramUniformMatrix2x3dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glProgramUniformMatrix2x3dv';
    
    static procedure ProgramUniformMatrix3x2dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glProgramUniformMatrix3x2dv';
    static procedure ProgramUniformMatrix3x2dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: double);
    external 'opengl32.dll' name 'glProgramUniformMatrix3x2dv';
    static procedure ProgramUniformMatrix3x2dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr3x2d);
    external 'opengl32.dll' name 'glProgramUniformMatrix3x2dv';
    static procedure ProgramUniformMatrix3x2dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glProgramUniformMatrix3x2dv';
    
    static procedure ProgramUniformMatrix2x4dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glProgramUniformMatrix2x4dv';
    static procedure ProgramUniformMatrix2x4dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: double);
    external 'opengl32.dll' name 'glProgramUniformMatrix2x4dv';
    static procedure ProgramUniformMatrix2x4dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr2x4d);
    external 'opengl32.dll' name 'glProgramUniformMatrix2x4dv';
    static procedure ProgramUniformMatrix2x4dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glProgramUniformMatrix2x4dv';
    
    static procedure ProgramUniformMatrix4x2dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glProgramUniformMatrix4x2dv';
    static procedure ProgramUniformMatrix4x2dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: double);
    external 'opengl32.dll' name 'glProgramUniformMatrix4x2dv';
    static procedure ProgramUniformMatrix4x2dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr4x2d);
    external 'opengl32.dll' name 'glProgramUniformMatrix4x2dv';
    static procedure ProgramUniformMatrix4x2dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glProgramUniformMatrix4x2dv';
    
    static procedure ProgramUniformMatrix3x4dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glProgramUniformMatrix3x4dv';
    static procedure ProgramUniformMatrix3x4dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: double);
    external 'opengl32.dll' name 'glProgramUniformMatrix3x4dv';
    static procedure ProgramUniformMatrix3x4dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr3x4d);
    external 'opengl32.dll' name 'glProgramUniformMatrix3x4dv';
    static procedure ProgramUniformMatrix3x4dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glProgramUniformMatrix3x4dv';
    
    static procedure ProgramUniformMatrix4x3dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glProgramUniformMatrix4x3dv';
    static procedure ProgramUniformMatrix4x3dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: double);
    external 'opengl32.dll' name 'glProgramUniformMatrix4x3dv';
    static procedure ProgramUniformMatrix4x3dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr4x3d);
    external 'opengl32.dll' name 'glProgramUniformMatrix4x3dv';
    static procedure ProgramUniformMatrix4x3dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glProgramUniformMatrix4x3dv';
    
    {$endregion ProgramUniformMatrix[2x3,3x2,2x4,4x2,3x4,4x3][f,d]v}
    
    // 7.6.3
    
    static procedure UniformBlockBinding(&program: ProgramName; uniformBlockIndex: UInt32; uniformBlockBinding: UInt32);
    external 'opengl32.dll' name 'glUniformBlockBinding';
    
    {$endregion 7.6 - Uniform Variables}
    
    {$region 7.8 - Shader Buffer Variables and Shader Storage Blocks}
    
    static procedure ShaderStorageBlockBinding(&program: ProgramName; storageBlockIndex: UInt32; storageBlockBinding: UInt32);
    external 'opengl32.dll' name 'glShaderStorageBlockBinding';
    
    {$endregion 7.8 - Shader Buffer Variables and Shader Storage Blocks}
    
    {$region 7.10 - Subroutine Uniform Variables}
    
    static function GetSubroutineIndex(&program: ProgramName; _shadertype: ShaderType; [MarshalAs(UnmanagedType.LPStr)] name: string): UInt32;
    external 'opengl32.dll' name 'glGetSubroutineIndex';
    static function GetSubroutineIndex(&program: ProgramName; _shadertype: ShaderType; name: IntPtr): UInt32;
    external 'opengl32.dll' name 'glGetSubroutineIndex';
    
    static procedure GetActiveSubroutineName(&program: ProgramName; _shadertype: ShaderType; index: UInt32; bufsize: Int32; var length: Int32; [MarshalAs(UnmanagedType.LPStr)] name: string);
    external 'opengl32.dll' name 'glGetActiveSubroutineName';
    static procedure GetActiveSubroutineName(&program: ProgramName; _shadertype: ShaderType; index: UInt32; bufsize: Int32; var length: Int32; name: IntPtr);
    external 'opengl32.dll' name 'glGetActiveSubroutineName';
    static procedure GetActiveSubroutineName(&program: ProgramName; _shadertype: ShaderType; index: UInt32; bufsize: Int32; length: pointer; [MarshalAs(UnmanagedType.LPStr)] name: string);
    external 'opengl32.dll' name 'glGetActiveSubroutineName';
    static procedure GetActiveSubroutineName(&program: ProgramName; _shadertype: ShaderType; index: UInt32; bufsize: Int32; length: pointer; name: IntPtr);
    external 'opengl32.dll' name 'glGetActiveSubroutineName';
    
    static function GetSubroutineUniformLocation(&program: ProgramName; _shadertype: ShaderType; [MarshalAs(UnmanagedType.LPStr)] name: string): Int32;
    external 'opengl32.dll' name 'glGetSubroutineUniformLocation';
    static function GetSubroutineUniformLocation(&program: ProgramName; _shadertype: ShaderType; name: IntPtr): Int32;
    external 'opengl32.dll' name 'glGetSubroutineUniformLocation';
    
    static procedure GetActiveSubroutineUniformName(&program: ProgramName; _shadertype: ShaderType; index: UInt32; bufsize: Int32; var length: Int32; [MarshalAs(UnmanagedType.LPStr)] name: string);
    external 'opengl32.dll' name 'glGetActiveSubroutineUniformName';
    static procedure GetActiveSubroutineUniformName(&program: ProgramName; _shadertype: ShaderType; index: UInt32; bufsize: Int32; var length: Int32; name: IntPtr);
    external 'opengl32.dll' name 'glGetActiveSubroutineUniformName';
    static procedure GetActiveSubroutineUniformName(&program: ProgramName; _shadertype: ShaderType; index: UInt32; bufsize: Int32; length: pointer; [MarshalAs(UnmanagedType.LPStr)] name: string);
    external 'opengl32.dll' name 'glGetActiveSubroutineUniformName';
    static procedure GetActiveSubroutineUniformName(&program: ProgramName; _shadertype: ShaderType; index: UInt32; bufsize: Int32; length: pointer; name: IntPtr);
    external 'opengl32.dll' name 'glGetActiveSubroutineUniformName';
    
    static procedure GetActiveSubroutineUniformiv(&program: ProgramName; _shadertype: ShaderType; index: UInt32; pname: ProgramInterfaceProperty; [MarshalAs(UnmanagedType.LPArray)] values: array of Int32);
    external 'opengl32.dll' name 'glGetActiveSubroutineUniformiv';
    static procedure GetActiveSubroutineUniformiv(&program: ProgramName; _shadertype: ShaderType; index: UInt32; pname: ProgramInterfaceProperty; var values: Int32);
    external 'opengl32.dll' name 'glGetActiveSubroutineUniformiv';
    static procedure GetActiveSubroutineUniformiv(&program: ProgramName; _shadertype: ShaderType; index: UInt32; pname: ProgramInterfaceProperty; values: pointer);
    external 'opengl32.dll' name 'glGetActiveSubroutineUniformiv';
    
    static procedure UniformSubroutinesuiv(_shadertype: ShaderType; count: Int32; [MarshalAs(UnmanagedType.LPArray)] indices: array of UInt32);
    external 'opengl32.dll' name 'glUniformSubroutinesuiv';
    static procedure UniformSubroutinesuiv(_shadertype: ShaderType; count: Int32; var indices: UInt32);
    external 'opengl32.dll' name 'glUniformSubroutinesuiv';
    static procedure UniformSubroutinesuiv(_shadertype: ShaderType; count: Int32; indices: pointer);
    external 'opengl32.dll' name 'glUniformSubroutinesuiv';
    
    {$endregion 7.10 - Subroutine Uniform Variables}
    
    {$region 7.13 - Shader Memory Access}
    
    //7.13.2
    
    static procedure MemoryBarrier(barriers: MemoryBarrierTypeFlags);
    external 'opengl32.dll' name 'glMemoryBarrier';
    
    static procedure MemoryBarrierByRegion(barriers: MemoryBarrierTypeFlags);
    external 'opengl32.dll' name 'glMemoryBarrierByRegion';
    
    {$endregion 7.13 - Shader Memory Access}
    
    {$region 7.14 - Shader, Program, and Program Pipeline Queries}
    
    static procedure GetShaderiv(shader: ShaderName; pname: ShaderInfoType; [MarshalAs(UnmanagedType.LPArray)] &params: array of Int32);
    external 'opengl32.dll' name 'glGetShaderiv';
    static procedure GetShaderiv(shader: ShaderName; pname: ShaderInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetShaderiv';
    static procedure GetShaderiv(shader: ShaderName; pname: ShaderInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetShaderiv';
    
    static procedure GetProgramiv(&program: ProgramName; pname: ProgramInfoType; [MarshalAs(UnmanagedType.LPArray)] &params: array of Int32);
    external 'opengl32.dll' name 'glGetProgramiv';
    static procedure GetProgramiv(&program: ProgramName; pname: ProgramInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetProgramiv';
    static procedure GetProgramiv(&program: ProgramName; pname: ProgramInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetProgramiv';
    
    static procedure GetProgramPipelineiv(pipeline: ProgramPipelineName; pname: ProgramPipelineInfoType; var &params: ProgramName);
    external 'opengl32.dll' name 'glGetProgramPipelineiv';
    static procedure GetProgramPipelineiv(pipeline: ProgramPipelineName; pname: ProgramPipelineInfoType; var &params: ErrorCode);
    external 'opengl32.dll' name 'glGetProgramPipelineiv';
    static procedure GetProgramPipelineiv(pipeline: ProgramPipelineName; pname: ProgramPipelineInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetProgramPipelineiv';
    static procedure GetProgramPipelineiv(pipeline: ProgramPipelineName; pname: ProgramPipelineInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetProgramPipelineiv';
    
    static procedure GetAttachedShaders(&program: ProgramName; maxCount: Int32; var count: Int32; [MarshalAs(UnmanagedType.LPArray)] shaders: array of ShaderName);
    external 'opengl32.dll' name 'glGetAttachedShaders';
    static procedure GetAttachedShaders(&program: ProgramName; maxCount: Int32; var count: Int32; var shaders: ShaderName);
    external 'opengl32.dll' name 'glGetAttachedShaders';
    static procedure GetAttachedShaders(&program: ProgramName; maxCount: Int32; var count: Int32; shaders: pointer);
    external 'opengl32.dll' name 'glGetAttachedShaders';
    static procedure GetAttachedShaders(&program: ProgramName; maxCount: Int32; count: pointer; [MarshalAs(UnmanagedType.LPArray)] shaders: array of ShaderName);
    external 'opengl32.dll' name 'glGetAttachedShaders';
    static procedure GetAttachedShaders(&program: ProgramName; maxCount: Int32; count: pointer; var shaders: ShaderName);
    external 'opengl32.dll' name 'glGetAttachedShaders';
    static procedure GetAttachedShaders(&program: ProgramName; maxCount: Int32; count: pointer; shaders: pointer);
    external 'opengl32.dll' name 'glGetAttachedShaders';
    
    static procedure GetShaderInfoLog(shader: ShaderName; bufSize: Int32; var length: Int32; [MarshalAs(UnmanagedType.LPStr)] infoLog: string);
    external 'opengl32.dll' name 'glGetShaderInfoLog';
    static procedure GetShaderInfoLog(shader: ShaderName; bufSize: Int32; var length: Int32; infoLog: IntPtr);
    external 'opengl32.dll' name 'glGetShaderInfoLog';
    static procedure GetShaderInfoLog(shader: ShaderName; bufSize: Int32; length: pointer; [MarshalAs(UnmanagedType.LPStr)] infoLog: string);
    external 'opengl32.dll' name 'glGetShaderInfoLog';
    static procedure GetShaderInfoLog(shader: ShaderName; bufSize: Int32; length: pointer; infoLog: IntPtr);
    external 'opengl32.dll' name 'glGetShaderInfoLog';
    
    static procedure GetProgramInfoLog(&program: ProgramName; bufSize: Int32; var length: Int32; [MarshalAs(UnmanagedType.LPStr)] infoLog: string);
    external 'opengl32.dll' name 'glGetProgramInfoLog';
    static procedure GetProgramInfoLog(&program: ProgramName; bufSize: Int32; var length: Int32; infoLog: IntPtr);
    external 'opengl32.dll' name 'glGetProgramInfoLog';
    static procedure GetProgramInfoLog(&program: ProgramName; bufSize: Int32; length: pointer; [MarshalAs(UnmanagedType.LPStr)] infoLog: string);
    external 'opengl32.dll' name 'glGetProgramInfoLog';
    static procedure GetProgramInfoLog(&program: ProgramName; bufSize: Int32; length: pointer; infoLog: IntPtr);
    external 'opengl32.dll' name 'glGetProgramInfoLog';
    
    static procedure GetProgramPipelineInfoLog(pipeline: ProgramPipelineName; bufSize: Int32; var length: Int32; [MarshalAs(UnmanagedType.LPStr)] infoLog: string);
    external 'opengl32.dll' name 'glGetProgramPipelineInfoLog';
    static procedure GetProgramPipelineInfoLog(pipeline: ProgramPipelineName; bufSize: Int32; var length: Int32; infoLog: IntPtr);
    external 'opengl32.dll' name 'glGetProgramPipelineInfoLog';
    static procedure GetProgramPipelineInfoLog(pipeline: ProgramPipelineName; bufSize: Int32; length: pointer; [MarshalAs(UnmanagedType.LPStr)] infoLog: string);
    external 'opengl32.dll' name 'glGetProgramPipelineInfoLog';
    static procedure GetProgramPipelineInfoLog(pipeline: ProgramPipelineName; bufSize: Int32; length: pointer; infoLog: IntPtr);
    external 'opengl32.dll' name 'glGetProgramPipelineInfoLog';
    
    static procedure GetShaderSource(shader: ShaderName; bufSize: Int32; var length: Int32; [MarshalAs(UnmanagedType.LPStr)] source: string);
    external 'opengl32.dll' name 'glGetShaderSource';
    static procedure GetShaderSource(shader: ShaderName; bufSize: Int32; var length: Int32; source: IntPtr);
    external 'opengl32.dll' name 'glGetShaderSource';
    static procedure GetShaderSource(shader: ShaderName; bufSize: Int32; length: pointer; [MarshalAs(UnmanagedType.LPStr)] source: string);
    external 'opengl32.dll' name 'glGetShaderSource';
    static procedure GetShaderSource(shader: ShaderName; bufSize: Int32; length: pointer; source: IntPtr);
    external 'opengl32.dll' name 'glGetShaderSource';
    
    static procedure GetShaderPrecisionFormat(_shadertype: ShaderType; precisiontype: ShaderPrecisionFormatType; [MarshalAs(UnmanagedType.LPArray)] range: array of Int32; var precision: Int32);
    external 'opengl32.dll' name 'glGetShaderPrecisionFormat';
    static procedure GetShaderPrecisionFormat(_shadertype: ShaderType; precisiontype: ShaderPrecisionFormatType; [MarshalAs(UnmanagedType.LPArray)] range: array of Int32; precision: pointer);
    external 'opengl32.dll' name 'glGetShaderPrecisionFormat';
    static procedure GetShaderPrecisionFormat(_shadertype: ShaderType; precisiontype: ShaderPrecisionFormatType; var range: Vec2i; var precision: Int32);
    external 'opengl32.dll' name 'glGetShaderPrecisionFormat';
    static procedure GetShaderPrecisionFormat(_shadertype: ShaderType; precisiontype: ShaderPrecisionFormatType; var range: Vec2i; precision: pointer);
    external 'opengl32.dll' name 'glGetShaderPrecisionFormat';
    static procedure GetShaderPrecisionFormat(_shadertype: ShaderType; precisiontype: ShaderPrecisionFormatType; range: pointer; var precision: Int32);
    external 'opengl32.dll' name 'glGetShaderPrecisionFormat';
    static procedure GetShaderPrecisionFormat(_shadertype: ShaderType; precisiontype: ShaderPrecisionFormatType; range: pointer; precision: pointer);
    external 'opengl32.dll' name 'glGetShaderPrecisionFormat';
    
    static procedure GetUniformfv(&program: ProgramName; location: Int32; [MarshalAs(UnmanagedType.LPArray)] &params: array of single);
    external 'opengl32.dll' name 'glGetUniformfv';
    static procedure GetUniformfv(&program: ProgramName; location: Int32; var &params: single);
    external 'opengl32.dll' name 'glGetUniformfv';
    static procedure GetUniformfv(&program: ProgramName; location: Int32; &params: pointer);
    external 'opengl32.dll' name 'glGetUniformfv';
    
    static procedure GetUniformdv(&program: ProgramName; location: Int32; [MarshalAs(UnmanagedType.LPArray)] &params: array of double);
    external 'opengl32.dll' name 'glGetUniformdv';
    static procedure GetUniformdv(&program: ProgramName; location: Int32; var &params: double);
    external 'opengl32.dll' name 'glGetUniformdv';
    static procedure GetUniformdv(&program: ProgramName; location: Int32; &params: pointer);
    external 'opengl32.dll' name 'glGetUniformdv';
    
    static procedure GetUniformiv(&program: ProgramName; location: Int32; [MarshalAs(UnmanagedType.LPArray)] &params: array of Int32);
    external 'opengl32.dll' name 'glGetUniformiv';
    static procedure GetUniformiv(&program: ProgramName; location: Int32; var &params: Int32);
    external 'opengl32.dll' name 'glGetUniformiv';
    static procedure GetUniformiv(&program: ProgramName; location: Int32; &params: pointer);
    external 'opengl32.dll' name 'glGetUniformiv';
    
    static procedure GetUniformuiv(&program: ProgramName; location: Int32; [MarshalAs(UnmanagedType.LPArray)] &params: array of UInt32);
    external 'opengl32.dll' name 'glGetUniformuiv';
    static procedure GetUniformuiv(&program: ProgramName; location: Int32; var &params: UInt32);
    external 'opengl32.dll' name 'glGetUniformuiv';
    static procedure GetUniformuiv(&program: ProgramName; location: Int32; &params: pointer);
    external 'opengl32.dll' name 'glGetUniformuiv';
    
    static procedure GetnUniformfv(&program: ProgramName; location: Int32; bufSize: Int32; [MarshalAs(UnmanagedType.LPArray)] &params: array of single);
    external 'opengl32.dll' name 'glGetnUniformfv';
    static procedure GetnUniformfv(&program: ProgramName; location: Int32; bufSize: Int32; var &params: single);
    external 'opengl32.dll' name 'glGetnUniformfv';
    static procedure GetnUniformfv(&program: ProgramName; location: Int32; bufSize: Int32; &params: pointer);
    external 'opengl32.dll' name 'glGetnUniformfv';
    
    static procedure GetnUniformdv(&program: ProgramName; location: Int32; bufSize: Int32; [MarshalAs(UnmanagedType.LPArray)] &params: array of double);
    external 'opengl32.dll' name 'glGetnUniformdv';
    static procedure GetnUniformdv(&program: ProgramName; location: Int32; bufSize: Int32; var &params: double);
    external 'opengl32.dll' name 'glGetnUniformdv';
    static procedure GetnUniformdv(&program: ProgramName; location: Int32; bufSize: Int32; &params: pointer);
    external 'opengl32.dll' name 'glGetnUniformdv';
    
    static procedure GetnUniformiv(&program: ProgramName; location: Int32; bufSize: Int32; [MarshalAs(UnmanagedType.LPArray)] &params: array of Int32);
    external 'opengl32.dll' name 'glGetnUniformiv';
    static procedure GetnUniformiv(&program: ProgramName; location: Int32; bufSize: Int32; var &params: Int32);
    external 'opengl32.dll' name 'glGetnUniformiv';
    static procedure GetnUniformiv(&program: ProgramName; location: Int32; bufSize: Int32; &params: pointer);
    external 'opengl32.dll' name 'glGetnUniformiv';
    
    static procedure GetnUniformuiv(&program: ProgramName; location: Int32; bufSize: Int32; [MarshalAs(UnmanagedType.LPArray)] &params: array of UInt32);
    external 'opengl32.dll' name 'glGetnUniformuiv';
    static procedure GetnUniformuiv(&program: ProgramName; location: Int32; bufSize: Int32; var &params: UInt32);
    external 'opengl32.dll' name 'glGetnUniformuiv';
    static procedure GetnUniformuiv(&program: ProgramName; location: Int32; bufSize: Int32; &params: pointer);
    external 'opengl32.dll' name 'glGetnUniformuiv';
    
    static procedure GetUniformSubroutineuiv(_shadertype: ShaderType; location: Int32; [MarshalAs(UnmanagedType.LPArray)] &params: array of UInt32);
    external 'opengl32.dll' name 'glGetUniformSubroutineuiv';
    static procedure GetUniformSubroutineuiv(_shadertype: ShaderType; location: Int32; var &params: UInt32);
    external 'opengl32.dll' name 'glGetUniformSubroutineuiv';
    static procedure GetUniformSubroutineuiv(_shadertype: ShaderType; location: Int32; &params: pointer);
    external 'opengl32.dll' name 'glGetUniformSubroutineuiv';
    
    static procedure GetProgramStageiv(&program: ProgramName; _shadertype: ShaderType; pname: ActiveSubroutineInfoType; [MarshalAs(UnmanagedType.LPArray)] values: array of Int32);
    external 'opengl32.dll' name 'glGetProgramStageiv';
    static procedure GetProgramStageiv(&program: ProgramName; _shadertype: ShaderType; pname: ActiveSubroutineInfoType; var values: Int32);
    external 'opengl32.dll' name 'glGetProgramStageiv';
    static procedure GetProgramStageiv(&program: ProgramName; _shadertype: ShaderType; pname: ActiveSubroutineInfoType; values: pointer);
    external 'opengl32.dll' name 'glGetProgramStageiv';
    
    {$endregion 7.14 - Shader, Program, and Program Pipeline Queries}
    
    {$endregion 7.0 - Programs and Shaders}
    
    {$region 8.0 - Textures and Samplers}
    
    static procedure ActiveTexture(texture: TextureUnitId);
    external 'opengl32.dll' name 'glActiveTexture';
    
    {$region 8.1 - Texture Objects}
    
    static procedure GenTextures(n: Int32; [MarshalAs(UnmanagedType.LPArray)] textures: array of TextureName);
    external 'opengl32.dll' name 'glGenTextures';
    static procedure GenTextures(n: Int32; var textures: TextureName);
    external 'opengl32.dll' name 'glGenTextures';
    static procedure GenTextures(n: Int32; textures: pointer);
    external 'opengl32.dll' name 'glGenTextures';
    
    static procedure BindTexture(target: TextureBindTarget; texture: TextureName);
    external 'opengl32.dll' name 'glBindTexture';
    
    static procedure BindTextures(first: TextureUnitId; count: Int32; [MarshalAs(UnmanagedType.LPArray)] textures: array of TextureName);
    external 'opengl32.dll' name 'glBindTextures';
    static procedure BindTextures(first: TextureUnitId; count: Int32; var textures: TextureName);
    external 'opengl32.dll' name 'glBindTextures';
    static procedure BindTextures(first: TextureUnitId; count: Int32; textures: pointer);
    external 'opengl32.dll' name 'glBindTextures';
    
    static procedure BindTextureUnit(&unit: TextureUnitId; texture: TextureName);
    external 'opengl32.dll' name 'glBindTextureUnit';
    
    static procedure CreateTextures(target: TextureBindTarget; n: Int32; [MarshalAs(UnmanagedType.LPArray)] textures: array of TextureName);
    external 'opengl32.dll' name 'glCreateTextures';
    static procedure CreateTextures(target: TextureBindTarget; n: Int32; var textures: TextureName);
    external 'opengl32.dll' name 'glCreateTextures';
    static procedure CreateTextures(target: TextureBindTarget; n: Int32; textures: pointer);
    external 'opengl32.dll' name 'glCreateTextures';
    
    static procedure DeleteTextures(n: Int32; [MarshalAs(UnmanagedType.LPArray)] textures: array of TextureName);
    external 'opengl32.dll' name 'glDeleteTextures';
    static procedure DeleteTextures(n: Int32; var textures: TextureName);
    external 'opengl32.dll' name 'glDeleteTextures';
    static procedure DeleteTextures(n: Int32; textures: pointer);
    external 'opengl32.dll' name 'glDeleteTextures';
    
    static function IsTexture(texture: TextureName): boolean;
    external 'opengl32.dll' name 'glIsTexture';
    
    {$endregion 8.1 - Texture Objects}
    
    {$region 8.2 - Sampler Objects}
    
    static procedure GenSamplers(count: Int32; [MarshalAs(UnmanagedType.LPArray)] samplers: array of SamplerName);
    external 'opengl32.dll' name 'glGenSamplers';
    static procedure GenSamplers(count: Int32; var samplers: SamplerName);
    external 'opengl32.dll' name 'glGenSamplers';
    static procedure GenSamplers(count: Int32; samplers: pointer);
    external 'opengl32.dll' name 'glGenSamplers';
    
    static procedure CreateSamplers(n: Int32; [MarshalAs(UnmanagedType.LPArray)] samplers: array of SamplerName);
    external 'opengl32.dll' name 'glCreateSamplers';
    static procedure CreateSamplers(n: Int32; var samplers: SamplerName);
    external 'opengl32.dll' name 'glCreateSamplers';
    static procedure CreateSamplers(n: Int32; samplers: pointer);
    external 'opengl32.dll' name 'glCreateSamplers';
    
    static procedure BindSampler(&unit: Int32; sampler: SamplerName);
    external 'opengl32.dll' name 'glBindSampler';
    
    static procedure BindSamplers(first: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] samplers: array of SamplerName);
    external 'opengl32.dll' name 'glBindSamplers';
    static procedure BindSamplers(first: Int32; count: Int32; var samplers: SamplerName);
    external 'opengl32.dll' name 'glBindSamplers';
    static procedure BindSamplers(first: Int32; count: Int32; samplers: pointer);
    external 'opengl32.dll' name 'glBindSamplers';
    
    static procedure SamplerParameteri(sampler: SamplerName; pname: TextureInfoType; param: TextureCompareMode);
    external 'opengl32.dll' name 'glSamplerParameteri';
    static procedure SamplerParameteri(sampler: SamplerName; pname: TextureInfoType; param: ActivationFunc);
    external 'opengl32.dll' name 'glSamplerParameteri';
    static procedure SamplerParameteri(sampler: SamplerName; pname: TextureInfoType; param: PixelMagFilterMode);
    external 'opengl32.dll' name 'glSamplerParameteri';
    static procedure SamplerParameteri(sampler: SamplerName; pname: TextureInfoType; param: PixelMinFilterMode);
    external 'opengl32.dll' name 'glSamplerParameteri';
    static procedure SamplerParameteri(sampler: SamplerName; pname: TextureInfoType; param: PixelWrapMode);
    external 'opengl32.dll' name 'glSamplerParameteri';
    static procedure SamplerParameteri(sampler: SamplerName; pname: TextureInfoType; param: Int32); // нигде не используется, существует только для совместимости с .val
    external 'opengl32.dll' name 'glSamplerParameteri';
    
    static procedure SamplerParameterf(sampler: SamplerName; pname: TextureInfoType; param: single);
    external 'opengl32.dll' name 'glSamplerParameterf';
    
    static procedure SamplerParameteriv(sampler: SamplerName; pname: TextureInfoType; var param: Int32);
    external 'opengl32.dll' name 'glSamplerParameteriv';
    static procedure SamplerParameteriv(sampler: SamplerName; pname: TextureInfoType; param: pointer);
    external 'opengl32.dll' name 'glSamplerParameteriv';
    
    static procedure SamplerParameterfv(sampler: SamplerName; pname: TextureInfoType; var param: single);
    external 'opengl32.dll' name 'glSamplerParameterfv';
    static procedure SamplerParameterfv(sampler: SamplerName; pname: TextureInfoType; param: pointer);
    external 'opengl32.dll' name 'glSamplerParameterfv';
    
    static procedure SamplerParameterIiv(sampler: SamplerName; pname: TextureInfoType; var param: Int32); // нигде не используется, существует только для совместимости с .val
    external 'opengl32.dll' name 'glSamplerParameterIiv';
    static procedure SamplerParameterIiv(sampler: SamplerName; pname: TextureInfoType; param: pointer);
    external 'opengl32.dll' name 'glSamplerParameterIiv';
    
    static procedure SamplerParameterIuiv(sampler: SamplerName; pname: TextureInfoType; var param: TextureCompareMode);
    external 'opengl32.dll' name 'glSamplerParameterIuiv';
    static procedure SamplerParameterIuiv(sampler: SamplerName; pname: TextureInfoType; var param: ActivationFunc);
    external 'opengl32.dll' name 'glSamplerParameterIuiv';
    static procedure SamplerParameterIuiv(sampler: SamplerName; pname: TextureInfoType; var param: PixelMagFilterMode);
    external 'opengl32.dll' name 'glSamplerParameterIuiv';
    static procedure SamplerParameterIuiv(sampler: SamplerName; pname: TextureInfoType; var param: PixelMinFilterMode);
    external 'opengl32.dll' name 'glSamplerParameterIuiv';
    static procedure SamplerParameterIuiv(sampler: SamplerName; pname: TextureInfoType; var param: PixelWrapMode);
    external 'opengl32.dll' name 'glSamplerParameterIuiv';
    static procedure SamplerParameterIuiv(sampler: SamplerName; pname: TextureInfoType; var param: UInt32); // нигде не используется, существует только для совместимости с .val
    external 'opengl32.dll' name 'glSamplerParameterIuiv';
    static procedure SamplerParameterIuiv(sampler: SamplerName; pname: TextureInfoType; param: pointer);
    external 'opengl32.dll' name 'glSamplerParameterIuiv';
    
    static procedure DeleteSamplers(count: Int32; [MarshalAs(UnmanagedType.LPArray)] samplers: array of SamplerName);
    external 'opengl32.dll' name 'glDeleteSamplers';
    static procedure DeleteSamplers(count: Int32; var samplers: SamplerName);
    external 'opengl32.dll' name 'glDeleteSamplers';
    static procedure DeleteSamplers(count: Int32; samplers: pointer);
    external 'opengl32.dll' name 'glDeleteSamplers';
    
    static function IsSampler(sampler: SamplerName): boolean;
    external 'opengl32.dll' name 'glIsSampler';
    
    {$endregion 8.2 - Sampler Objects}
    
    {$region 8.3 - Sampler Object Queries}
    
    static procedure GetSamplerParameteriv(sampler: SamplerName; pname: TextureInfoType; var &params: TextureCompareMode);
    external 'opengl32.dll' name 'glGetSamplerParameteriv';
    static procedure GetSamplerParameteriv(sampler: SamplerName; pname: TextureInfoType; var &params: ActivationFunc);
    external 'opengl32.dll' name 'glGetSamplerParameteriv';
    static procedure GetSamplerParameteriv(sampler: SamplerName; pname: TextureInfoType; var &params: PixelMagFilterMode);
    external 'opengl32.dll' name 'glGetSamplerParameteriv';
    static procedure GetSamplerParameteriv(sampler: SamplerName; pname: TextureInfoType; var &params: PixelMinFilterMode);
    external 'opengl32.dll' name 'glGetSamplerParameteriv';
    static procedure GetSamplerParameteriv(sampler: SamplerName; pname: TextureInfoType; var &params: PixelWrapMode);
    external 'opengl32.dll' name 'glGetSamplerParameteriv';
    static procedure GetSamplerParameteriv(sampler: SamplerName; pname: TextureInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetSamplerParameteriv';
    static procedure GetSamplerParameteriv(sampler: SamplerName; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetSamplerParameteriv';
    
    static procedure GetSamplerParameterfv(sampler: SamplerName; pname: TextureInfoType; var &params: single);
    external 'opengl32.dll' name 'glGetSamplerParameterfv';
    static procedure GetSamplerParameterfv(sampler: SamplerName; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetSamplerParameterfv';
    
    static procedure GetSamplerParameterIiv(sampler: SamplerName; pname: TextureInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetSamplerParameterIiv';
    static procedure GetSamplerParameterIiv(sampler: SamplerName; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetSamplerParameterIiv';
    
    static procedure GetSamplerParameterIuiv(sampler: SamplerName; pname: TextureInfoType; var &params: TextureCompareMode);
    external 'opengl32.dll' name 'glGetSamplerParameterIuiv';
    static procedure GetSamplerParameterIuiv(sampler: SamplerName; pname: TextureInfoType; var &params: ActivationFunc);
    external 'opengl32.dll' name 'glGetSamplerParameterIuiv';
    static procedure GetSamplerParameterIuiv(sampler: SamplerName; pname: TextureInfoType; var &params: PixelMagFilterMode);
    external 'opengl32.dll' name 'glGetSamplerParameterIuiv';
    static procedure GetSamplerParameterIuiv(sampler: SamplerName; pname: TextureInfoType; var &params: PixelMinFilterMode);
    external 'opengl32.dll' name 'glGetSamplerParameterIuiv';
    static procedure GetSamplerParameterIuiv(sampler: SamplerName; pname: TextureInfoType; var &params: PixelWrapMode);
    external 'opengl32.dll' name 'glGetSamplerParameterIuiv';
    static procedure GetSamplerParameterIuiv(sampler: SamplerName; pname: TextureInfoType; var &params: UInt32);
    external 'opengl32.dll' name 'glGetSamplerParameterIuiv';
    static procedure GetSamplerParameterIuiv(sampler: SamplerName; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetSamplerParameterIuiv';
    
    {$endregion 8.3 - Sampler Object Queries}
    
    {$region 8.4 - Pixel Rectangles}
    
    // 8.4.1
    
    static procedure PixelStorei(pname: PixelInfoType; param: Int32);
    external 'opengl32.dll' name 'glPixelStorei';
    
    static procedure PixelStoref(pname: PixelInfoType; param: single);
    external 'opengl32.dll' name 'glPixelStoref';
    
    {$endregion 8.4 - Pixel Rectangles}
    
    {$region 8.5 - Texture Image Specification}
    
    static procedure TexImage3D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; depth: Int32; border: Int32; format: DataFormat; &type: DataType; pixels: IntPtr);
    external 'opengl32.dll' name 'glTexImage3D';
    static procedure TexImage3D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; depth: Int32; border: Int32; format: DataFormat; &type: DataType; pixels: pointer);
    external 'opengl32.dll' name 'glTexImage3D';
    
    static procedure TexImage2D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; border: Int32; format: DataFormat; &type: DataType; pixels: IntPtr);
    external 'opengl32.dll' name 'glTexImage2D';
    static procedure TexImage2D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; border: Int32; format: DataFormat; &type: DataType; pixels: pointer);
    external 'opengl32.dll' name 'glTexImage2D';
    
    static procedure TexImage1D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; border: Int32; format: DataFormat; &type: DataType; pixels: IntPtr);
    external 'opengl32.dll' name 'glTexImage1D';
    static procedure TexImage1D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; border: Int32; format: DataFormat; &type: DataType; pixels: pointer);
    external 'opengl32.dll' name 'glTexImage1D';
    
    {$endregion 8.5 - Texture Image Specification}
    
    {$region 8.6 - Alternate Texture Image Specification Commands}
    
    static procedure CopyTexImage2D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; x: Int32; y: Int32; width: Int32; height: Int32; border: Int32);
    external 'opengl32.dll' name 'glCopyTexImage2D';
    
    static procedure CopyTexImage1D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; x: Int32; y: Int32; width: Int32; border: Int32);
    external 'opengl32.dll' name 'glCopyTexImage1D';
    
    static procedure TexSubImage3D(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; &type: DataType; pixels: IntPtr);
    external 'opengl32.dll' name 'glTexSubImage3D';
    static procedure TexSubImage3D(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; &type: DataType; pixels: pointer);
    external 'opengl32.dll' name 'glTexSubImage3D';
    
    static procedure TexSubImage2D(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DataFormat; &type: DataType; pixels: IntPtr);
    external 'opengl32.dll' name 'glTexSubImage2D';
    static procedure TexSubImage2D(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DataFormat; &type: DataType; pixels: pointer);
    external 'opengl32.dll' name 'glTexSubImage2D';
    
    static procedure TexSubImage1D(target: TextureBindTarget; level: Int32; xoffset: Int32; width: Int32; format: DataFormat; &type: DataType; pixels: IntPtr);
    external 'opengl32.dll' name 'glTexSubImage1D';
    static procedure TexSubImage1D(target: TextureBindTarget; level: Int32; xoffset: Int32; width: Int32; format: DataFormat; &type: DataType; pixels: pointer);
    external 'opengl32.dll' name 'glTexSubImage1D';
    
    static procedure CopyTexSubImage3D(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glCopyTexSubImage3D';
    
    static procedure CopyTexSubImage2D(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glCopyTexSubImage2D';
    
    static procedure CopyTexSubImage1D(target: TextureBindTarget; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32);
    external 'opengl32.dll' name 'glCopyTexSubImage1D';
    
    static procedure TextureSubImage3D(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; &type: DataType; pixels: IntPtr);
    external 'opengl32.dll' name 'glTextureSubImage3D';
    static procedure TextureSubImage3D(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; &type: DataType; pixels: pointer);
    external 'opengl32.dll' name 'glTextureSubImage3D';
    
    static procedure TextureSubImage2D(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DataFormat; &type: DataType; pixels: IntPtr);
    external 'opengl32.dll' name 'glTextureSubImage2D';
    static procedure TextureSubImage2D(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DataFormat; &type: DataType; pixels: pointer);
    external 'opengl32.dll' name 'glTextureSubImage2D';
    
    static procedure TextureSubImage1D(texture: TextureName; level: Int32; xoffset: Int32; width: Int32; DataFormat: UInt32; &type: DataType; pixels: IntPtr);
    external 'opengl32.dll' name 'glTextureSubImage1D';
    static procedure TextureSubImage1D(texture: TextureName; level: Int32; xoffset: Int32; width: Int32; DataFormat: UInt32; &type: DataType; pixels: pointer);
    external 'opengl32.dll' name 'glTextureSubImage1D';
    
    static procedure CopyTextureSubImage3D(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glCopyTextureSubImage3D';
    
    static procedure CopyTextureSubImage2D(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glCopyTextureSubImage2D';
    
    static procedure CopyTextureSubImage1D(texture: TextureName; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32);
    external 'opengl32.dll' name 'glCopyTextureSubImage1D';
    
    {$endregion 8.6 - Alternate Texture Image Specification Commands}
    
    {$region 8.7 - Compressed Texture Images}
    
    static procedure CompressedTexImage1D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; border: Int32; imageSize: Int32; data: IntPtr);
    external 'opengl32.dll' name 'glCompressedTexImage1D';
    static procedure CompressedTexImage1D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; border: Int32; imageSize: Int32; data: pointer);
    external 'opengl32.dll' name 'glCompressedTexImage1D';
    
    static procedure CompressedTexImage2D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; border: Int32; imageSize: Int32; data: IntPtr);
    external 'opengl32.dll' name 'glCompressedTexImage2D';
    static procedure CompressedTexImage2D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; border: Int32; imageSize: Int32; data: pointer);
    external 'opengl32.dll' name 'glCompressedTexImage2D';
    
    static procedure CompressedTexImage3D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; depth: Int32; border: Int32; imageSize: Int32; data: IntPtr);
    external 'opengl32.dll' name 'glCompressedTexImage3D';
    static procedure CompressedTexImage3D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; depth: Int32; border: Int32; imageSize: Int32; data: pointer);
    external 'opengl32.dll' name 'glCompressedTexImage3D';
    
    static procedure CompressedTexSubImage1D(target: TextureBindTarget; level: Int32; xoffset: Int32; width: Int32; format: DataFormat; imageSize: Int32; data: IntPtr);
    external 'opengl32.dll' name 'glCompressedTexSubImage1D';
    static procedure CompressedTexSubImage1D(target: TextureBindTarget; level: Int32; xoffset: Int32; width: Int32; format: DataFormat; imageSize: Int32; data: pointer);
    external 'opengl32.dll' name 'glCompressedTexSubImage1D';
    
    static procedure CompressedTexSubImage2D(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DataFormat; imageSize: Int32; data: IntPtr);
    external 'opengl32.dll' name 'glCompressedTexSubImage2D';
    static procedure CompressedTexSubImage2D(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DataFormat; imageSize: Int32; data: pointer);
    external 'opengl32.dll' name 'glCompressedTexSubImage2D';
    
    static procedure CompressedTexSubImage3D(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; imageSize: Int32; data: IntPtr);
    external 'opengl32.dll' name 'glCompressedTexSubImage3D';
    static procedure CompressedTexSubImage3D(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; imageSize: Int32; data: pointer);
    external 'opengl32.dll' name 'glCompressedTexSubImage3D';
    
    static procedure CompressedTextureSubImage1D(texture: TextureBindTarget; level: Int32; xoffset: Int32; width: Int32; format: DataFormat; imageSize: Int32; data: IntPtr);
    external 'opengl32.dll' name 'glCompressedTextureSubImage1D';
    static procedure CompressedTextureSubImage1D(texture: TextureBindTarget; level: Int32; xoffset: Int32; width: Int32; format: DataFormat; imageSize: Int32; data: pointer);
    external 'opengl32.dll' name 'glCompressedTextureSubImage1D';
    
    static procedure CompressedTextureSubImage2D(texture: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DataFormat; imageSize: Int32; data: IntPtr);
    external 'opengl32.dll' name 'glCompressedTextureSubImage2D';
    static procedure CompressedTextureSubImage2D(texture: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DataFormat; imageSize: Int32; data: pointer);
    external 'opengl32.dll' name 'glCompressedTextureSubImage2D';
    
    static procedure CompressedTextureSubImage3D(texture: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; imageSize: Int32; data: IntPtr);
    external 'opengl32.dll' name 'glCompressedTextureSubImage3D';
    static procedure CompressedTextureSubImage3D(texture: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; imageSize: Int32; data: pointer);
    external 'opengl32.dll' name 'glCompressedTextureSubImage3D';
    
    {$endregion 8.7 - Compressed Texture Images}
    
    {$region 8.8 - Multisample Textures}
    
    static procedure TexImage2DMultisample(target: TextureBindTarget; samples: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; fixedsamplelocations: boolean);
    external 'opengl32.dll' name 'glTexImage2DMultisample';
    
    static procedure TexImage3DMultisample(target: TextureBindTarget; samples: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: boolean);
    external 'opengl32.dll' name 'glTexImage3DMultisample';
    
    {$endregion 8.8 - Multisample Textures}
    
    {$region 8.9 - Buffer Textures}
    
    static procedure TexBufferRange(target: TextureBindTarget; internalformat: InternalDataFormat; buffer: BufferName; offset: IntPtr; size: UIntPtr);
    external 'opengl32.dll' name 'glTexBufferRange';
    
    static procedure TextureBufferRange(texture: TextureName; internalformat: InternalDataFormat; buffer: BufferName; offset: IntPtr; size: UIntPtr);
    external 'opengl32.dll' name 'glTextureBufferRange';
    
    static procedure TexBuffer(target: TextureBindTarget; internalformat: InternalDataFormat; buffer: BufferName);
    external 'opengl32.dll' name 'glTexBuffer';
    
    static procedure TextureBuffer(texture: TextureName; internalformat: InternalDataFormat; buffer: BufferName);
    external 'opengl32.dll' name 'glTextureBuffer';
    
    {$endregion 8.9 - Buffer Textures}
    
    {$region 8.10 - Texture Parameters}
    //ToDo передавать можно энумы и массивы (и энумов тоже)...
    // - в конце проверить чтоб все энумы существовали
    // - и возможно ещё сделать для них перегрузки
    // - это так же касается 8.11
    
    static procedure TexParameteri(target: TextureBindTarget; pname: TextureInfoType; param: DepthStencilMode);
    external 'opengl32.dll' name 'glTexParameteri';
    static procedure TexParameteri(target: TextureBindTarget; pname: TextureInfoType; param: Int32);
    external 'opengl32.dll' name 'glTexParameteri';
    static procedure TexParameteri(target: TextureBindTarget; pname: TextureInfoType; param: TextureCompareMode);
    external 'opengl32.dll' name 'glTexParameteri';
    static procedure TexParameteri(target: TextureBindTarget; pname: TextureInfoType; param: ActivationFunc);
    external 'opengl32.dll' name 'glTexParameteri';
    static procedure TexParameteri(target: TextureBindTarget; pname: TextureInfoType; param: PixelMagFilterMode);
    external 'opengl32.dll' name 'glTexParameteri';
    static procedure TexParameteri(target: TextureBindTarget; pname: TextureInfoType; param: PixelMinFilterMode);
    external 'opengl32.dll' name 'glTexParameteri';
    static procedure TexParameteri(target: TextureBindTarget; pname: TextureInfoType; param: SwizzleMode);
    external 'opengl32.dll' name 'glTexParameteri';
    static procedure TexParameteri(target: TextureBindTarget; pname: TextureInfoType; param: PixelWrapMode);
    external 'opengl32.dll' name 'glTexParameteri';
    
    static procedure TexParameterf(target: TextureBindTarget; pname: TextureInfoType; param: single);
    external 'opengl32.dll' name 'glTexParameterf';
    
    static procedure TexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: DepthStencilMode);
    external 'opengl32.dll' name 'glTexParameteriv';
    static procedure TexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glTexParameteriv';
    static procedure TexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: TextureCompareMode);
    external 'opengl32.dll' name 'glTexParameteriv';
    static procedure TexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: ActivationFunc);
    external 'opengl32.dll' name 'glTexParameteriv';
    static procedure TexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: PixelMagFilterMode);
    external 'opengl32.dll' name 'glTexParameteriv';
    static procedure TexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: PixelMinFilterMode);
    external 'opengl32.dll' name 'glTexParameteriv';
    static procedure TexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: SwizzleMode);
    external 'opengl32.dll' name 'glTexParameteriv';
    static procedure TexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: PixelWrapMode);
    external 'opengl32.dll' name 'glTexParameteriv';
    static procedure TexParameteriv(target: TextureBindTarget; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glTexParameteriv';
    
    static procedure TexParameterfv(target: TextureBindTarget; pname: TextureInfoType; var &params: single);
    external 'opengl32.dll' name 'glTexParameterfv';
    static procedure TexParameterfv(target: TextureBindTarget; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glTexParameterfv';
    
    static procedure TexParameterIiv(target: TextureBindTarget; pname: TextureInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glTexParameterIiv';
    static procedure TexParameterIiv(target: TextureBindTarget; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glTexParameterIiv';
    
    static procedure TexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: DepthStencilMode);
    external 'opengl32.dll' name 'glTexParameterIuiv';
    static procedure TexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: TextureCompareMode);
    external 'opengl32.dll' name 'glTexParameterIuiv';
    static procedure TexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: ActivationFunc);
    external 'opengl32.dll' name 'glTexParameterIuiv';
    static procedure TexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: PixelMagFilterMode);
    external 'opengl32.dll' name 'glTexParameterIuiv';
    static procedure TexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: PixelMinFilterMode);
    external 'opengl32.dll' name 'glTexParameterIuiv';
    static procedure TexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: SwizzleMode);
    external 'opengl32.dll' name 'glTexParameterIuiv';
    static procedure TexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: PixelWrapMode);
    external 'opengl32.dll' name 'glTexParameterIuiv';
    static procedure TexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: UInt32);
    external 'opengl32.dll' name 'glTexParameterIuiv';
    static procedure TexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glTexParameterIuiv';
    
    static procedure TextureParameteri(texture: TextureName; pname: TextureInfoType; param: DepthStencilMode);
    external 'opengl32.dll' name 'glTextureParameteri';
    static procedure TextureParameteri(texture: TextureName; pname: TextureInfoType; param: Int32);
    external 'opengl32.dll' name 'glTextureParameteri';
    static procedure TextureParameteri(texture: TextureName; pname: TextureInfoType; param: TextureCompareMode);
    external 'opengl32.dll' name 'glTextureParameteri';
    static procedure TextureParameteri(texture: TextureName; pname: TextureInfoType; param: ActivationFunc);
    external 'opengl32.dll' name 'glTextureParameteri';
    static procedure TextureParameteri(texture: TextureName; pname: TextureInfoType; param: PixelMagFilterMode);
    external 'opengl32.dll' name 'glTextureParameteri';
    static procedure TextureParameteri(texture: TextureName; pname: TextureInfoType; param: PixelMinFilterMode);
    external 'opengl32.dll' name 'glTextureParameteri';
    static procedure TextureParameteri(texture: TextureName; pname: TextureInfoType; param: SwizzleMode);
    external 'opengl32.dll' name 'glTextureParameteri';
    static procedure TextureParameteri(texture: TextureName; pname: TextureInfoType; param: PixelWrapMode);
    external 'opengl32.dll' name 'glTextureParameteri';
    
    static procedure TextureParameterf(texture: TextureName; pname: TextureInfoType; param: single);
    external 'opengl32.dll' name 'glTextureParameterf';
    
    static procedure TextureParameteriv(texture: TextureName; pname: TextureInfoType; var param: DepthStencilMode);
    external 'opengl32.dll' name 'glTextureParameteriv';
    static procedure TextureParameteriv(texture: TextureName; pname: TextureInfoType; var param: Int32);
    external 'opengl32.dll' name 'glTextureParameteriv';
    static procedure TextureParameteriv(texture: TextureName; pname: TextureInfoType; var param: TextureCompareMode);
    external 'opengl32.dll' name 'glTextureParameteriv';
    static procedure TextureParameteriv(texture: TextureName; pname: TextureInfoType; var param: ActivationFunc);
    external 'opengl32.dll' name 'glTextureParameteriv';
    static procedure TextureParameteriv(texture: TextureName; pname: TextureInfoType; var param: PixelMagFilterMode);
    external 'opengl32.dll' name 'glTextureParameteriv';
    static procedure TextureParameteriv(texture: TextureName; pname: TextureInfoType; var param: PixelMinFilterMode);
    external 'opengl32.dll' name 'glTextureParameteriv';
    static procedure TextureParameteriv(texture: TextureName; pname: TextureInfoType; var param: SwizzleMode);
    external 'opengl32.dll' name 'glTextureParameteriv';
    static procedure TextureParameteriv(texture: TextureName; pname: TextureInfoType; var param: PixelWrapMode);
    external 'opengl32.dll' name 'glTextureParameteriv';
    static procedure TextureParameteriv(texture: TextureName; pname: TextureInfoType; param: pointer);
    external 'opengl32.dll' name 'glTextureParameteriv';
    
    static procedure TextureParameterfv(texture: TextureName; pname: TextureInfoType; var param: single);
    external 'opengl32.dll' name 'glTextureParameterfv';
    static procedure TextureParameterfv(texture: TextureName; pname: TextureInfoType; param: pointer);
    external 'opengl32.dll' name 'glTextureParameterfv';
    
    static procedure TextureParameterIiv(texture: TextureName; pname: TextureInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glTextureParameterIiv';
    static procedure TextureParameterIiv(texture: TextureName; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glTextureParameterIiv';
    
    static procedure TextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: DepthStencilMode);
    external 'opengl32.dll' name 'glTextureParameterIuiv';
    static procedure TextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: TextureCompareMode);
    external 'opengl32.dll' name 'glTextureParameterIuiv';
    static procedure TextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: ActivationFunc);
    external 'opengl32.dll' name 'glTextureParameterIuiv';
    static procedure TextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: PixelMagFilterMode);
    external 'opengl32.dll' name 'glTextureParameterIuiv';
    static procedure TextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: PixelMinFilterMode);
    external 'opengl32.dll' name 'glTextureParameterIuiv';
    static procedure TextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: SwizzleMode);
    external 'opengl32.dll' name 'glTextureParameterIuiv';
    static procedure TextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: PixelWrapMode);
    external 'opengl32.dll' name 'glTextureParameterIuiv';
    static procedure TextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: UInt32);
    external 'opengl32.dll' name 'glTextureParameterIuiv';
    static procedure TextureParameterIuiv(texture: TextureName; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glTextureParameterIuiv';
    
    {$endregion 8.10 - Texture Parameters}
    
    {$region 8.11 - Texture Queries}
    
    // 8.11.2
    
    static procedure GetTexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: DepthStencilMode);
    external 'opengl32.dll' name 'glGetTexParameteriv';
    static procedure GetTexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetTexParameteriv';
    static procedure GetTexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: TextureCompareMode);
    external 'opengl32.dll' name 'glGetTexParameteriv';
    static procedure GetTexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: ActivationFunc);
    external 'opengl32.dll' name 'glGetTexParameteriv';
    static procedure GetTexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: PixelMagFilterMode);
    external 'opengl32.dll' name 'glGetTexParameteriv';
    static procedure GetTexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: PixelMinFilterMode);
    external 'opengl32.dll' name 'glGetTexParameteriv';
    static procedure GetTexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: SwizzleMode);
    external 'opengl32.dll' name 'glGetTexParameteriv';
    static procedure GetTexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: PixelWrapMode);
    external 'opengl32.dll' name 'glGetTexParameteriv';
    static procedure GetTexParameteriv(target: TextureBindTarget; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetTexParameteriv';
    
    static procedure GetTexParameterfv(target: TextureBindTarget; pname: TextureInfoType; var &params: single);
    external 'opengl32.dll' name 'glGetTexParameterfv';
    static procedure GetTexParameterfv(target: TextureBindTarget; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetTexParameterfv';
    
    static procedure GetTexParameterIiv(target: TextureBindTarget; pname: TextureInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetTexParameterIiv';
    static procedure GetTexParameterIiv(target: TextureBindTarget; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetTexParameterIiv';
    
    static procedure GetTexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: DepthStencilMode);
    external 'opengl32.dll' name 'glGetTexParameterIuiv';
    static procedure GetTexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: TextureCompareMode);
    external 'opengl32.dll' name 'glGetTexParameterIuiv';
    static procedure GetTexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: ActivationFunc);
    external 'opengl32.dll' name 'glGetTexParameterIuiv';
    static procedure GetTexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: PixelMagFilterMode);
    external 'opengl32.dll' name 'glGetTexParameterIuiv';
    static procedure GetTexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: PixelMinFilterMode);
    external 'opengl32.dll' name 'glGetTexParameterIuiv';
    static procedure GetTexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: SwizzleMode);
    external 'opengl32.dll' name 'glGetTexParameterIuiv';
    static procedure GetTexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: PixelWrapMode);
    external 'opengl32.dll' name 'glGetTexParameterIuiv';
    static procedure GetTexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: UInt32);
    external 'opengl32.dll' name 'glGetTexParameterIuiv';
    static procedure GetTexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetTexParameterIuiv';
    
    static procedure GetTextureParameteriv(texture: TextureName; pname: TextureInfoType; var &params: DepthStencilMode);
    external 'opengl32.dll' name 'glGetTextureParameteriv';
    static procedure GetTextureParameteriv(texture: TextureName; pname: TextureInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetTextureParameteriv';
    static procedure GetTextureParameteriv(texture: TextureName; pname: TextureInfoType; var &params: TextureCompareMode);
    external 'opengl32.dll' name 'glGetTextureParameteriv';
    static procedure GetTextureParameteriv(texture: TextureName; pname: TextureInfoType; var &params: ActivationFunc);
    external 'opengl32.dll' name 'glGetTextureParameteriv';
    static procedure GetTextureParameteriv(texture: TextureName; pname: TextureInfoType; var &params: PixelMagFilterMode);
    external 'opengl32.dll' name 'glGetTextureParameteriv';
    static procedure GetTextureParameteriv(texture: TextureName; pname: TextureInfoType; var &params: PixelMinFilterMode);
    external 'opengl32.dll' name 'glGetTextureParameteriv';
    static procedure GetTextureParameteriv(texture: TextureName; pname: TextureInfoType; var &params: SwizzleMode);
    external 'opengl32.dll' name 'glGetTextureParameteriv';
    static procedure GetTextureParameteriv(texture: TextureName; pname: TextureInfoType; var &params: PixelWrapMode);
    external 'opengl32.dll' name 'glGetTextureParameteriv';
    static procedure GetTextureParameteriv(texture: TextureName; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetTextureParameteriv';
    
    static procedure GetTextureParameterfv(texture: TextureName; pname: TextureInfoType; var &params: single);
    external 'opengl32.dll' name 'glGetTextureParameterfv';
    static procedure GetTextureParameterfv(texture: TextureName; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetTextureParameterfv';
    
    static procedure GetTextureParameterIiv(texture: TextureName; pname: TextureInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetTextureParameterIiv';
    static procedure GetTextureParameterIiv(texture: TextureName; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetTextureParameterIiv';
    
    static procedure GetTextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: DepthStencilMode);
    external 'opengl32.dll' name 'glGetTextureParameterIuiv';
    static procedure GetTextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: TextureCompareMode);
    external 'opengl32.dll' name 'glGetTextureParameterIuiv';
    static procedure GetTextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: ActivationFunc);
    external 'opengl32.dll' name 'glGetTextureParameterIuiv';
    static procedure GetTextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: PixelMagFilterMode);
    external 'opengl32.dll' name 'glGetTextureParameterIuiv';
    static procedure GetTextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: PixelMinFilterMode);
    external 'opengl32.dll' name 'glGetTextureParameterIuiv';
    static procedure GetTextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: SwizzleMode);
    external 'opengl32.dll' name 'glGetTextureParameterIuiv';
    static procedure GetTextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: PixelWrapMode);
    external 'opengl32.dll' name 'glGetTextureParameterIuiv';
    static procedure GetTextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: UInt32);
    external 'opengl32.dll' name 'glGetTextureParameterIuiv';
    static procedure GetTextureParameterIuiv(texture: TextureName; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetTextureParameterIuiv';
    
    // 8.11.3
    
    static procedure GetTexLevelParameterfv(target: TextureBindTarget; level: Int32; pname: TextureInfoType; var &params: single);
    external 'opengl32.dll' name 'glGetTexLevelParameterfv';
    static procedure GetTexLevelParameterfv(target: TextureBindTarget; level: Int32; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetTexLevelParameterfv';
    static procedure GetTexLevelParameterfv(target: TextureCubeSide; level: Int32; pname: TextureInfoType; var &params: single);
    external 'opengl32.dll' name 'glGetTexLevelParameterfv';
    static procedure GetTexLevelParameterfv(target: TextureCubeSide; level: Int32; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetTexLevelParameterfv';
    
    static procedure GetTexLevelParameteriv(target: TextureBindTarget; level: Int32; pname: TextureInfoType; var &params: DataType);
    external 'opengl32.dll' name 'glGetTexLevelParameteriv';
    static procedure GetTexLevelParameteriv(target: TextureBindTarget; level: Int32; pname: TextureInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetTexLevelParameteriv';
    static procedure GetTexLevelParameteriv(target: TextureBindTarget; level: Int32; pname: TextureInfoType; var &params: boolean);
    external 'opengl32.dll' name 'glGetTexLevelParameteriv';
    static procedure GetTexLevelParameteriv(target: TextureBindTarget; level: Int32; pname: TextureInfoType; var &params: InternalDataFormat);
    external 'opengl32.dll' name 'glGetTexLevelParameteriv';
    static procedure GetTexLevelParameteriv(target: TextureBindTarget; level: Int32; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetTexLevelParameteriv';
    static procedure GetTexLevelParameteriv(target: TextureCubeSide; level: Int32; pname: TextureInfoType; var &params: DataType);
    external 'opengl32.dll' name 'glGetTexLevelParameteriv';
    static procedure GetTexLevelParameteriv(target: TextureCubeSide; level: Int32; pname: TextureInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetTexLevelParameteriv';
    static procedure GetTexLevelParameteriv(target: TextureCubeSide; level: Int32; pname: TextureInfoType; var &params: boolean);
    external 'opengl32.dll' name 'glGetTexLevelParameteriv';
    static procedure GetTexLevelParameteriv(target: TextureCubeSide; level: Int32; pname: TextureInfoType; var &params: InternalDataFormat);
    external 'opengl32.dll' name 'glGetTexLevelParameteriv';
    static procedure GetTexLevelParameteriv(target: TextureCubeSide; level: Int32; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetTexLevelParameteriv';
    
    static procedure GetTextureLevelParameterfv(texture: TextureName; level: Int32; pname: TextureInfoType; var &params: single);
    external 'opengl32.dll' name 'glGetTextureLevelParameterfv';
    static procedure GetTextureLevelParameterfv(texture: TextureName; level: Int32; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetTextureLevelParameterfv';
    
    static procedure GetTextureLevelParameteriv(texture: TextureName; level: Int32; pname: TextureInfoType; var &params: DataType);
    external 'opengl32.dll' name 'glGetTextureLevelParameteriv';
    static procedure GetTextureLevelParameteriv(texture: TextureName; level: Int32; pname: TextureInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetTextureLevelParameteriv';
    static procedure GetTextureLevelParameteriv(texture: TextureName; level: Int32; pname: TextureInfoType; var &params: boolean);
    external 'opengl32.dll' name 'glGetTextureLevelParameteriv';
    static procedure GetTextureLevelParameteriv(texture: TextureName; level: Int32; pname: TextureInfoType; var &params: InternalDataFormat);
    external 'opengl32.dll' name 'glGetTextureLevelParameteriv';
    static procedure GetTextureLevelParameteriv(texture: TextureName; level: Int32; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetTextureLevelParameteriv';
    
    // 8.11.4
    
    static procedure GetTexImage(target: TextureBindTarget; level: Int32; format: DataFormat; &type: DataType; pixels: IntPtr);
    external 'opengl32.dll' name 'glGetTexImage';
    static procedure GetTexImage(target: TextureBindTarget; level: Int32; format: DataFormat; &type: DataType; pixels: pointer);
    external 'opengl32.dll' name 'glGetTexImage';
    
    static procedure GetTextureImage(texture: TextureName; level: Int32; format: DataFormat; &type: DataType; bufSize: Int32; pixels: IntPtr);
    external 'opengl32.dll' name 'glGetTextureImage';
    static procedure GetTextureImage(texture: TextureName; level: Int32; format: DataFormat; &type: DataType; bufSize: Int32; pixels: pointer);
    external 'opengl32.dll' name 'glGetTextureImage';
    
    static procedure GetnTexImage(target: TextureBindTarget; level: Int32; format: DataFormat; &type: DataType; bufSize: Int32; pixels: IntPtr);
    external 'opengl32.dll' name 'glGetnTexImage';
    static procedure GetnTexImage(target: TextureBindTarget; level: Int32; format: DataFormat; &type: DataType; bufSize: Int32; pixels: pointer);
    external 'opengl32.dll' name 'glGetnTexImage';
    
    static procedure GetTextureSubImage(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; &type: DataType; bufSize: Int32; pixels: IntPtr);
    external 'opengl32.dll' name 'glGetTextureSubImage';
    static procedure GetTextureSubImage(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; &type: DataType; bufSize: Int32; pixels: pointer);
    external 'opengl32.dll' name 'glGetTextureSubImage';
    
    static procedure GetCompressedTexImage(target: TextureBindTarget; level: Int32; pixels: IntPtr);
    external 'opengl32.dll' name 'glGetCompressedTexImage';
    static procedure GetCompressedTexImage(target: TextureBindTarget; level: Int32; pixels: pointer);
    external 'opengl32.dll' name 'glGetCompressedTexImage';
    
    static procedure GetCompressedTextureImage(texture: TextureName; level: Int32; bufSize: Int32; pixels: IntPtr);
    external 'opengl32.dll' name 'glGetCompressedTextureImage';
    static procedure GetCompressedTextureImage(texture: TextureName; level: Int32; bufSize: Int32; pixels: pointer);
    external 'opengl32.dll' name 'glGetCompressedTextureImage';
    
    static procedure GetnCompressedTexImage(target: TextureBindTarget; level: Int32; bufSize: Int32; pixels: IntPtr);
    external 'opengl32.dll' name 'glGetnCompressedTexImage';
    static procedure GetnCompressedTexImage(target: TextureBindTarget; level: Int32; bufSize: Int32; pixels: pointer);
    external 'opengl32.dll' name 'glGetnCompressedTexImage';
    
    static procedure GetCompressedTextureSubImage(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; bufSize: Int32; pixels: IntPtr);
    external 'opengl32.dll' name 'glGetCompressedTextureSubImage';
    static procedure GetCompressedTextureSubImage(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; bufSize: Int32; pixels: pointer);
    external 'opengl32.dll' name 'glGetCompressedTextureSubImage';
    
    {$endregion 8.11 - Texture Queries}
    
    {$region 8.14 - Texture Minification}
    
    // 8.14.4
    
    static procedure GenerateMipmap(target: TextureBindTarget);
    external 'opengl32.dll' name 'glGenerateMipmap';
    
    static procedure GenerateTextureMipmap(texture: TextureName);
    external 'opengl32.dll' name 'glGenerateTextureMipmap';
    
    {$endregion 8.14 - Texture Minification}
    
    {$region 8.18 - Texture Views}
    
    static procedure TextureView(texture: TextureName; target: TextureBindTarget; origtexture: TextureName; internalformat: InternalDataFormat; minlevel: UInt32; numlevels: UInt32; minlayer: UInt32; numlayers: UInt32);
    external 'opengl32.dll' name 'glTextureView';
    
    {$endregion 8.18 - Texture Views}
    
    {$region 8.19 - Immutable-Format Texture Images}
    
    static procedure TexStorage1D(target: TextureBindTarget; levels: Int32; internalformat: InternalDataFormat; width: Int32);
    external 'opengl32.dll' name 'glTexStorage1D';
    
    static procedure TextureStorage1D(texture: TextureName; levels: Int32; internalformat: InternalDataFormat; width: Int32);
    external 'opengl32.dll' name 'glTextureStorage1D';
    
    static procedure TexStorage2D(target: TextureBindTarget; levels: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glTexStorage2D';
    
    static procedure TextureStorage2D(texture: TextureName; levels: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glTextureStorage2D';
    
    static procedure TexStorage3D(target: TextureBindTarget; levels: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; depth: Int32);
    external 'opengl32.dll' name 'glTexStorage3D';
    
    static procedure TextureStorage3D(texture: TextureName; levels: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; depth: Int32);
    external 'opengl32.dll' name 'glTextureStorage3D';
    
    static procedure TexStorage2DMultisample(target: TextureBindTarget; samples: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; fixedsamplelocations: boolean);
    external 'opengl32.dll' name 'glTexStorage2DMultisample';
    
    static procedure TextureStorage2DMultisample(texture: TextureName; samples: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; fixedsamplelocations: boolean);
    external 'opengl32.dll' name 'glTextureStorage2DMultisample';
    
    static procedure TexStorage3DMultisample(target: TextureBindTarget; samples: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: boolean);
    external 'opengl32.dll' name 'glTexStorage3DMultisample';
    
    static procedure TextureStorage3DMultisample(texture: TextureName; samples: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: boolean);
    external 'opengl32.dll' name 'glTextureStorage3DMultisample';
    
    {$endregion 8.19 - Immutable-Format Texture Images}
    
    {$region 8.20 - Invalidating Texture Image Data}
    
    static procedure InvalidateTexSubImage(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32);
    external 'opengl32.dll' name 'glInvalidateTexSubImage';
    
    static procedure InvalidateTexImage(texture: TextureName; level: Int32);
    external 'opengl32.dll' name 'glInvalidateTexImage';
    
    {$endregion 8.20 - Invalidating Texture Image Data}
    
    {$region 8.21 - Clearing Texture Image Data}
    
    static procedure ClearTexSubImage(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; &type: DataType; data: IntPtr);
    external 'opengl32.dll' name 'glClearTexSubImage';
    static procedure ClearTexSubImage(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; &type: DataType; data: pointer);
    external 'opengl32.dll' name 'glClearTexSubImage';
    
    static procedure ClearTexImage(texture: TextureName; level: Int32; format: DataFormat; &type: DataType; data: IntPtr);
    external 'opengl32.dll' name 'glClearTexImage';
    static procedure ClearTexImage(texture: TextureName; level: Int32; format: DataFormat; &type: DataType; data: pointer);
    external 'opengl32.dll' name 'glClearTexImage';
    
    {$endregion 8.21 - Clearing Texture Image Data}
    
    {$region 8.26 - Texture Image Loads and Stores}
    
    static procedure BindImageTexture(&unit: TextureUnitId; texture: TextureName; level: Int32; layered: boolean; layer: Int32; access: AccessType; format: DataFormat);
    external 'opengl32.dll' name 'glBindImageTexture';
    
    static procedure BindImageTextures(first: UInt32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] textures: array of TextureName);
    external 'opengl32.dll' name 'glBindImageTextures';
    static procedure BindImageTextures(first: UInt32; count: Int32; var textures: TextureName);
    external 'opengl32.dll' name 'glBindImageTextures';
    static procedure BindImageTextures(first: UInt32; count: Int32; textures: pointer);
    external 'opengl32.dll' name 'glBindImageTextures';
    
    {$endregion 8.26 - Texture Image Loads and Stores}
    
    {$endregion 8.0 - Textures and Samplers}
    
    {$region 9.0 - Framebuffers and Framebuffer Objects}
    
    {$region 9.2 - Binding and Managing Framebuffer Objects}
    
    static procedure BindFramebuffer(target: FramebufferBindTarget; framebuffer: FramebufferName);
    external 'opengl32.dll' name 'glBindFramebuffer';
    
    static procedure CreateFramebuffers(n: Int32; [MarshalAs(UnmanagedType.LPArray)] framebuffers: array of FramebufferName);
    external 'opengl32.dll' name 'glCreateFramebuffers';
    static procedure CreateFramebuffers(n: Int32; var framebuffers: FramebufferName);
    external 'opengl32.dll' name 'glCreateFramebuffers';
    static procedure CreateFramebuffers(n: Int32; framebuffers: pointer);
    external 'opengl32.dll' name 'glCreateFramebuffers';
    
    static procedure GenFramebuffers(n: Int32; [MarshalAs(UnmanagedType.LPArray)] framebuffers: array of FramebufferName);
    external 'opengl32.dll' name 'glGenFramebuffers';
    static procedure GenFramebuffers(n: Int32; var framebuffers: FramebufferName);
    external 'opengl32.dll' name 'glGenFramebuffers';
    static procedure GenFramebuffers(n: Int32; framebuffers: pointer);
    external 'opengl32.dll' name 'glGenFramebuffers';
    
    static procedure DeleteFramebuffers(n: Int32; [MarshalAs(UnmanagedType.LPArray)] framebuffers: array of FramebufferName);
    external 'opengl32.dll' name 'glDeleteFramebuffers';
    static procedure DeleteFramebuffers(n: Int32; var framebuffers: FramebufferName);
    external 'opengl32.dll' name 'glDeleteFramebuffers';
    static procedure DeleteFramebuffers(n: Int32; framebuffers: pointer);
    external 'opengl32.dll' name 'glDeleteFramebuffers';
    
    static function IsFramebuffer(framebuffer: FramebufferName): boolean;
    external 'opengl32.dll' name 'glIsFramebuffer';
    
    // 9.2.1
    
    static procedure FramebufferParameteri(target: FramebufferBindTarget; pname: FramebufferInfoType; param: Int32);
    external 'opengl32.dll' name 'glFramebufferParameteri';
    
    static procedure NamedFramebufferParameteri(framebuffer: FramebufferName; pname: FramebufferInfoType; param: Int32);
    external 'opengl32.dll' name 'glNamedFramebufferParameteri';
    
    // 9.2.3
    
    static procedure GetFramebufferParameteriv(target: FramebufferBindTarget; pname: FramebufferInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetFramebufferParameteriv';
    static procedure GetFramebufferParameteriv(target: FramebufferBindTarget; pname: FramebufferInfoType; var &params: boolean);
    external 'opengl32.dll' name 'glGetFramebufferParameteriv';
    static procedure GetFramebufferParameteriv(target: FramebufferBindTarget; pname: FramebufferInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetFramebufferParameteriv';
    
    static procedure GetNamedFramebufferParameteriv(framebuffer: FramebufferName; pname: FramebufferInfoType; var param: Int32);
    external 'opengl32.dll' name 'glGetNamedFramebufferParameteriv';
    static procedure GetNamedFramebufferParameteriv(framebuffer: FramebufferName; pname: FramebufferInfoType; var param: boolean);
    external 'opengl32.dll' name 'glGetNamedFramebufferParameteriv';
    static procedure GetNamedFramebufferParameteriv(framebuffer: FramebufferName; pname: FramebufferInfoType; param: pointer);
    external 'opengl32.dll' name 'glGetNamedFramebufferParameteriv';
    
    static procedure GetFramebufferAttachmentParameteriv(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; pname: FramebufferAttachmentInfoType; var &params: FramebufferAttachmentObjectType);
    external 'opengl32.dll' name 'glGetFramebufferAttachmentParameteriv';
    static procedure GetFramebufferAttachmentParameteriv(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; pname: FramebufferAttachmentInfoType; var &params: UInt32);
    external 'opengl32.dll' name 'glGetFramebufferAttachmentParameteriv';
    static procedure GetFramebufferAttachmentParameteriv(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; pname: FramebufferAttachmentInfoType; var &params: DataType);
    external 'opengl32.dll' name 'glGetFramebufferAttachmentParameteriv';
    static procedure GetFramebufferAttachmentParameteriv(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; pname: FramebufferAttachmentInfoType; var &params: ColorEncodingMode);
    external 'opengl32.dll' name 'glGetFramebufferAttachmentParameteriv';
    static procedure GetFramebufferAttachmentParameteriv(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; pname: FramebufferAttachmentInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetFramebufferAttachmentParameteriv';
    static procedure GetFramebufferAttachmentParameteriv(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; pname: FramebufferAttachmentInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetFramebufferAttachmentParameteriv';
    
    static procedure GetNamedFramebufferAttachmentParameteriv(framebuffer: FramebufferName; attachment: FramebufferAttachmentPoint; pname: FramebufferAttachmentInfoType; var &params: FramebufferAttachmentObjectType);
    external 'opengl32.dll' name 'glGetNamedFramebufferAttachmentParameteriv';
    static procedure GetNamedFramebufferAttachmentParameteriv(framebuffer: FramebufferName; attachment: FramebufferAttachmentPoint; pname: FramebufferAttachmentInfoType; var &params: UInt32);
    external 'opengl32.dll' name 'glGetNamedFramebufferAttachmentParameteriv';
    static procedure GetNamedFramebufferAttachmentParameteriv(framebuffer: FramebufferName; attachment: FramebufferAttachmentPoint; pname: FramebufferAttachmentInfoType; var &params: DataType);
    external 'opengl32.dll' name 'glGetNamedFramebufferAttachmentParameteriv';
    static procedure GetNamedFramebufferAttachmentParameteriv(framebuffer: FramebufferName; attachment: FramebufferAttachmentPoint; pname: FramebufferAttachmentInfoType; var &params: ColorEncodingMode);
    external 'opengl32.dll' name 'glGetNamedFramebufferAttachmentParameteriv';
    static procedure GetNamedFramebufferAttachmentParameteriv(framebuffer: FramebufferName; attachment: FramebufferAttachmentPoint; pname: FramebufferAttachmentInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetNamedFramebufferAttachmentParameteriv';
    static procedure GetNamedFramebufferAttachmentParameteriv(framebuffer: FramebufferName; attachment: FramebufferAttachmentPoint; pname: FramebufferAttachmentInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetNamedFramebufferAttachmentParameteriv';
    
    // 9.2.4
    
    static procedure BindRenderbuffer(target: RenderbufferBindTarget; renderbuffer: RenderbufferName);
    external 'opengl32.dll' name 'glBindRenderbuffer';
    
    static procedure CreateRenderbuffers(n: Int32; [MarshalAs(UnmanagedType.LPArray)] renderbuffers: array of RenderbufferName);
    external 'opengl32.dll' name 'glCreateRenderbuffers';
    static procedure CreateRenderbuffers(n: Int32; var renderbuffers: RenderbufferName);
    external 'opengl32.dll' name 'glCreateRenderbuffers';
    static procedure CreateRenderbuffers(n: Int32; renderbuffers: pointer);
    external 'opengl32.dll' name 'glCreateRenderbuffers';
    
    static procedure GenRenderbuffers(n: Int32; [MarshalAs(UnmanagedType.LPArray)] renderbuffers: array of RenderbufferName);
    external 'opengl32.dll' name 'glGenRenderbuffers';
    static procedure GenRenderbuffers(n: Int32; var renderbuffers: RenderbufferName);
    external 'opengl32.dll' name 'glGenRenderbuffers';
    static procedure GenRenderbuffers(n: Int32; renderbuffers: pointer);
    external 'opengl32.dll' name 'glGenRenderbuffers';
    
    static procedure DeleteRenderbuffers(n: Int32; [MarshalAs(UnmanagedType.LPArray)] renderbuffers: array of RenderbufferName);
    external 'opengl32.dll' name 'glDeleteRenderbuffers';
    static procedure DeleteRenderbuffers(n: Int32; var renderbuffers: RenderbufferName);
    external 'opengl32.dll' name 'glDeleteRenderbuffers';
    static procedure DeleteRenderbuffers(n: Int32; renderbuffers: pointer);
    external 'opengl32.dll' name 'glDeleteRenderbuffers';
    
    static function IsRenderbuffer(renderbuffer: RenderbufferName): boolean;
    external 'opengl32.dll' name 'glIsRenderbuffer';
    
    static procedure RenderbufferStorageMultisample(target: RenderbufferBindTarget; samples: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glRenderbufferStorageMultisample';
    
    static procedure NamedRenderbufferStorageMultisample(renderbuffer: RenderbufferName; samples: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glNamedRenderbufferStorageMultisample';
    
    static procedure RenderbufferStorage(target: RenderbufferBindTarget; internalformat: InternalDataFormat; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glRenderbufferStorage';
    
    static procedure NamedRenderbufferStorage(renderbuffer: RenderbufferName; internalformat: InternalDataFormat; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glNamedRenderbufferStorage';
    
    // 9.2.6
    
    static procedure GetRenderbufferParameteriv(target: RenderbufferBindTarget; pname: RenderbufferInfoType; var &params: InternalDataFormat);
    external 'opengl32.dll' name 'glGetRenderbufferParameteriv';
    static procedure GetRenderbufferParameteriv(target: RenderbufferBindTarget; pname: RenderbufferInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetRenderbufferParameteriv';
    static procedure GetRenderbufferParameteriv(target: RenderbufferBindTarget; pname: RenderbufferInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetRenderbufferParameteriv';
    
    static procedure GetNamedRenderbufferParameteriv(renderbuffer: RenderbufferName; pname: RenderbufferInfoType; var &params: InternalDataFormat);
    external 'opengl32.dll' name 'glGetNamedRenderbufferParameteriv';
    static procedure GetNamedRenderbufferParameteriv(renderbuffer: RenderbufferName; pname: RenderbufferInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetNamedRenderbufferParameteriv';
    static procedure GetNamedRenderbufferParameteriv(renderbuffer: RenderbufferName; pname: RenderbufferInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetNamedRenderbufferParameteriv';
    
    // 9.2.7
    
    static procedure FramebufferRenderbuffer(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; renderbuffertarget: RenderbufferBindTarget; renderbuffer: RenderbufferName);
    external 'opengl32.dll' name 'glFramebufferRenderbuffer';
    
    static procedure NamedFramebufferRenderbuffer(framebuffer: FramebufferName; attachment: FramebufferAttachmentPoint; renderbuffertarget: RenderbufferBindTarget; renderbuffer: RenderbufferName);
    external 'opengl32.dll' name 'glNamedFramebufferRenderbuffer';
    
    // 9.2.8
    
    static procedure FramebufferTexture(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; texture: TextureName; level: Int32);
    external 'opengl32.dll' name 'glFramebufferTexture';
    
    static procedure NamedFramebufferTexture(framebuffer: FramebufferName; attachment: FramebufferAttachmentPoint; texture: TextureName; level: Int32);
    external 'opengl32.dll' name 'glNamedFramebufferTexture';
    
    static procedure FramebufferTexture1D(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; textarget: TextureBindTarget; texture: TextureName; level: Int32);
    external 'opengl32.dll' name 'glFramebufferTexture1D';
    static procedure FramebufferTexture1D(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; textarget: TextureCubeSide; texture: TextureName; level: Int32);
    external 'opengl32.dll' name 'glFramebufferTexture1D';
    
    static procedure FramebufferTexture2D(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; textarget: TextureBindTarget; texture: TextureName; level: Int32);
    external 'opengl32.dll' name 'glFramebufferTexture2D';
    static procedure FramebufferTexture2D(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; textarget: TextureCubeSide; texture: TextureName; level: Int32);
    external 'opengl32.dll' name 'glFramebufferTexture2D';
    
    static procedure FramebufferTexture3D(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; textarget: TextureBindTarget; texture: TextureName; level: Int32; zoffset: Int32);
    external 'opengl32.dll' name 'glFramebufferTexture3D';
    static procedure FramebufferTexture3D(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; textarget: TextureCubeSide; texture: TextureName; level: Int32; zoffset: Int32);
    external 'opengl32.dll' name 'glFramebufferTexture3D';
    
    static procedure FramebufferTextureLayer(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; texture: TextureName; level: Int32; layer: Int32);
    external 'opengl32.dll' name 'glFramebufferTextureLayer';
    
    static procedure NamedFramebufferTextureLayer(framebuffer: FramebufferName; attachment: FramebufferAttachmentPoint; texture: TextureName; level: Int32; layer: Int32);
    external 'opengl32.dll' name 'glNamedFramebufferTextureLayer';
    
    {$endregion 9.2 - Binding and Managing Framebuffer Objects}
    
    {$region 9.3 - Feedback Loops Between Textures and the Framebuffer}
    
    // 9.3.1
    
    static procedure TextureBarrier;
    external 'opengl32.dll' name 'glTextureBarrier';
    
    {$endregion 9.3 - Feedback Loops Between Textures and the Framebuffer}
    
    {$region 9.4 - Framebuffer Completeness}
    
    // 9.4.2
    
    static function CheckFramebufferStatus(target: FramebufferBindTarget): ErrorCode;
    external 'opengl32.dll' name 'glCheckFramebufferStatus';
    
    static function CheckNamedFramebufferStatus(framebuffer: FramebufferName; target: FramebufferBindTarget): ErrorCode;
    external 'opengl32.dll' name 'glCheckNamedFramebufferStatus';
    
    {$endregion 9.4 - Framebuffer Completeness}
    
    {$endregion 9.0 - Framebuffers and Framebuffer Objects}
    
    {$region 10.0 - Vertex Specification and Drawing Commands}
    
    {$region 10.1 - Primitive Types}
    
    // 10.1.15
    
    static procedure PatchParameteri(pname: PatchMode; value: Int32);
    external 'opengl32.dll' name 'glPatchParameteri';
    
    {$endregion 10.1 - Primitive Types}
    
    {$region 10.2 - Current Vertex Attribute Values}
    
    // 10.2.1
    
    {$region VertexAttrib[1,2,3,4][s,f,d]}
    
    static procedure VertexAttrib1s(index: UInt32; x: Int16);
    external 'opengl32.dll' name 'glVertexAttrib1s';
    
    static procedure VertexAttrib2s(index: UInt32; x: Int16; y: Int16);
    external 'opengl32.dll' name 'glVertexAttrib2s';
    
    static procedure VertexAttrib3s(index: UInt32; x: Int16; y: Int16; z: Int16);
    external 'opengl32.dll' name 'glVertexAttrib3s';
    
    static procedure VertexAttrib4s(index: UInt32; x: Int16; y: Int16; z: Int16; w: Int16);
    external 'opengl32.dll' name 'glVertexAttrib4s';
    
    static procedure VertexAttrib1f(index: UInt32; x: single);
    external 'opengl32.dll' name 'glVertexAttrib1f';
    
    static procedure VertexAttrib2f(index: UInt32; x: single; y: single);
    external 'opengl32.dll' name 'glVertexAttrib2f';
    
    static procedure VertexAttrib3f(index: UInt32; x: single; y: single; z: single);
    external 'opengl32.dll' name 'glVertexAttrib3f';
    
    static procedure VertexAttrib4f(index: UInt32; x: single; y: single; z: single; w: single);
    external 'opengl32.dll' name 'glVertexAttrib4f';
    
    static procedure VertexAttrib1d(index: UInt32; x: double);
    external 'opengl32.dll' name 'glVertexAttrib1d';
    
    static procedure VertexAttrib2d(index: UInt32; x: double; y: double);
    external 'opengl32.dll' name 'glVertexAttrib2d';
    
    static procedure VertexAttrib3d(index: UInt32; x: double; y: double; z: double);
    external 'opengl32.dll' name 'glVertexAttrib3d';
    
    static procedure VertexAttrib4d(index: UInt32; x: double; y: double; z: double; w: double);
    external 'opengl32.dll' name 'glVertexAttrib4d';
    
    {$endregion VertexAttrib[1,2,3,4][s,f,d]}
    
    {$region VertexAttrib[1,2,3][s,f,d]v}
    
    static procedure VertexAttrib1sv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of Int16);
    external 'opengl32.dll' name 'glVertexAttrib1sv';
    static procedure VertexAttrib1sv(index: UInt32; var v: Int16);
    external 'opengl32.dll' name 'glVertexAttrib1sv';
    static procedure VertexAttrib1sv(index: UInt32; var v: Vec1s);
    external 'opengl32.dll' name 'glVertexAttrib1sv';
    static procedure VertexAttrib1sv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib1sv';
    
    static procedure VertexAttrib2sv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of Int16);
    external 'opengl32.dll' name 'glVertexAttrib2sv';
    static procedure VertexAttrib2sv(index: UInt32; var v: Int16);
    external 'opengl32.dll' name 'glVertexAttrib2sv';
    static procedure VertexAttrib2sv(index: UInt32; var v: Vec2s);
    external 'opengl32.dll' name 'glVertexAttrib2sv';
    static procedure VertexAttrib2sv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib2sv';
    
    static procedure VertexAttrib3sv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of Int16);
    external 'opengl32.dll' name 'glVertexAttrib3sv';
    static procedure VertexAttrib3sv(index: UInt32; var v: Int16);
    external 'opengl32.dll' name 'glVertexAttrib3sv';
    static procedure VertexAttrib3sv(index: UInt32; var v: Vec3s);
    external 'opengl32.dll' name 'glVertexAttrib3sv';
    static procedure VertexAttrib3sv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib3sv';
    
    static procedure VertexAttrib1fv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of single);
    external 'opengl32.dll' name 'glVertexAttrib1fv';
    static procedure VertexAttrib1fv(index: UInt32; var v: single);
    external 'opengl32.dll' name 'glVertexAttrib1fv';
    static procedure VertexAttrib1fv(index: UInt32; var v: Vec1f);
    external 'opengl32.dll' name 'glVertexAttrib1fv';
    static procedure VertexAttrib1fv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib1fv';
    
    static procedure VertexAttrib2fv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of single);
    external 'opengl32.dll' name 'glVertexAttrib2fv';
    static procedure VertexAttrib2fv(index: UInt32; var v: single);
    external 'opengl32.dll' name 'glVertexAttrib2fv';
    static procedure VertexAttrib2fv(index: UInt32; var v: Vec2f);
    external 'opengl32.dll' name 'glVertexAttrib2fv';
    static procedure VertexAttrib2fv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib2fv';
    
    static procedure VertexAttrib3fv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of single);
    external 'opengl32.dll' name 'glVertexAttrib3fv';
    static procedure VertexAttrib3fv(index: UInt32; var v: single);
    external 'opengl32.dll' name 'glVertexAttrib3fv';
    static procedure VertexAttrib3fv(index: UInt32; var v: Vec3f);
    external 'opengl32.dll' name 'glVertexAttrib3fv';
    static procedure VertexAttrib3fv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib3fv';
    
    static procedure VertexAttrib1dv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of double);
    external 'opengl32.dll' name 'glVertexAttrib1dv';
    static procedure VertexAttrib1dv(index: UInt32; var v: double);
    external 'opengl32.dll' name 'glVertexAttrib1dv';
    static procedure VertexAttrib1dv(index: UInt32; var v: Vec1d);
    external 'opengl32.dll' name 'glVertexAttrib1dv';
    static procedure VertexAttrib1dv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib1dv';
    
    static procedure VertexAttrib2dv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of double);
    external 'opengl32.dll' name 'glVertexAttrib2dv';
    static procedure VertexAttrib2dv(index: UInt32; var v: double);
    external 'opengl32.dll' name 'glVertexAttrib2dv';
    static procedure VertexAttrib2dv(index: UInt32; var v: Vec2d);
    external 'opengl32.dll' name 'glVertexAttrib2dv';
    static procedure VertexAttrib2dv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib2dv';
    
    static procedure VertexAttrib3dv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of double);
    external 'opengl32.dll' name 'glVertexAttrib3dv';
    static procedure VertexAttrib3dv(index: UInt32; var v: double);
    external 'opengl32.dll' name 'glVertexAttrib3dv';
    static procedure VertexAttrib3dv(index: UInt32; var v: Vec3d);
    external 'opengl32.dll' name 'glVertexAttrib3dv';
    static procedure VertexAttrib3dv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib3dv';
    
    {$endregion VertexAttrib[1,2,3][s,f,d]v}
    
    {$region VertexAttrib4[b,s,i,f,d,ub,us,ui]v}
    
    static procedure VertexAttrib4bv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of SByte);
    external 'opengl32.dll' name 'glVertexAttrib4bv';
    static procedure VertexAttrib4bv(index: UInt32; var v: SByte);
    external 'opengl32.dll' name 'glVertexAttrib4bv';
    static procedure VertexAttrib4bv(index: UInt32; var v: Vec4b);
    external 'opengl32.dll' name 'glVertexAttrib4bv';
    static procedure VertexAttrib4bv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib4bv';
    
    static procedure VertexAttrib4sv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of Int16);
    external 'opengl32.dll' name 'glVertexAttrib4sv';
    static procedure VertexAttrib4sv(index: UInt32; var v: Int16);
    external 'opengl32.dll' name 'glVertexAttrib4sv';
    static procedure VertexAttrib4sv(index: UInt32; var v: Vec4s);
    external 'opengl32.dll' name 'glVertexAttrib4sv';
    static procedure VertexAttrib4sv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib4sv';
    
    static procedure VertexAttrib4iv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of Int32);
    external 'opengl32.dll' name 'glVertexAttrib4iv';
    static procedure VertexAttrib4iv(index: UInt32; var v: Int32);
    external 'opengl32.dll' name 'glVertexAttrib4iv';
    static procedure VertexAttrib4iv(index: UInt32; var v: Vec4i);
    external 'opengl32.dll' name 'glVertexAttrib4iv';
    static procedure VertexAttrib4iv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib4iv';
    
    static procedure VertexAttrib4fv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of single);
    external 'opengl32.dll' name 'glVertexAttrib4fv';
    static procedure VertexAttrib4fv(index: UInt32; var v: single);
    external 'opengl32.dll' name 'glVertexAttrib4fv';
    static procedure VertexAttrib4fv(index: UInt32; var v: Vec4f);
    external 'opengl32.dll' name 'glVertexAttrib4fv';
    static procedure VertexAttrib4fv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib4fv';
    
    static procedure VertexAttrib4dv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of double);
    external 'opengl32.dll' name 'glVertexAttrib4dv';
    static procedure VertexAttrib4dv(index: UInt32; var v: double);
    external 'opengl32.dll' name 'glVertexAttrib4dv';
    static procedure VertexAttrib4dv(index: UInt32; var v: Vec4d);
    external 'opengl32.dll' name 'glVertexAttrib4dv';
    static procedure VertexAttrib4dv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib4dv';
    
    static procedure VertexAttrib4ubv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of Byte);
    external 'opengl32.dll' name 'glVertexAttrib4ubv';
    static procedure VertexAttrib4ubv(index: UInt32; var v: Byte);
    external 'opengl32.dll' name 'glVertexAttrib4ubv';
    static procedure VertexAttrib4ubv(index: UInt32; var v: Vec4ub);
    external 'opengl32.dll' name 'glVertexAttrib4ubv';
    static procedure VertexAttrib4ubv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib4ubv';
    
    static procedure VertexAttrib4usv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of UInt16);
    external 'opengl32.dll' name 'glVertexAttrib4usv';
    static procedure VertexAttrib4usv(index: UInt32; var v: UInt16);
    external 'opengl32.dll' name 'glVertexAttrib4usv';
    static procedure VertexAttrib4usv(index: UInt32; var v: Vec4us);
    external 'opengl32.dll' name 'glVertexAttrib4usv';
    static procedure VertexAttrib4usv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib4usv';
    
    static procedure VertexAttrib4uiv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of UInt32);
    external 'opengl32.dll' name 'glVertexAttrib4uiv';
    static procedure VertexAttrib4uiv(index: UInt32; var v: UInt32);
    external 'opengl32.dll' name 'glVertexAttrib4uiv';
    static procedure VertexAttrib4uiv(index: UInt32; var v: Vec4ui);
    external 'opengl32.dll' name 'glVertexAttrib4uiv';
    static procedure VertexAttrib4uiv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib4uiv';
    
    {$endregion VertexAttrib4[b,s,i,f,d,ub,us,ui]v}
    
    {$region VertexAttrib4Nub}
    
    static procedure VertexAttrib4Nub(index: UInt32; x: Byte; y: Byte; z: Byte; w: Byte);
    external 'opengl32.dll' name 'glVertexAttrib4Nub';
    
    {$endregion VertexAttrib4Nub}
    
    {$region VertexAttrib4N[b,s,i,ub,us,ui]v}
    
    static procedure VertexAttrib4Nbv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of SByte);
    external 'opengl32.dll' name 'glVertexAttrib4Nbv';
    static procedure VertexAttrib4Nbv(index: UInt32; var v: SByte);
    external 'opengl32.dll' name 'glVertexAttrib4Nbv';
    static procedure VertexAttrib4Nbv(index: UInt32; var v: Vec4b);
    external 'opengl32.dll' name 'glVertexAttrib4Nbv';
    static procedure VertexAttrib4Nbv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib4Nbv';
    
    static procedure VertexAttrib4Nsv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of Int16);
    external 'opengl32.dll' name 'glVertexAttrib4Nsv';
    static procedure VertexAttrib4Nsv(index: UInt32; var v: Int16);
    external 'opengl32.dll' name 'glVertexAttrib4Nsv';
    static procedure VertexAttrib4Nsv(index: UInt32; var v: Vec4s);
    external 'opengl32.dll' name 'glVertexAttrib4Nsv';
    static procedure VertexAttrib4Nsv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib4Nsv';
    
    static procedure VertexAttrib4Niv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of Int32);
    external 'opengl32.dll' name 'glVertexAttrib4Niv';
    static procedure VertexAttrib4Niv(index: UInt32; var v: Int32);
    external 'opengl32.dll' name 'glVertexAttrib4Niv';
    static procedure VertexAttrib4Niv(index: UInt32; var v: Vec4i);
    external 'opengl32.dll' name 'glVertexAttrib4Niv';
    static procedure VertexAttrib4Niv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib4Niv';
    
    static procedure VertexAttrib4Nubv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of Byte);
    external 'opengl32.dll' name 'glVertexAttrib4Nubv';
    static procedure VertexAttrib4Nubv(index: UInt32; var v: Byte);
    external 'opengl32.dll' name 'glVertexAttrib4Nubv';
    static procedure VertexAttrib4Nubv(index: UInt32; var v: Vec4ub);
    external 'opengl32.dll' name 'glVertexAttrib4Nubv';
    static procedure VertexAttrib4Nubv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib4Nubv';
    
    static procedure VertexAttrib4Nusv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of UInt16);
    external 'opengl32.dll' name 'glVertexAttrib4Nusv';
    static procedure VertexAttrib4Nusv(index: UInt32; var v: UInt16);
    external 'opengl32.dll' name 'glVertexAttrib4Nusv';
    static procedure VertexAttrib4Nusv(index: UInt32; var v: Vec4us);
    external 'opengl32.dll' name 'glVertexAttrib4Nusv';
    static procedure VertexAttrib4Nusv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib4Nusv';
    
    static procedure VertexAttrib4Nuiv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of UInt32);
    external 'opengl32.dll' name 'glVertexAttrib4Nuiv';
    static procedure VertexAttrib4Nuiv(index: UInt32; var v: UInt32);
    external 'opengl32.dll' name 'glVertexAttrib4Nuiv';
    static procedure VertexAttrib4Nuiv(index: UInt32; var v: Vec4ui);
    external 'opengl32.dll' name 'glVertexAttrib4Nuiv';
    static procedure VertexAttrib4Nuiv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib4Nuiv';
    
    {$endregion VertexAttrib4N[b,s,i,ub,us,ui]v}
    
    {$region VertexAttribI[1,2,3,4][i,ui]}
    
    static procedure VertexAttribI1i(index: UInt32; x: Int32);
    external 'opengl32.dll' name 'glVertexAttribI1i';
    
    static procedure VertexAttribI2i(index: UInt32; x: Int32; y: Int32);
    external 'opengl32.dll' name 'glVertexAttribI2i';
    
    static procedure VertexAttribI3i(index: UInt32; x: Int32; y: Int32; z: Int32);
    external 'opengl32.dll' name 'glVertexAttribI3i';
    
    static procedure VertexAttribI4i(index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32);
    external 'opengl32.dll' name 'glVertexAttribI4i';
    
    static procedure VertexAttribI1ui(index: UInt32; x: UInt32);
    external 'opengl32.dll' name 'glVertexAttribI1ui';
    
    static procedure VertexAttribI2ui(index: UInt32; x: UInt32; y: UInt32);
    external 'opengl32.dll' name 'glVertexAttribI2ui';
    
    static procedure VertexAttribI3ui(index: UInt32; x: UInt32; y: UInt32; z: UInt32);
    external 'opengl32.dll' name 'glVertexAttribI3ui';
    
    static procedure VertexAttribI4ui(index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32);
    external 'opengl32.dll' name 'glVertexAttribI4ui';
    
    {$endregion VertexAttribI[1,2,3,4][i,ui]}
    
    {$region VertexAttribI[1,2,3,4][i,ui]v}
    
    static procedure VertexAttribI1iv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of Int32);
    external 'opengl32.dll' name 'glVertexAttribI1iv';
    static procedure VertexAttribI1iv(index: UInt32; var v: Int32);
    external 'opengl32.dll' name 'glVertexAttribI1iv';
    static procedure VertexAttribI1iv(index: UInt32; var v: Vec1i);
    external 'opengl32.dll' name 'glVertexAttribI1iv';
    static procedure VertexAttribI1iv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttribI1iv';
    
    static procedure VertexAttribI2iv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of Int32);
    external 'opengl32.dll' name 'glVertexAttribI2iv';
    static procedure VertexAttribI2iv(index: UInt32; var v: Int32);
    external 'opengl32.dll' name 'glVertexAttribI2iv';
    static procedure VertexAttribI2iv(index: UInt32; var v: Vec2i);
    external 'opengl32.dll' name 'glVertexAttribI2iv';
    static procedure VertexAttribI2iv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttribI2iv';
    
    static procedure VertexAttribI3iv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of Int32);
    external 'opengl32.dll' name 'glVertexAttribI3iv';
    static procedure VertexAttribI3iv(index: UInt32; var v: Int32);
    external 'opengl32.dll' name 'glVertexAttribI3iv';
    static procedure VertexAttribI3iv(index: UInt32; var v: Vec3i);
    external 'opengl32.dll' name 'glVertexAttribI3iv';
    static procedure VertexAttribI3iv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttribI3iv';
    
    static procedure VertexAttribI4iv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of Int32);
    external 'opengl32.dll' name 'glVertexAttribI4iv';
    static procedure VertexAttribI4iv(index: UInt32; var v: Int32);
    external 'opengl32.dll' name 'glVertexAttribI4iv';
    static procedure VertexAttribI4iv(index: UInt32; var v: Vec4i);
    external 'opengl32.dll' name 'glVertexAttribI4iv';
    static procedure VertexAttribI4iv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttribI4iv';
    
    static procedure VertexAttribI1uiv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of UInt32);
    external 'opengl32.dll' name 'glVertexAttribI1uiv';
    static procedure VertexAttribI1uiv(index: UInt32; var v: UInt32);
    external 'opengl32.dll' name 'glVertexAttribI1uiv';
    static procedure VertexAttribI1uiv(index: UInt32; var v: Vec1ui);
    external 'opengl32.dll' name 'glVertexAttribI1uiv';
    static procedure VertexAttribI1uiv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttribI1uiv';
    
    static procedure VertexAttribI2uiv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of UInt32);
    external 'opengl32.dll' name 'glVertexAttribI2uiv';
    static procedure VertexAttribI2uiv(index: UInt32; var v: UInt32);
    external 'opengl32.dll' name 'glVertexAttribI2uiv';
    static procedure VertexAttribI2uiv(index: UInt32; var v: Vec2ui);
    external 'opengl32.dll' name 'glVertexAttribI2uiv';
    static procedure VertexAttribI2uiv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttribI2uiv';
    
    static procedure VertexAttribI3uiv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of UInt32);
    external 'opengl32.dll' name 'glVertexAttribI3uiv';
    static procedure VertexAttribI3uiv(index: UInt32; var v: UInt32);
    external 'opengl32.dll' name 'glVertexAttribI3uiv';
    static procedure VertexAttribI3uiv(index: UInt32; var v: Vec3ui);
    external 'opengl32.dll' name 'glVertexAttribI3uiv';
    static procedure VertexAttribI3uiv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttribI3uiv';
    
    static procedure VertexAttribI4uiv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of UInt32);
    external 'opengl32.dll' name 'glVertexAttribI4uiv';
    static procedure VertexAttribI4uiv(index: UInt32; var v: UInt32);
    external 'opengl32.dll' name 'glVertexAttribI4uiv';
    static procedure VertexAttribI4uiv(index: UInt32; var v: Vec4ui);
    external 'opengl32.dll' name 'glVertexAttribI4uiv';
    static procedure VertexAttribI4uiv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttribI4uiv';
    
    {$endregion VertexAttribI[1,2,3,4][i,ui]v}
    
    {$region VertexAttribI4[b,s,ub,us]v}
    
    static procedure VertexAttribI4bv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of SByte);
    external 'opengl32.dll' name 'glVertexAttribI4bv';
    static procedure VertexAttribI4bv(index: UInt32; var v: SByte);
    external 'opengl32.dll' name 'glVertexAttribI4bv';
    static procedure VertexAttribI4bv(index: UInt32; var v: Vec4b);
    external 'opengl32.dll' name 'glVertexAttribI4bv';
    static procedure VertexAttribI4bv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttribI4bv';
    
    static procedure VertexAttribI4sv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of Int16);
    external 'opengl32.dll' name 'glVertexAttribI4sv';
    static procedure VertexAttribI4sv(index: UInt32; var v: Int16);
    external 'opengl32.dll' name 'glVertexAttribI4sv';
    static procedure VertexAttribI4sv(index: UInt32; var v: Vec4s);
    external 'opengl32.dll' name 'glVertexAttribI4sv';
    static procedure VertexAttribI4sv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttribI4sv';
    
    static procedure VertexAttribI4ubv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of Byte);
    external 'opengl32.dll' name 'glVertexAttribI4ubv';
    static procedure VertexAttribI4ubv(index: UInt32; var v: Byte);
    external 'opengl32.dll' name 'glVertexAttribI4ubv';
    static procedure VertexAttribI4ubv(index: UInt32; var v: Vec4ub);
    external 'opengl32.dll' name 'glVertexAttribI4ubv';
    static procedure VertexAttribI4ubv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttribI4ubv';
    
    static procedure VertexAttribI4usv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of UInt16);
    external 'opengl32.dll' name 'glVertexAttribI4usv';
    static procedure VertexAttribI4usv(index: UInt32; var v: UInt16);
    external 'opengl32.dll' name 'glVertexAttribI4usv';
    static procedure VertexAttribI4usv(index: UInt32; var v: Vec4us);
    external 'opengl32.dll' name 'glVertexAttribI4usv';
    static procedure VertexAttribI4usv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttribI4usv';
    
    {$endregion VertexAttribI4[b,s,ub,us]v}
    
    {$region VertexAttribL[1,2,3,4]d}
    
    static procedure VertexAttribL1d(index: UInt32; x: double);
    external 'opengl32.dll' name 'glVertexAttribL1d';
    
    static procedure VertexAttribL2d(index: UInt32; x: double; y: double);
    external 'opengl32.dll' name 'glVertexAttribL2d';
    
    static procedure VertexAttribL3d(index: UInt32; x: double; y: double; z: double);
    external 'opengl32.dll' name 'glVertexAttribL3d';
    
    static procedure VertexAttribL4d(index: UInt32; x: double; y: double; z: double; w: double);
    external 'opengl32.dll' name 'glVertexAttribL4d';
    
    {$endregion VertexAttribL[1,2,3,4]d}
    
    {$region VertexAttribL[1,2,3,4]dv}
    
    static procedure VertexAttribL1dv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of double);
    external 'opengl32.dll' name 'glVertexAttribL1dv';
    static procedure VertexAttribL1dv(index: UInt32; var v: double);
    external 'opengl32.dll' name 'glVertexAttribL1dv';
    static procedure VertexAttribL1dv(index: UInt32; var v: Vec1d);
    external 'opengl32.dll' name 'glVertexAttribL1dv';
    static procedure VertexAttribL1dv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttribL1dv';
    
    static procedure VertexAttribL2dv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of double);
    external 'opengl32.dll' name 'glVertexAttribL2dv';
    static procedure VertexAttribL2dv(index: UInt32; var v: double);
    external 'opengl32.dll' name 'glVertexAttribL2dv';
    static procedure VertexAttribL2dv(index: UInt32; var v: Vec2d);
    external 'opengl32.dll' name 'glVertexAttribL2dv';
    static procedure VertexAttribL2dv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttribL2dv';
    
    static procedure VertexAttribL3dv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of double);
    external 'opengl32.dll' name 'glVertexAttribL3dv';
    static procedure VertexAttribL3dv(index: UInt32; var v: double);
    external 'opengl32.dll' name 'glVertexAttribL3dv';
    static procedure VertexAttribL3dv(index: UInt32; var v: Vec3d);
    external 'opengl32.dll' name 'glVertexAttribL3dv';
    static procedure VertexAttribL3dv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttribL3dv';
    
    static procedure VertexAttribL4dv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of double);
    external 'opengl32.dll' name 'glVertexAttribL4dv';
    static procedure VertexAttribL4dv(index: UInt32; var v: double);
    external 'opengl32.dll' name 'glVertexAttribL4dv';
    static procedure VertexAttribL4dv(index: UInt32; var v: Vec4d);
    external 'opengl32.dll' name 'glVertexAttribL4dv';
    static procedure VertexAttribL4dv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttribL4dv';
    
    {$endregion VertexAttribL[1,2,3,4]dv}
    
    {$region VertexAttribP[1,2,3,4]ui}
    
    static procedure VertexAttribP1ui(index: UInt32; &type: DataType; normalized: boolean; value: UInt32);
    external 'opengl32.dll' name 'glVertexAttribP1ui';
    
    static procedure VertexAttribP2ui(index: UInt32; &type: DataType; normalized: boolean; value: UInt32);
    external 'opengl32.dll' name 'glVertexAttribP2ui';
    
    static procedure VertexAttribP3ui(index: UInt32; &type: DataType; normalized: boolean; value: UInt32);
    external 'opengl32.dll' name 'glVertexAttribP3ui';
    
    static procedure VertexAttribP4ui(index: UInt32; &type: DataType; normalized: boolean; value: UInt32);
    external 'opengl32.dll' name 'glVertexAttribP4ui';
    
    {$endregion VertexAttribP[1,2,3,4]ui}
    
    {$region VertexAttribP[1,2,3,4]uiv}
    
    static procedure VertexAttribP1uiv(index: UInt32; &type: DataType; normalized: boolean; var value: UInt32);
    external 'opengl32.dll' name 'glVertexAttribP1uiv';
    static procedure VertexAttribP1uiv(index: UInt32; &type: DataType; normalized: boolean; value: pointer);
    external 'opengl32.dll' name 'glVertexAttribP1uiv';
    
    static procedure VertexAttribP2uiv(index: UInt32; &type: DataType; normalized: boolean; var value: UInt32);
    external 'opengl32.dll' name 'glVertexAttribP2uiv';
    static procedure VertexAttribP2uiv(index: UInt32; &type: DataType; normalized: boolean; value: pointer);
    external 'opengl32.dll' name 'glVertexAttribP2uiv';
    
    static procedure VertexAttribP3uiv(index: UInt32; &type: DataType; normalized: boolean; var value: UInt32);
    external 'opengl32.dll' name 'glVertexAttribP3uiv';
    static procedure VertexAttribP3uiv(index: UInt32; &type: DataType; normalized: boolean; value: pointer);
    external 'opengl32.dll' name 'glVertexAttribP3uiv';
    
    static procedure VertexAttribP4uiv(index: UInt32; &type: DataType; normalized: boolean; var value: UInt32);
    external 'opengl32.dll' name 'glVertexAttribP4uiv';
    static procedure VertexAttribP4uiv(index: UInt32; &type: DataType; normalized: boolean; value: pointer);
    external 'opengl32.dll' name 'glVertexAttribP4uiv';
    
    {$endregion VertexAttribP[1,2,3,4]uiv}
    
    {$endregion 10.2 - Current Vertex Attribute Values}
    
    {$region 10.3 - Vertex Arrays}
    
    // 10.3.1
    
    static procedure GenVertexArrays(n: Int32; [MarshalAs(UnmanagedType.LPArray)] arrays: array of VertexArrayName);
    external 'opengl32.dll' name 'glGenVertexArrays';
    static procedure GenVertexArrays(n: Int32; var arrays: VertexArrayName);
    external 'opengl32.dll' name 'glGenVertexArrays';
    static procedure GenVertexArrays(n: Int32; arrays: pointer);
    external 'opengl32.dll' name 'glGenVertexArrays';
    
    static procedure DeleteVertexArrays(n: Int32; [MarshalAs(UnmanagedType.LPArray)] arrays: array of VertexArrayName);
    external 'opengl32.dll' name 'glDeleteVertexArrays';
    static procedure DeleteVertexArrays(n: Int32; var arrays: VertexArrayName);
    external 'opengl32.dll' name 'glDeleteVertexArrays';
    static procedure DeleteVertexArrays(n: Int32; arrays: pointer);
    external 'opengl32.dll' name 'glDeleteVertexArrays';
    
    static procedure BindVertexArray(&array: VertexArrayName);
    external 'opengl32.dll' name 'glBindVertexArray';
    
    static procedure CreateVertexArrays(n: Int32; [MarshalAs(UnmanagedType.LPArray)] arrays: array of VertexArrayName);
    external 'opengl32.dll' name 'glCreateVertexArrays';
    static procedure CreateVertexArrays(n: Int32; var arrays: VertexArrayName);
    external 'opengl32.dll' name 'glCreateVertexArrays';
    static procedure CreateVertexArrays(n: Int32; arrays: pointer);
    external 'opengl32.dll' name 'glCreateVertexArrays';
    
    static function IsVertexArray(&array: VertexArrayName): boolean;
    external 'opengl32.dll' name 'glIsVertexArray';
    
    static procedure VertexArrayElementBuffer(vaobj: VertexArrayName; buffer: BufferName);
    external 'opengl32.dll' name 'glVertexArrayElementBuffer';
    
    // 10.3.2
    
    static procedure VertexAttribFormat(attribindex: UInt32; size: Int32; &type: DataType; normalized: boolean; relativeoffset: UInt32);
    external 'opengl32.dll' name 'glVertexAttribFormat';
    
    static procedure VertexAttribIFormat(attribindex: UInt32; size: Int32; &type: DataType; relativeoffset: UInt32);
    external 'opengl32.dll' name 'glVertexAttribIFormat';
    
    static procedure VertexAttribLFormat(attribindex: UInt32; size: Int32; &type: DataType; relativeoffset: UInt32);
    external 'opengl32.dll' name 'glVertexAttribLFormat';
    
    static procedure VertexArrayAttribFormat(vaobj: VertexArrayName; attribindex: UInt32; size: Int32; &type: DataType; normalized: boolean; relativeoffset: UInt32);
    external 'opengl32.dll' name 'glVertexArrayAttribFormat';
    
    static procedure VertexArrayAttribIFormat(vaobj: VertexArrayName; attribindex: UInt32; size: Int32; &type: DataType; relativeoffset: UInt32);
    external 'opengl32.dll' name 'glVertexArrayAttribIFormat';
    
    static procedure VertexArrayAttribLFormat(vaobj: VertexArrayName; attribindex: UInt32; size: Int32; &type: DataType; relativeoffset: UInt32);
    external 'opengl32.dll' name 'glVertexArrayAttribLFormat';
    
    static procedure BindVertexBuffer(bindingindex: UInt32; buffer: BufferName; offset: IntPtr; stride: Int32);
    external 'opengl32.dll' name 'glBindVertexBuffer';
    
    static procedure VertexArrayVertexBuffer(vaobj: VertexArrayName; bindingindex: UInt32; buffer: BufferName; offset: IntPtr; stride: Int32);
    external 'opengl32.dll' name 'glVertexArrayVertexBuffer';
    
    static procedure BindVertexBuffers(first: UInt32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] buffers: array of BufferName; [MarshalAs(UnmanagedType.LPArray)] offsets: array of IntPtr; [MarshalAs(UnmanagedType.LPArray)] strides: array of Int32);
    external 'opengl32.dll' name 'glBindVertexBuffers';
    static procedure BindVertexBuffers(first: UInt32; count: Int32; var buffers: BufferName; var offsets: IntPtr; var strides: Int32);
    external 'opengl32.dll' name 'glBindVertexBuffers';
    static procedure BindVertexBuffers(first: UInt32; count: Int32; buffers: pointer; offsets: pointer; strides: pointer);
    external 'opengl32.dll' name 'glBindVertexBuffers';
    
    static procedure VertexArrayVertexBuffers(vaobj: VertexArrayName; first: UInt32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] buffers: array of BufferName; [MarshalAs(UnmanagedType.LPArray)] offsets: array of IntPtr; [MarshalAs(UnmanagedType.LPArray)] strides: array of Int32);
    external 'opengl32.dll' name 'glVertexArrayVertexBuffers';
    static procedure VertexArrayVertexBuffers(vaobj: VertexArrayName; first: UInt32; count: Int32; var buffers: BufferName; var offsets: IntPtr; var strides: Int32);
    external 'opengl32.dll' name 'glVertexArrayVertexBuffers';
    static procedure VertexArrayVertexBuffers(vaobj: VertexArrayName; first: UInt32; count: Int32; buffers: pointer; offsets: pointer; strides: pointer);
    external 'opengl32.dll' name 'glVertexArrayVertexBuffers';
    
    static procedure VertexAttribBinding(attribindex: UInt32; bindingindex: UInt32);
    external 'opengl32.dll' name 'glVertexAttribBinding';
    
    static procedure VertexArrayAttribBinding(vaobj: VertexArrayName; attribindex: UInt32; bindingindex: UInt32);
    external 'opengl32.dll' name 'glVertexArrayAttribBinding';
    
    static procedure VertexAttribPointer(index: UInt32; size: Int32; &type: DataType; normalized: boolean; stride: Int32; _pointer: IntPtr);
    external 'opengl32.dll' name 'glVertexAttribPointer';
    static procedure VertexAttribPointer(index: UInt32; size: Int32; &type: DataType; normalized: boolean; stride: Int32; _pointer: pointer);
    external 'opengl32.dll' name 'glVertexAttribPointer';
    
    static procedure VertexAttribIPointer(index: UInt32; size: Int32; &type: DataType; stride: Int32; _pointer: IntPtr);
    external 'opengl32.dll' name 'glVertexAttribIPointer';
    static procedure VertexAttribIPointer(index: UInt32; size: Int32; &type: DataType; stride: Int32; _pointer: pointer);
    external 'opengl32.dll' name 'glVertexAttribIPointer';
    
    static procedure VertexAttribLPointer(index: UInt32; size: Int32; &type: DataType; stride: Int32; _pointer: IntPtr);
    external 'opengl32.dll' name 'glVertexAttribLPointer';
    static procedure VertexAttribLPointer(index: UInt32; size: Int32; &type: DataType; stride: Int32; _pointer: pointer);
    external 'opengl32.dll' name 'glVertexAttribLPointer';
    
    static procedure EnableVertexAttribArray(index: UInt32);
    external 'opengl32.dll' name 'glEnableVertexAttribArray';
    
    static procedure EnableVertexArrayAttrib(vaobj: VertexArrayName; index: UInt32);
    external 'opengl32.dll' name 'glEnableVertexArrayAttrib';
    
    static procedure DisableVertexAttribArray(index: UInt32);
    external 'opengl32.dll' name 'glDisableVertexAttribArray';
    
    static procedure DisableVertexArrayAttrib(vaobj: VertexArrayName; index: UInt32);
    external 'opengl32.dll' name 'glDisableVertexArrayAttrib';
    
    static procedure VertexBindingDivisor(bindingindex: UInt32; divisor: UInt32);
    external 'opengl32.dll' name 'glVertexBindingDivisor';
    
    static procedure VertexArrayBindingDivisor(vaobj: VertexArrayName; bindingindex: UInt32; divisor: UInt32);
    external 'opengl32.dll' name 'glVertexArrayBindingDivisor';
    
    static procedure VertexAttribDivisor(index: UInt32; divisor: UInt32);
    external 'opengl32.dll' name 'glVertexAttribDivisor';
    
    // 10.3.6
    
    static procedure Disable(cap: EnablableName);
    external 'opengl32.dll' name 'glDisable';
    
    static procedure Enable(cap: EnablableName);
    external 'opengl32.dll' name 'glEnable';
    
    static procedure PrimitiveRestartIndex(index: UInt32);
    external 'opengl32.dll' name 'glPrimitiveRestartIndex';
    
    {$endregion 10.3 - Vertex Arrays}
    
    {$region 10.4 - Drawing Commands Using Vertex Arrays}
    
    static procedure DrawArrays(mode: PrimitiveType; first: Int32; count: Int32);
    external 'opengl32.dll' name 'glDrawArrays';
    
    static procedure DrawArraysInstancedBaseInstance(mode: PrimitiveType; first: Int32; count: Int32; instancecount: Int32; baseinstance: UInt32);
    external 'opengl32.dll' name 'glDrawArraysInstancedBaseInstance';
    
    static procedure DrawArraysInstanced(mode: PrimitiveType; first: Int32; count: Int32; instancecount: Int32);
    external 'opengl32.dll' name 'glDrawArraysInstanced';
    
    static procedure DrawArraysIndirect(mode: PrimitiveType; var indirect: DrawArraysIndirectCommand);
    external 'opengl32.dll' name 'glDrawArraysIndirect';
    static procedure DrawArraysIndirect(mode: PrimitiveType; indirect: pointer);
    external 'opengl32.dll' name 'glDrawArraysIndirect';
    
    static procedure MultiDrawArrays(mode: PrimitiveType; [MarshalAs(UnmanagedType.LPArray)] first: array of Int32; [MarshalAs(UnmanagedType.LPArray)] count: array of Int32; drawcount: Int32);
    external 'opengl32.dll' name 'glMultiDrawArrays';
    static procedure MultiDrawArrays(mode: PrimitiveType; var first: Int32; var count: Int32; drawcount: Int32);
    external 'opengl32.dll' name 'glMultiDrawArrays';
    static procedure MultiDrawArrays(mode: PrimitiveType; first: pointer; count: pointer; drawcount: Int32);
    external 'opengl32.dll' name 'glMultiDrawArrays';
    
    static procedure MultiDrawArraysIndirect(mode: PrimitiveType; [MarshalAs(UnmanagedType.LPArray)] indirect: array of DrawArraysIndirectCommand; drawcount: Int32; stride: Int32);
    external 'opengl32.dll' name 'glMultiDrawArraysIndirect';
    static procedure MultiDrawArraysIndirect(mode: PrimitiveType; var indirect: DrawArraysIndirectCommand; drawcount: Int32; stride: Int32);
    external 'opengl32.dll' name 'glMultiDrawArraysIndirect';
    static procedure MultiDrawArraysIndirect(mode: PrimitiveType; indirect: pointer; drawcount: Int32; stride: Int32);
    external 'opengl32.dll' name 'glMultiDrawArraysIndirect';
    
    static procedure MultiDrawArraysIndirectCount(mode: PrimitiveType; [MarshalAs(UnmanagedType.LPArray)] indirect: array of DrawArraysIndirectCommand; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32);
    external 'opengl32.dll' name 'glMultiDrawArraysIndirectCount';
    static procedure MultiDrawArraysIndirectCount(mode: PrimitiveType; var indirect: DrawArraysIndirectCommand; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32);
    external 'opengl32.dll' name 'glMultiDrawArraysIndirectCount';
    static procedure MultiDrawArraysIndirectCount(mode: PrimitiveType; indirect: pointer; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32);
    external 'opengl32.dll' name 'glMultiDrawArraysIndirectCount';
    
    static procedure DrawElements(mode: PrimitiveType; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of UInt32);
    external 'opengl32.dll' name 'glDrawElements';
    static procedure DrawElements(mode: PrimitiveType; count: Int32; &type: DataType; var indices: UInt32);
    external 'opengl32.dll' name 'glDrawElements';
    static procedure DrawElements(mode: PrimitiveType; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of UInt16);
    external 'opengl32.dll' name 'glDrawElements';
    static procedure DrawElements(mode: PrimitiveType; count: Int32; &type: DataType; var indices: UInt16);
    external 'opengl32.dll' name 'glDrawElements';
    static procedure DrawElements(mode: PrimitiveType; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of Byte);
    external 'opengl32.dll' name 'glDrawElements';
    static procedure DrawElements(mode: PrimitiveType; count: Int32; &type: DataType; var indices: Byte);
    external 'opengl32.dll' name 'glDrawElements';
    static procedure DrawElements(mode: PrimitiveType; count: Int32; &type: DataType; indices: pointer);
    external 'opengl32.dll' name 'glDrawElements';
    
    static procedure DrawElementsInstancedBaseInstance(mode: PrimitiveType; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of UInt32; instancecount: Int32; baseinstance: UInt32);
    external 'opengl32.dll' name 'glDrawElementsInstancedBaseInstance';
    static procedure DrawElementsInstancedBaseInstance(mode: PrimitiveType; count: Int32; &type: DataType; var indices: UInt32; instancecount: Int32; baseinstance: UInt32);
    external 'opengl32.dll' name 'glDrawElementsInstancedBaseInstance';
    static procedure DrawElementsInstancedBaseInstance(mode: PrimitiveType; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of UInt16; instancecount: Int32; baseinstance: UInt32);
    external 'opengl32.dll' name 'glDrawElementsInstancedBaseInstance';
    static procedure DrawElementsInstancedBaseInstance(mode: PrimitiveType; count: Int32; &type: DataType; var indices: UInt16; instancecount: Int32; baseinstance: UInt32);
    external 'opengl32.dll' name 'glDrawElementsInstancedBaseInstance';
    static procedure DrawElementsInstancedBaseInstance(mode: PrimitiveType; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of Byte; instancecount: Int32; baseinstance: UInt32);
    external 'opengl32.dll' name 'glDrawElementsInstancedBaseInstance';
    static procedure DrawElementsInstancedBaseInstance(mode: PrimitiveType; count: Int32; &type: DataType; var indices: Byte; instancecount: Int32; baseinstance: UInt32);
    external 'opengl32.dll' name 'glDrawElementsInstancedBaseInstance';
    static procedure DrawElementsInstancedBaseInstance(mode: PrimitiveType; count: Int32; &type: DataType; indices: pointer; instancecount: Int32; baseinstance: UInt32);
    external 'opengl32.dll' name 'glDrawElementsInstancedBaseInstance';
    
    static procedure DrawElementsInstanced(mode: PrimitiveType; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of UInt32; instancecount: Int32);
    external 'opengl32.dll' name 'glDrawElementsInstanced';
    static procedure DrawElementsInstanced(mode: PrimitiveType; count: Int32; &type: DataType; var indices: UInt32; instancecount: Int32);
    external 'opengl32.dll' name 'glDrawElementsInstanced';
    static procedure DrawElementsInstanced(mode: PrimitiveType; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of UInt16; instancecount: Int32);
    external 'opengl32.dll' name 'glDrawElementsInstanced';
    static procedure DrawElementsInstanced(mode: PrimitiveType; count: Int32; &type: DataType; var indices: UInt16; instancecount: Int32);
    external 'opengl32.dll' name 'glDrawElementsInstanced';
    static procedure DrawElementsInstanced(mode: PrimitiveType; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of Byte; instancecount: Int32);
    external 'opengl32.dll' name 'glDrawElementsInstanced';
    static procedure DrawElementsInstanced(mode: PrimitiveType; count: Int32; &type: DataType; var indices: Byte; instancecount: Int32);
    external 'opengl32.dll' name 'glDrawElementsInstanced';
    static procedure DrawElementsInstanced(mode: PrimitiveType; count: Int32; &type: DataType; indices: pointer; instancecount: Int32);
    external 'opengl32.dll' name 'glDrawElementsInstanced';
    
    static procedure MultiDrawElements(mode: PrimitiveType; [MarshalAs(UnmanagedType.LPArray)] count: array of Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.LPArray)] indices: array of array of UInt32; drawcount: Int32);
    external 'opengl32.dll' name 'glMultiDrawElements';
    static procedure MultiDrawElements(mode: PrimitiveType; [MarshalAs(UnmanagedType.LPArray)] count: array of Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.LPArray)] indices: array of array of UInt16; drawcount: Int32);
    external 'opengl32.dll' name 'glMultiDrawElements';
    static procedure MultiDrawElements(mode: PrimitiveType; [MarshalAs(UnmanagedType.LPArray)] count: array of Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.LPArray)] indices: array of array of Byte; drawcount: Int32);
    external 'opengl32.dll' name 'glMultiDrawElements';
    static procedure MultiDrawElements(mode: PrimitiveType; [MarshalAs(UnmanagedType.LPArray)] count: array of Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of IntPtr; drawcount: Int32);
    external 'opengl32.dll' name 'glMultiDrawElements';
    static procedure MultiDrawElements(mode: PrimitiveType; var count: Int32; &type: DataType; [MarshalAs(UnmanagedType.SysInt, ArraySubType = UnmanagedType.LPArray)] var indices: array of UInt32; drawcount: Int32);
    external 'opengl32.dll' name 'glMultiDrawElements';
    static procedure MultiDrawElements(mode: PrimitiveType; var count: Int32; &type: DataType; [MarshalAs(UnmanagedType.SysInt, ArraySubType = UnmanagedType.LPArray)] var indices: array of UInt16; drawcount: Int32);
    external 'opengl32.dll' name 'glMultiDrawElements';
    static procedure MultiDrawElements(mode: PrimitiveType; var count: Int32; &type: DataType; [MarshalAs(UnmanagedType.SysInt, ArraySubType = UnmanagedType.LPArray)] var indices: array of Byte; drawcount: Int32);
    external 'opengl32.dll' name 'glMultiDrawElements';
    static procedure MultiDrawElements(mode: PrimitiveType; var count: Int32; &type: DataType; var indices: IntPtr; drawcount: Int32);
    external 'opengl32.dll' name 'glMultiDrawElements';
    static procedure MultiDrawElements(mode: PrimitiveType; var count: Int32; &type: DataType; var indices: pointer; drawcount: Int32);
    external 'opengl32.dll' name 'glMultiDrawElements';
    static procedure MultiDrawElements(mode: PrimitiveType; count: pointer; &type: DataType; indices: pointer; drawcount: Int32);
    external 'opengl32.dll' name 'glMultiDrawElements';
    
    static procedure DrawRangeElements(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of UInt32);
    external 'opengl32.dll' name 'glDrawRangeElements';
    static procedure DrawRangeElements(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; var indices: UInt32);
    external 'opengl32.dll' name 'glDrawRangeElements';
    static procedure DrawRangeElements(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of UInt16);
    external 'opengl32.dll' name 'glDrawRangeElements';
    static procedure DrawRangeElements(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; var indices: UInt16);
    external 'opengl32.dll' name 'glDrawRangeElements';
    static procedure DrawRangeElements(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of Byte);
    external 'opengl32.dll' name 'glDrawRangeElements';
    static procedure DrawRangeElements(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; var indices: Byte);
    external 'opengl32.dll' name 'glDrawRangeElements';
    static procedure DrawRangeElements(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; indices: pointer);
    external 'opengl32.dll' name 'glDrawRangeElements';
    
    static procedure DrawElementsBaseVertex(mode: PrimitiveType; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of UInt32; basevertex: Int32);
    external 'opengl32.dll' name 'glDrawElementsBaseVertex';
    static procedure DrawElementsBaseVertex(mode: PrimitiveType; count: Int32; &type: DataType; var indices: UInt32; basevertex: Int32);
    external 'opengl32.dll' name 'glDrawElementsBaseVertex';
    static procedure DrawElementsBaseVertex(mode: PrimitiveType; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of UInt16; basevertex: Int32);
    external 'opengl32.dll' name 'glDrawElementsBaseVertex';
    static procedure DrawElementsBaseVertex(mode: PrimitiveType; count: Int32; &type: DataType; var indices: UInt16; basevertex: Int32);
    external 'opengl32.dll' name 'glDrawElementsBaseVertex';
    static procedure DrawElementsBaseVertex(mode: PrimitiveType; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of Byte; basevertex: Int32);
    external 'opengl32.dll' name 'glDrawElementsBaseVertex';
    static procedure DrawElementsBaseVertex(mode: PrimitiveType; count: Int32; &type: DataType; var indices: Byte; basevertex: Int32);
    external 'opengl32.dll' name 'glDrawElementsBaseVertex';
    static procedure DrawElementsBaseVertex(mode: PrimitiveType; count: Int32; &type: DataType; indices: pointer; basevertex: Int32);
    external 'opengl32.dll' name 'glDrawElementsBaseVertex';
    
    static procedure DrawRangeElementsBaseVertex(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of UInt32; basevertex: Int32);
    external 'opengl32.dll' name 'glDrawRangeElementsBaseVertex';
    static procedure DrawRangeElementsBaseVertex(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; var indices: UInt32; basevertex: Int32);
    external 'opengl32.dll' name 'glDrawRangeElementsBaseVertex';
    static procedure DrawRangeElementsBaseVertex(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of UInt16; basevertex: Int32);
    external 'opengl32.dll' name 'glDrawRangeElementsBaseVertex';
    static procedure DrawRangeElementsBaseVertex(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; var indices: UInt16; basevertex: Int32);
    external 'opengl32.dll' name 'glDrawRangeElementsBaseVertex';
    static procedure DrawRangeElementsBaseVertex(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of Byte; basevertex: Int32);
    external 'opengl32.dll' name 'glDrawRangeElementsBaseVertex';
    static procedure DrawRangeElementsBaseVertex(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; var indices: Byte; basevertex: Int32);
    external 'opengl32.dll' name 'glDrawRangeElementsBaseVertex';
    static procedure DrawRangeElementsBaseVertex(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; indices: pointer; basevertex: Int32);
    external 'opengl32.dll' name 'glDrawRangeElementsBaseVertex';
    
    static procedure DrawElementsInstancedBaseVertex(mode: PrimitiveType; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of UInt32; instancecount: Int32; basevertex: Int32);
    external 'opengl32.dll' name 'glDrawElementsInstancedBaseVertex';
    static procedure DrawElementsInstancedBaseVertex(mode: PrimitiveType; count: Int32; &type: DataType; var indices: UInt32; instancecount: Int32; basevertex: Int32);
    external 'opengl32.dll' name 'glDrawElementsInstancedBaseVertex';
    static procedure DrawElementsInstancedBaseVertex(mode: PrimitiveType; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of UInt16; instancecount: Int32; basevertex: Int32);
    external 'opengl32.dll' name 'glDrawElementsInstancedBaseVertex';
    static procedure DrawElementsInstancedBaseVertex(mode: PrimitiveType; count: Int32; &type: DataType; var indices: UInt16; instancecount: Int32; basevertex: Int32);
    external 'opengl32.dll' name 'glDrawElementsInstancedBaseVertex';
    static procedure DrawElementsInstancedBaseVertex(mode: PrimitiveType; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of Byte; instancecount: Int32; basevertex: Int32);
    external 'opengl32.dll' name 'glDrawElementsInstancedBaseVertex';
    static procedure DrawElementsInstancedBaseVertex(mode: PrimitiveType; count: Int32; &type: DataType; var indices: Byte; instancecount: Int32; basevertex: Int32);
    external 'opengl32.dll' name 'glDrawElementsInstancedBaseVertex';
    static procedure DrawElementsInstancedBaseVertex(mode: PrimitiveType; count: Int32; &type: DataType; indices: pointer; instancecount: Int32; basevertex: Int32);
    external 'opengl32.dll' name 'glDrawElementsInstancedBaseVertex';
    
    static procedure DrawElementsInstancedBaseVertexBaseInstance(mode: PrimitiveType; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of UInt32; instancecount: Int32; basevertex: Int32; baseinstance: UInt32);
    external 'opengl32.dll' name 'glDrawElementsInstancedBaseVertexBaseInstance';
    static procedure DrawElementsInstancedBaseVertexBaseInstance(mode: PrimitiveType; count: Int32; &type: DataType; var indices: UInt32; instancecount: Int32; basevertex: Int32; baseinstance: UInt32);
    external 'opengl32.dll' name 'glDrawElementsInstancedBaseVertexBaseInstance';
    static procedure DrawElementsInstancedBaseVertexBaseInstance(mode: PrimitiveType; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of UInt16; instancecount: Int32; basevertex: Int32; baseinstance: UInt32);
    external 'opengl32.dll' name 'glDrawElementsInstancedBaseVertexBaseInstance';
    static procedure DrawElementsInstancedBaseVertexBaseInstance(mode: PrimitiveType; count: Int32; &type: DataType; var indices: UInt16; instancecount: Int32; basevertex: Int32; baseinstance: UInt32);
    external 'opengl32.dll' name 'glDrawElementsInstancedBaseVertexBaseInstance';
    static procedure DrawElementsInstancedBaseVertexBaseInstance(mode: PrimitiveType; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of Byte; instancecount: Int32; basevertex: Int32; baseinstance: UInt32);
    external 'opengl32.dll' name 'glDrawElementsInstancedBaseVertexBaseInstance';
    static procedure DrawElementsInstancedBaseVertexBaseInstance(mode: PrimitiveType; count: Int32; &type: DataType; var indices: Byte; instancecount: Int32; basevertex: Int32; baseinstance: UInt32);
    external 'opengl32.dll' name 'glDrawElementsInstancedBaseVertexBaseInstance';
    static procedure DrawElementsInstancedBaseVertexBaseInstance(mode: PrimitiveType; count: Int32; &type: DataType; indices: pointer; instancecount: Int32; basevertex: Int32; baseinstance: UInt32);
    external 'opengl32.dll' name 'glDrawElementsInstancedBaseVertexBaseInstance';
    
    static procedure DrawElementsIndirect(mode: PrimitiveType; &type: DataType; var indirect: DrawArraysIndirectCommand);
    external 'opengl32.dll' name 'glDrawElementsIndirect';
    static procedure DrawElementsIndirect(mode: PrimitiveType; &type: DataType; indirect: pointer);
    external 'opengl32.dll' name 'glDrawElementsIndirect';
    
    static procedure MultiDrawElementsIndirect(mode: PrimitiveType; &type: DataType; var indirect: DrawArraysIndirectCommand; drawcount: Int32; stride: Int32);
    external 'opengl32.dll' name 'glMultiDrawElementsIndirect';
    static procedure MultiDrawElementsIndirect(mode: PrimitiveType; &type: DataType; indirect: pointer; drawcount: Int32; stride: Int32);
    external 'opengl32.dll' name 'glMultiDrawElementsIndirect';
    
    static procedure MultiDrawElementsIndirectCount(mode: PrimitiveType; &type: DataType; var indirect: DrawArraysIndirectCommand; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32);
    external 'opengl32.dll' name 'glMultiDrawElementsIndirectCount';
    static procedure MultiDrawElementsIndirectCount(mode: PrimitiveType; &type: DataType; indirect: pointer; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32);
    external 'opengl32.dll' name 'glMultiDrawElementsIndirectCount';
    
    static procedure MultiDrawElementsBaseVertex(mode: PrimitiveType; [MarshalAs(UnmanagedType.LPArray)] count: array of Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.LPArray)] indices: array of array of UInt32; drawcount: Int32; [MarshalAs(UnmanagedType.LPArray)] basevertex: array of Int32);
    external 'opengl32.dll' name 'glMultiDrawElementsBaseVertex';
    static procedure MultiDrawElementsBaseVertex(mode: PrimitiveType; [MarshalAs(UnmanagedType.LPArray)] count: array of Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.LPArray)] indices: array of array of UInt16; drawcount: Int32; [MarshalAs(UnmanagedType.LPArray)] basevertex: array of Int32);
    external 'opengl32.dll' name 'glMultiDrawElementsBaseVertex';
    static procedure MultiDrawElementsBaseVertex(mode: PrimitiveType; [MarshalAs(UnmanagedType.LPArray)] count: array of Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.LPArray)] indices: array of array of Byte; drawcount: Int32; [MarshalAs(UnmanagedType.LPArray)] basevertex: array of Int32);
    external 'opengl32.dll' name 'glMultiDrawElementsBaseVertex';
    static procedure MultiDrawElementsBaseVertex(mode: PrimitiveType; [MarshalAs(UnmanagedType.LPArray)] count: array of Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of IntPtr; drawcount: Int32; var basevertex: Int32);
    external 'opengl32.dll' name 'glMultiDrawElementsBaseVertex';
    static procedure MultiDrawElementsBaseVertex(mode: PrimitiveType; var count: Int32; &type: DataType; [MarshalAs(UnmanagedType.SysInt, ArraySubType = UnmanagedType.LPArray)] var indices: array of UInt32; drawcount: Int32; var basevertex: Int32);
    external 'opengl32.dll' name 'glMultiDrawElementsBaseVertex';
    static procedure MultiDrawElementsBaseVertex(mode: PrimitiveType; var count: Int32; &type: DataType; [MarshalAs(UnmanagedType.SysInt, ArraySubType = UnmanagedType.LPArray)] var indices: array of UInt16; drawcount: Int32; var basevertex: Int32);
    external 'opengl32.dll' name 'glMultiDrawElementsBaseVertex';
    static procedure MultiDrawElementsBaseVertex(mode: PrimitiveType; var count: Int32; &type: DataType; [MarshalAs(UnmanagedType.SysInt, ArraySubType = UnmanagedType.LPArray)] var indices: array of Byte; drawcount: Int32; var basevertex: Int32);
    external 'opengl32.dll' name 'glMultiDrawElementsBaseVertex';
    static procedure MultiDrawElementsBaseVertex(mode: PrimitiveType; var count: Int32; &type: DataType; var indices: IntPtr; drawcount: Int32; var basevertex: Int32);
    external 'opengl32.dll' name 'glMultiDrawElementsBaseVertex';
    static procedure MultiDrawElementsBaseVertex(mode: PrimitiveType; var count: Int32; &type: DataType; var indices: pointer; drawcount: Int32; var basevertex: Int32);
    external 'opengl32.dll' name 'glMultiDrawElementsBaseVertex';
    static procedure MultiDrawElementsBaseVertex(mode: PrimitiveType; count: pointer; &type: DataType; indices: pointer; drawcount: Int32; basevertex: pointer);
    external 'opengl32.dll' name 'glMultiDrawElementsBaseVertex';
    
    {$endregion 10.4 - Drawing Commands Using Vertex Arrays}
    
    {$region 10.5 - Vertex Array and Vertex Array Object Queries}
    
    static procedure GetVertexArrayiv(vaobj: VertexArrayName; pname: VertexAttribInfoType; var param: BufferName);
    external 'opengl32.dll' name 'glGetVertexArrayiv';
    static procedure GetVertexArrayiv(vaobj: VertexArrayName; pname: VertexAttribInfoType; var param: Int32);
    external 'opengl32.dll' name 'glGetVertexArrayiv';
    static procedure GetVertexArrayiv(vaobj: VertexArrayName; pname: VertexAttribInfoType; param: pointer);
    external 'opengl32.dll' name 'glGetVertexArrayiv';
    
    static procedure GetVertexArrayIndexediv(vaobj: VertexArrayName; index: UInt32; pname: VertexAttribInfoType; var param: Int32);
    external 'opengl32.dll' name 'glGetVertexArrayIndexediv';
    static procedure GetVertexArrayIndexediv(vaobj: VertexArrayName; index: UInt32; pname: VertexAttribInfoType; var param: DataType);
    external 'opengl32.dll' name 'glGetVertexArrayIndexediv';
    static procedure GetVertexArrayIndexediv(vaobj: VertexArrayName; index: UInt32; pname: VertexAttribInfoType; param: pointer);
    external 'opengl32.dll' name 'glGetVertexArrayIndexediv';
    
    static procedure GetVertexArrayIndexed64iv(vaobj: VertexArrayName; index: UInt32; pname: VertexAttribInfoType; var param: Int64);
    external 'opengl32.dll' name 'glGetVertexArrayIndexed64iv';
    static procedure GetVertexArrayIndexed64iv(vaobj: VertexArrayName; index: UInt32; pname: VertexAttribInfoType; param: pointer);
    external 'opengl32.dll' name 'glGetVertexArrayIndexed64iv';
    
    static procedure GetVertexAttribdv(index: UInt32; pname: VertexAttribInfoType; [MarshalAs(UnmanagedType.LPArray)] &params: array of double);
    external 'opengl32.dll' name 'glGetVertexAttribdv';
    static procedure GetVertexAttribdv(index: UInt32; pname: VertexAttribInfoType; var &params: double);
    external 'opengl32.dll' name 'glGetVertexAttribdv';
    static procedure GetVertexAttribdv(index: UInt32; pname: VertexAttribInfoType; var &params: Vec4d);
    external 'opengl32.dll' name 'glGetVertexAttribdv';
    static procedure GetVertexAttribdv(index: UInt32; pname: VertexAttribInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetVertexAttribdv';
    
    static procedure GetVertexAttribfv(index: UInt32; pname: VertexAttribInfoType; [MarshalAs(UnmanagedType.LPArray)] &params: array of single);
    external 'opengl32.dll' name 'glGetVertexAttribfv';
    static procedure GetVertexAttribfv(index: UInt32; pname: VertexAttribInfoType; var &params: single);
    external 'opengl32.dll' name 'glGetVertexAttribfv';
    static procedure GetVertexAttribfv(index: UInt32; pname: VertexAttribInfoType; var &params: Vec4f);
    external 'opengl32.dll' name 'glGetVertexAttribfv';
    static procedure GetVertexAttribfv(index: UInt32; pname: VertexAttribInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetVertexAttribfv';
    
    static procedure GetVertexAttribiv(index: UInt32; pname: VertexAttribInfoType; var &params: BufferName);
    external 'opengl32.dll' name 'glGetVertexAttribiv';
    static procedure GetVertexAttribiv(index: UInt32; pname: VertexAttribInfoType; var &params: DataType);
    external 'opengl32.dll' name 'glGetVertexAttribiv';
    static procedure GetVertexAttribiv(index: UInt32; pname: VertexAttribInfoType; [MarshalAs(UnmanagedType.LPArray)] &params: array of Int32);
    external 'opengl32.dll' name 'glGetVertexAttribiv';
    static procedure GetVertexAttribiv(index: UInt32; pname: VertexAttribInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetVertexAttribiv';
    static procedure GetVertexAttribiv(index: UInt32; pname: VertexAttribInfoType; var &params: Vec4i);
    external 'opengl32.dll' name 'glGetVertexAttribiv';
    static procedure GetVertexAttribiv(index: UInt32; pname: VertexAttribInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetVertexAttribiv';
    
    static procedure GetVertexAttribIiv(index: UInt32; pname: VertexAttribInfoType; var &params: BufferName);
    external 'opengl32.dll' name 'glGetVertexAttribIiv';
    static procedure GetVertexAttribIiv(index: UInt32; pname: VertexAttribInfoType; var &params: DataType);
    external 'opengl32.dll' name 'glGetVertexAttribIiv';
    static procedure GetVertexAttribIiv(index: UInt32; pname: VertexAttribInfoType; [MarshalAs(UnmanagedType.LPArray)] &params: array of Int32);
    external 'opengl32.dll' name 'glGetVertexAttribIiv';
    static procedure GetVertexAttribIiv(index: UInt32; pname: VertexAttribInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetVertexAttribIiv';
    static procedure GetVertexAttribIiv(index: UInt32; pname: VertexAttribInfoType; var &params: Vec4i);
    external 'opengl32.dll' name 'glGetVertexAttribIiv';
    static procedure GetVertexAttribIiv(index: UInt32; pname: VertexAttribInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetVertexAttribIiv';
    
    static procedure GetVertexAttribIuiv(index: UInt32; pname: VertexAttribInfoType; var &params: DataType);
    external 'opengl32.dll' name 'glGetVertexAttribIuiv';
    static procedure GetVertexAttribIuiv(index: UInt32; pname: VertexAttribInfoType; [MarshalAs(UnmanagedType.LPArray)] &params: array of UInt32);
    external 'opengl32.dll' name 'glGetVertexAttribIuiv';
    static procedure GetVertexAttribIuiv(index: UInt32; pname: VertexAttribInfoType; var &params: UInt32);
    external 'opengl32.dll' name 'glGetVertexAttribIuiv';
    static procedure GetVertexAttribIuiv(index: UInt32; pname: VertexAttribInfoType; var &params: Vec4ui);
    external 'opengl32.dll' name 'glGetVertexAttribIuiv';
    static procedure GetVertexAttribIuiv(index: UInt32; pname: VertexAttribInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetVertexAttribIuiv';
    
    static procedure GetVertexAttribLdv(index: UInt32; pname: VertexAttribInfoType; [MarshalAs(UnmanagedType.LPArray)] &params: array of double);
    external 'opengl32.dll' name 'glGetVertexAttribLdv';
    static procedure GetVertexAttribLdv(index: UInt32; pname: VertexAttribInfoType; var &params: double);
    external 'opengl32.dll' name 'glGetVertexAttribLdv';
    static procedure GetVertexAttribLdv(index: UInt32; pname: VertexAttribInfoType; var &params: Vec4d);
    external 'opengl32.dll' name 'glGetVertexAttribLdv';
    static procedure GetVertexAttribLdv(index: UInt32; pname: VertexAttribInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetVertexAttribLdv';
    
    static procedure GetVertexAttribPointerv(index: UInt32; pname: UInt32; [MarshalAs(UnmanagedType.LPArray)] _pointer: array of IntPtr);
    external 'opengl32.dll' name 'glGetVertexAttribPointerv';
    static procedure GetVertexAttribPointerv(index: UInt32; pname: UInt32; var _pointer: IntPtr);
    external 'opengl32.dll' name 'glGetVertexAttribPointerv';
    static procedure GetVertexAttribPointerv(index: UInt32; pname: UInt32; var _pointer: pointer);
    external 'opengl32.dll' name 'glGetVertexAttribPointerv';
    static procedure GetVertexAttribPointerv(index: UInt32; pname: UInt32; _pointer: ^IntPtr);
    external 'opengl32.dll' name 'glGetVertexAttribPointerv';
    
    {$endregion 10.5 - Vertex Array and Vertex Array Object Queries}
    
    {$region 10.9 - Conditional Rendering}
    
    static procedure BeginConditionalRender(id: UInt32; mode: ConditionalRenderingMode);
    external 'opengl32.dll' name 'glBeginConditionalRender';
    
    static procedure EndConditionalRender;
    external 'opengl32.dll' name 'glEndConditionalRender';
    
    {$endregion 10.9 - Conditional Rendering}
    
    {$endregion 10.0 - Vertex Specification and Drawing Commands}
    
    {$region 11.0 - Programmable Vertex Processing}
    
    {$region 11.1 - Vertex Shaders}
    
    // 11.1.1
    
    static procedure BindAttribLocation(&program: ProgramName; index: UInt32; [MarshalAs(UnmanagedType.LPStr)] name: string);
    external 'opengl32.dll' name 'glBindAttribLocation';
    static procedure BindAttribLocation(&program: ProgramName; index: UInt32; name: IntPtr);
    external 'opengl32.dll' name 'glBindAttribLocation';
    
    static procedure GetActiveAttrib(&program: ProgramName; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: ProgramVarType; [MarshalAs(UnmanagedType.LPStr)] name: string);
    external 'opengl32.dll' name 'glGetActiveAttrib';
    static procedure GetActiveAttrib(&program: ProgramName; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: ProgramVarType; name: IntPtr);
    external 'opengl32.dll' name 'glGetActiveAttrib';
    static procedure GetActiveAttrib(&program: ProgramName; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: pointer; [MarshalAs(UnmanagedType.LPStr)] name: string);
    external 'opengl32.dll' name 'glGetActiveAttrib';
    static procedure GetActiveAttrib(&program: ProgramName; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: pointer; name: IntPtr);
    external 'opengl32.dll' name 'glGetActiveAttrib';
    static procedure GetActiveAttrib(&program: ProgramName; index: UInt32; bufSize: Int32; length: pointer; size: pointer; var &type: ProgramVarType; [MarshalAs(UnmanagedType.LPStr)] name: string);
    external 'opengl32.dll' name 'glGetActiveAttrib';
    static procedure GetActiveAttrib(&program: ProgramName; index: UInt32; bufSize: Int32; length: pointer; size: pointer; var &type: ProgramVarType; name: IntPtr);
    external 'opengl32.dll' name 'glGetActiveAttrib';
    static procedure GetActiveAttrib(&program: ProgramName; index: UInt32; bufSize: Int32; length: pointer; size: pointer; &type: pointer; [MarshalAs(UnmanagedType.LPStr)] name: string);
    external 'opengl32.dll' name 'glGetActiveAttrib';
    static procedure GetActiveAttrib(&program: ProgramName; index: UInt32; bufSize: Int32; length: pointer; size: pointer; &type: pointer; name: IntPtr);
    external 'opengl32.dll' name 'glGetActiveAttrib';
    
    static function GetAttribLocation(&program: ProgramName; [MarshalAs(UnmanagedType.LPStr)] name: string): Int32;
    external 'opengl32.dll' name 'glGetAttribLocation';
    static function GetAttribLocation(&program: ProgramName; name: IntPtr): Int32;
    external 'opengl32.dll' name 'glGetAttribLocation';
    
    //11.1.2
    
    //11.1.2.1
    
    static procedure TransformFeedbackVaryings(&program: ProgramName; count: Int32; [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.LPStr)] varyings: array of string; bufferMode: TransformFeedbackBufferMode);
    external 'opengl32.dll' name 'glTransformFeedbackVaryings';
    static procedure TransformFeedbackVaryings(&program: ProgramName; count: Int32; [MarshalAs(UnmanagedType.SysInt, ArraySubType = UnmanagedType.LPStr)] var varyings: string; bufferMode: TransformFeedbackBufferMode);
    external 'opengl32.dll' name 'glTransformFeedbackVaryings';
    static procedure TransformFeedbackVaryings(&program: ProgramName; count: Int32; var varyings: IntPtr; bufferMode: TransformFeedbackBufferMode);
    external 'opengl32.dll' name 'glTransformFeedbackVaryings';
    static procedure TransformFeedbackVaryings(&program: ProgramName; count: Int32; varyings: pointer; bufferMode: TransformFeedbackBufferMode);
    external 'opengl32.dll' name 'glTransformFeedbackVaryings';
    
    static procedure GetTransformFeedbackVarying(&program: ProgramName; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: ProgramVarType; [MarshalAs(UnmanagedType.LPStr)] name: string);
    external 'opengl32.dll' name 'glGetTransformFeedbackVarying';
    static procedure GetTransformFeedbackVarying(&program: ProgramName; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: ProgramVarType; name: IntPtr);
    external 'opengl32.dll' name 'glGetTransformFeedbackVarying';
    static procedure GetTransformFeedbackVarying(&program: ProgramName; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: pointer; [MarshalAs(UnmanagedType.LPStr)] name: string);
    external 'opengl32.dll' name 'glGetTransformFeedbackVarying';
    static procedure GetTransformFeedbackVarying(&program: ProgramName; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: pointer; name: IntPtr);
    external 'opengl32.dll' name 'glGetTransformFeedbackVarying';
    static procedure GetTransformFeedbackVarying(&program: ProgramName; index: UInt32; bufSize: Int32; length: pointer; size: pointer; var &type: ProgramVarType; [MarshalAs(UnmanagedType.LPStr)] name: string);
    external 'opengl32.dll' name 'glGetTransformFeedbackVarying';
    static procedure GetTransformFeedbackVarying(&program: ProgramName; index: UInt32; bufSize: Int32; length: pointer; size: pointer; var &type: ProgramVarType; name: IntPtr);
    external 'opengl32.dll' name 'glGetTransformFeedbackVarying';
    static procedure GetTransformFeedbackVarying(&program: ProgramName; index: UInt32; bufSize: Int32; length: pointer; size: pointer; &type: pointer; [MarshalAs(UnmanagedType.LPStr)] name: string);
    external 'opengl32.dll' name 'glGetTransformFeedbackVarying';
    static procedure GetTransformFeedbackVarying(&program: ProgramName; index: UInt32; bufSize: Int32; length: pointer; size: pointer; &type: pointer; name: IntPtr);
    external 'opengl32.dll' name 'glGetTransformFeedbackVarying';
    
    //11.1.3
    
    //11.1.3.11
    
    static procedure ValidateProgram(&program: ProgramName);
    external 'opengl32.dll' name 'glValidateProgram';
    
    static procedure ValidateProgramPipeline(pipeline: ProgramPipelineName);
    external 'opengl32.dll' name 'glValidateProgramPipeline';
    
    {$endregion 11.1 - Vertex Shaders}
    
    {$region 11.2 - Tessellation}
    
    // 11.2.2
    
    static procedure PatchParameterfv(pname: PatchMode; var values: Vec2f);
    external 'opengl32.dll' name 'glPatchParameterfv';
    static procedure PatchParameterfv(pname: PatchMode; var values: Vec4f);
    external 'opengl32.dll' name 'glPatchParameterfv';
    static procedure PatchParameterfv(pname: PatchMode; [MarshalAs(UnmanagedType.LPArray)] values: array of single);
    external 'opengl32.dll' name 'glPatchParameterfv';
    static procedure PatchParameterfv(pname: PatchMode; var values: single);
    external 'opengl32.dll' name 'glPatchParameterfv';
    static procedure PatchParameterfv(pname: PatchMode; values: pointer);
    external 'opengl32.dll' name 'glPatchParameterfv';
    
    {$endregion 11.2 - Tessellation}
    
    {$endregion 11.0 - Programmable Vertex Processing}
    
    {$region 13.0 - Fixed-Function Vertex Post-Processing}
    
    {$region 13.3 - Transform Feedback}
    
    // 13.3.1
    
    static procedure GenTransformFeedbacks(n: Int32; [MarshalAs(UnmanagedType.LPArray)] ids: array of TransformFeedbackName);
    external 'opengl32.dll' name 'glGenTransformFeedbacks';
    static procedure GenTransformFeedbacks(n: Int32; var ids: TransformFeedbackName);
    external 'opengl32.dll' name 'glGenTransformFeedbacks';
    static procedure GenTransformFeedbacks(n: Int32; ids: pointer);
    external 'opengl32.dll' name 'glGenTransformFeedbacks';
    
    static procedure DeleteTransformFeedbacks(n: Int32; [MarshalAs(UnmanagedType.LPArray)] ids: array of TransformFeedbackName);
    external 'opengl32.dll' name 'glDeleteTransformFeedbacks';
    static procedure DeleteTransformFeedbacks(n: Int32; var ids: TransformFeedbackName);
    external 'opengl32.dll' name 'glDeleteTransformFeedbacks';
    static procedure DeleteTransformFeedbacks(n: Int32; ids: pointer);
    external 'opengl32.dll' name 'glDeleteTransformFeedbacks';
    
    static function IsTransformFeedback(id: TransformFeedbackName): boolean;
    external 'opengl32.dll' name 'glIsTransformFeedback';
    
    static procedure BindTransformFeedback(target: TransformFeedbackBindTarget; id: TransformFeedbackName);
    external 'opengl32.dll' name 'glBindTransformFeedback';
    
    static procedure CreateTransformFeedbacks(n: Int32; [MarshalAs(UnmanagedType.LPArray)] ids: array of TransformFeedbackName);
    external 'opengl32.dll' name 'glCreateTransformFeedbacks';
    static procedure CreateTransformFeedbacks(n: Int32; var ids: TransformFeedbackName);
    external 'opengl32.dll' name 'glCreateTransformFeedbacks';
    static procedure CreateTransformFeedbacks(n: Int32; ids: pointer);
    external 'opengl32.dll' name 'glCreateTransformFeedbacks';
    
    // 13.3.2
    
    static procedure BeginTransformFeedback(primitiveMode: PrimitiveType);
    external 'opengl32.dll' name 'glBeginTransformFeedback';
    
    static procedure EndTransformFeedback;
    external 'opengl32.dll' name 'glEndTransformFeedback';
    
    static procedure PauseTransformFeedback;
    external 'opengl32.dll' name 'glPauseTransformFeedback';
    
    static procedure ResumeTransformFeedback;
    external 'opengl32.dll' name 'glResumeTransformFeedback';
    
    static procedure TransformFeedbackBufferRange(xfb: TransformFeedbackName; index: UInt32; buffer: BufferName; offset: IntPtr; size: UIntPtr);
    external 'opengl32.dll' name 'glTransformFeedbackBufferRange';
    
    static procedure TransformFeedbackBufferBase(xfb: TransformFeedbackName; index: UInt32; buffer: BufferName);
    external 'opengl32.dll' name 'glTransformFeedbackBufferBase';
    
    // 13.3.3
    
    static procedure DrawTransformFeedback(mode: PrimitiveType; id: TransformFeedbackName);
    external 'opengl32.dll' name 'glDrawTransformFeedback';
    
    static procedure DrawTransformFeedbackInstanced(mode: PrimitiveType; id: TransformFeedbackName; instancecount: Int32);
    external 'opengl32.dll' name 'glDrawTransformFeedbackInstanced';
    
    static procedure DrawTransformFeedbackStream(mode: PrimitiveType; id: TransformFeedbackName; stream: UInt32);
    external 'opengl32.dll' name 'glDrawTransformFeedbackStream';
    
    static procedure DrawTransformFeedbackStreamInstanced(mode: PrimitiveType; id: TransformFeedbackName; stream: UInt32; instancecount: Int32);
    external 'opengl32.dll' name 'glDrawTransformFeedbackStreamInstanced';
    
    {$endregion 13.3 - Transform Feedback}
    
    {$region 13.6 - Flatshading}
    
    static procedure ProvokingVertex(mode: VertexProvokingMode);
    external 'opengl32.dll' name 'glProvokingVertex';
    
    {$endregion 13.6 - Flatshading}
    
    {$region 13.7 - Primitive Clipping}
    
    static procedure ClipControl(origin: ClipOriginMode; depth: ClipDepthMode);
    external 'opengl32.dll' name 'glClipControl';
    
    {$endregion 13.7 - Primitive Clipping}
    
    {$region 13.8 - Coordinate Transformations}
    
    // 13.8.1
    
    static procedure DepthRangeArrayv(first: UInt32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] v: array of Vec2d);
    external 'opengl32.dll' name 'glDepthRangeArrayv';
    static procedure DepthRangeArrayv(first: UInt32; count: Int32; var v: Vec2d);
    external 'opengl32.dll' name 'glDepthRangeArrayv';
    static procedure DepthRangeArrayv(first: UInt32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] v: array of double);
    external 'opengl32.dll' name 'glDepthRangeArrayv';
    static procedure DepthRangeArrayv(first: UInt32; count: Int32; var v: double);
    external 'opengl32.dll' name 'glDepthRangeArrayv';
    static procedure DepthRangeArrayv(first: UInt32; count: Int32; v: pointer);
    external 'opengl32.dll' name 'glDepthRangeArrayv';
    
    static procedure DepthRangeIndexed(index: UInt32; nearVal: double; farVal: double);
    external 'opengl32.dll' name 'glDepthRangeIndexed';
    
    static procedure DepthRange(nearVal: double; farVal: double);
    external 'opengl32.dll' name 'glDepthRange';
    
    static procedure DepthRangef(nearVal: single; farVal: single);
    external 'opengl32.dll' name 'glDepthRangef';
    
    static procedure ViewportArrayv(first: UInt32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] v: array of Vec4f);
    external 'opengl32.dll' name 'glViewportArrayv';
    static procedure ViewportArrayv(first: UInt32; count: Int32; var v: Vec4f);
    external 'opengl32.dll' name 'glViewportArrayv';
    static procedure ViewportArrayv(first: UInt32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] v: array of single);
    external 'opengl32.dll' name 'glViewportArrayv';
    static procedure ViewportArrayv(first: UInt32; count: Int32; var v: single);
    external 'opengl32.dll' name 'glViewportArrayv';
    static procedure ViewportArrayv(first: UInt32; count: Int32; v: pointer);
    external 'opengl32.dll' name 'glViewportArrayv';
    
    static procedure ViewportIndexedf(index: UInt32; x: single; y: single; w: single; h: single);
    external 'opengl32.dll' name 'glViewportIndexedf';
    
    static procedure ViewportIndexedfv(index: UInt32; var v: Vec4f);
    external 'opengl32.dll' name 'glViewportIndexedfv';
    static procedure ViewportIndexedfv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of single);
    external 'opengl32.dll' name 'glViewportIndexedfv';
    static procedure ViewportIndexedfv(index: UInt32; var v: single);
    external 'opengl32.dll' name 'glViewportIndexedfv';
    static procedure ViewportIndexedfv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glViewportIndexedfv';
    
    static procedure Viewport(x: Int32; y: Int32; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glViewport';
    
    {$endregion 13.8 - Coordinate Transformations}
    
    {$endregion 13.0 - Fixed-Function Vertex Post-Processing}
    
    {$region 14.0 - Fixed-Function Primitive Assembly and Rasterization}
    
    {$region 14.3 - Antialiasing}
    
    // 14.3.1
    
    static procedure GetMultisamplefv(pname: MultisampleInfoType; index: UInt32; var val: Vec2f);
    external 'opengl32.dll' name 'glGetMultisamplefv';
    static procedure GetMultisamplefv(pname: MultisampleInfoType; index: UInt32; [MarshalAs(UnmanagedType.LPArray)] val: array of single);
    external 'opengl32.dll' name 'glGetMultisamplefv';
    static procedure GetMultisamplefv(pname: MultisampleInfoType; index: UInt32; var val: single);
    external 'opengl32.dll' name 'glGetMultisamplefv';
    static procedure GetMultisamplefv(pname: MultisampleInfoType; index: UInt32; val: pointer);
    external 'opengl32.dll' name 'glGetMultisamplefv';
    
    // 14.3.1.1
    
    static procedure MinSampleShading(value: single);
    external 'opengl32.dll' name 'glMinSampleShading';
    
    {$endregion 14.3 - Antialiasing}
    
    {$region 14.4 - Points}
    
    static procedure PointSize(size: single);
    external 'opengl32.dll' name 'glPointSize';
    
    static procedure PointParameteri(pname: PointInfoType; param: Int32);
    external 'opengl32.dll' name 'glPointParameteri';
    static procedure PointParameteri(pname: PointInfoType; param: ClipOriginMode);
    external 'opengl32.dll' name 'glPointParameteri';
    
    static procedure PointParameterf(pname: PointInfoType; param: single);
    external 'opengl32.dll' name 'glPointParameterf';
    
    static procedure PointParameteriv(pname: PointInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glPointParameteriv';
    static procedure PointParameteriv(pname: PointInfoType; &params: pointer);
    external 'opengl32.dll' name 'glPointParameteriv';
    
    static procedure PointParameterfv(pname: PointInfoType; var &params: single);
    external 'opengl32.dll' name 'glPointParameterfv';
    static procedure PointParameterfv(pname: PointInfoType; &params: pointer);
    external 'opengl32.dll' name 'glPointParameterfv';
    
    {$endregion 14.4 - Points}
    
    {$region 14.5 - Line Segments}
    
    static procedure LineWidth(width: single);
    external 'opengl32.dll' name 'glLineWidth';
    
    {$endregion 14.5 - Line Segments}
    
    {$region 14.6 - Polygons}
    
    // 14.6.1
    
    static procedure FrontFace(mode: FrontFaceDirection);
    external 'opengl32.dll' name 'glFrontFace';
    
    static procedure CullFace(mode: PolygonFace);
    external 'opengl32.dll' name 'glCullFace';
    
    // 14.6.4
    
    static procedure PolygonMode(face: PolygonFace; mode: PolygonRasterizationMode);
    external 'opengl32.dll' name 'glPolygonMode';
    
    // 14.6.5
    
    static procedure PolygonOffsetClamp(factor: single; units: single; clamp: single);
    external 'opengl32.dll' name 'glPolygonOffsetClamp';
    
    static procedure PolygonOffset(factor: single; units: single);
    external 'opengl32.dll' name 'glPolygonOffset';
    
    {$endregion 14.6 - Polygons}
    
    {$region 14.9 - Early Per-Fragment Tests}
    
    // 14.9.2
    
    static procedure ScissorArrayv(first: UInt32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] v: array of Vec4i);
    external 'opengl32.dll' name 'glScissorArrayv';
    static procedure ScissorArrayv(first: UInt32; count: Int32; var v: Vec4i);
    external 'opengl32.dll' name 'glScissorArrayv';
    static procedure ScissorArrayv(first: UInt32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] v: array of Int32);
    external 'opengl32.dll' name 'glScissorArrayv';
    static procedure ScissorArrayv(first: UInt32; count: Int32; var v: Int32);
    external 'opengl32.dll' name 'glScissorArrayv';
    static procedure ScissorArrayv(first: UInt32; count: Int32; v: pointer);
    external 'opengl32.dll' name 'glScissorArrayv';
    
    static procedure ScissorIndexed(index: UInt32; left: Int32; bottom: Int32; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glScissorIndexed';
    
    static procedure ScissorIndexedv(index: UInt32; var v: Vec4i);
    external 'opengl32.dll' name 'glScissorIndexedv';
    static procedure ScissorIndexedv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of Int32);
    external 'opengl32.dll' name 'glScissorIndexedv';
    static procedure ScissorIndexedv(index: UInt32; var v: Int32);
    external 'opengl32.dll' name 'glScissorIndexedv';
    static procedure ScissorIndexedv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glScissorIndexedv';
    
    static procedure Scissor(x: Int32; y: Int32; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glScissor';
    
    // 14.9.3
    
    static procedure SampleCoverage(value: single; invert: boolean);
    external 'opengl32.dll' name 'glSampleCoverage';
    
    static procedure SampleMaski(maskNumber: UInt32; mask: UInt32);
    external 'opengl32.dll' name 'glSampleMaski';
    
    {$endregion 14.9 - Early Per-Fragment Tests}
    
    {$endregion 14.0 - Fixed-Function Primitive Assembly and Rasterization}
    
    {$region 15.0 - Programmable Fragment Processing}
    
    {$region 15.2 - Shader Execution}
    
    // 15.2.3
    
    static procedure BindFragDataLocationIndexed(&program: ProgramName; colorNumber: UInt32; index: UInt32; [MarshalAs(UnmanagedType.LPStr)] name: string);
    external 'opengl32.dll' name 'glBindFragDataLocationIndexed';
    static procedure BindFragDataLocationIndexed(&program: ProgramName; colorNumber: UInt32; index: UInt32; name: IntPtr);
    external 'opengl32.dll' name 'glBindFragDataLocationIndexed';
    
    static procedure BindFragDataLocation(&program: ProgramName; colorNumber: UInt32; [MarshalAs(UnmanagedType.LPStr)] name: string);
    external 'opengl32.dll' name 'glBindFragDataLocation';
    static procedure BindFragDataLocation(&program: ProgramName; colorNumber: UInt32; name: IntPtr);
    external 'opengl32.dll' name 'glBindFragDataLocation';
    
    static function GetFragDataLocation(&program: ProgramName; [MarshalAs(UnmanagedType.LPStr)] name: string): Int32;
    external 'opengl32.dll' name 'glGetFragDataLocation';
    static function GetFragDataLocation(&program: ProgramName; name: IntPtr): Int32;
    external 'opengl32.dll' name 'glGetFragDataLocation';
    
    static function GetFragDataIndex(&program: ProgramName; [MarshalAs(UnmanagedType.LPStr)] name: string): Int32;
    external 'opengl32.dll' name 'glGetFragDataIndex';
    static function GetFragDataIndex(&program: ProgramName; name: IntPtr): Int32;
    external 'opengl32.dll' name 'glGetFragDataIndex';
    
    {$endregion 15.2 - Shader Execution}
    
    {$endregion 15.0 - Programmable Fragment Processing}
    
    {$region 17.0 - Writing Fragments and Samples to the Framebuffer}
    
    {$region 17.3 - Per-Fragment Operations}
    
    // 17.3.3
    
    static procedure StencilFunc(func: ActivationFunc; ref: Int32; mask: UInt32);
    external 'opengl32.dll' name 'glStencilFunc';
    
    static procedure StencilFuncSeparate(face: PolygonFace; func: ActivationFunc; ref: Int32; mask: UInt32);
    external 'opengl32.dll' name 'glStencilFuncSeparate';
    
    static procedure StencilOp(fail: StencilOpFailMode; zfail: StencilOpFailMode; zpass: StencilOpFailMode);
    external 'opengl32.dll' name 'glStencilOp';
    
    static procedure StencilOpSeparate(face: PolygonFace; sfail: StencilOpFailMode; dpfail: StencilOpFailMode; dppass: StencilOpFailMode);
    external 'opengl32.dll' name 'glStencilOpSeparate';
    
    // 17.3.4
    
    static procedure DepthFunc(func: ActivationFunc);
    external 'opengl32.dll' name 'glDepthFunc';
    
    // 17.3.6
    
    static procedure Enablei(target: EnablableName; index: UInt32);
    external 'opengl32.dll' name 'glEnablei';
    
    static procedure Disablei(target: EnablableName; index: UInt32);
    external 'opengl32.dll' name 'glDisablei';
    
    // 17.3.6.1
    
    static procedure BlendEquation(mode: BlendEquationMode);
    external 'opengl32.dll' name 'glBlendEquation';
    
    static procedure BlendEquationSeparate(modeRGB: BlendEquationMode; modeAlpha: BlendEquationMode);
    external 'opengl32.dll' name 'glBlendEquationSeparate';
    
    static procedure BlendEquationi(buf: UInt32; mode: BlendEquationMode);
    external 'opengl32.dll' name 'glBlendEquationi';
    
    static procedure BlendEquationSeparatei(buf: UInt32; modeRGB: BlendEquationMode; modeAlpha: BlendEquationMode);
    external 'opengl32.dll' name 'glBlendEquationSeparatei';
    
    // 17.3.6.2
    
    static procedure BlendFunc(sfactor: BlendFuncMode; dfactor: BlendFuncMode);
    external 'opengl32.dll' name 'glBlendFunc';
    
    static procedure BlendFuncSeparate(sfactorRGB: BlendFuncMode; dfactorRGB: BlendFuncMode; sfactorAlpha: BlendFuncMode; dfactorAlpha: BlendFuncMode);
    external 'opengl32.dll' name 'glBlendFuncSeparate';
    
    static procedure BlendFunci(buf: UInt32; src: BlendFuncMode; dst: BlendFuncMode);
    external 'opengl32.dll' name 'glBlendFunci';
    
    static procedure BlendFuncSeparatei(buf: UInt32; srcRGB: BlendFuncMode; dstRGB: BlendFuncMode; srcAlpha: BlendFuncMode; dstAlpha: BlendFuncMode);
    external 'opengl32.dll' name 'glBlendFuncSeparatei';
    
    // 17.3.6.5
    
    static procedure BlendColor(red: single; green: single; blue: single; alpha: single);
    external 'opengl32.dll' name 'glBlendColor';
    
    // 17.3.9
    
    static procedure LogicOp(opcode: LogicOpCode);
    external 'opengl32.dll' name 'glLogicOp';
    
    {$endregion 17.3 - Per-Fragment Operations}
    
    {$region 17.4 - Whole Framebuffer Operations}
    
    // 17.4.1
    
    static procedure DrawBuffer(buf: FrameBufferPart);
    external 'opengl32.dll' name 'glDrawBuffer';
    
    static procedure NamedFramebufferDrawBuffer(framebuffer: FramebufferName; buf: FrameBufferPart);
    external 'opengl32.dll' name 'glNamedFramebufferDrawBuffer';
    
    static procedure DrawBuffers(n: Int32; [MarshalAs(UnmanagedType.LPArray)] bufs: array of FrameBufferPart);
    external 'opengl32.dll' name 'glDrawBuffers';
    static procedure DrawBuffers(n: Int32; var bufs: FrameBufferPart);
    external 'opengl32.dll' name 'glDrawBuffers';
    static procedure DrawBuffers(n: Int32; bufs: pointer);
    external 'opengl32.dll' name 'glDrawBuffers';
    
    static procedure NamedFramebufferDrawBuffers(framebuffer: FramebufferName; n: Int32; [MarshalAs(UnmanagedType.LPArray)] bufs: array of FrameBufferPart);
    external 'opengl32.dll' name 'glNamedFramebufferDrawBuffers';
    static procedure NamedFramebufferDrawBuffers(framebuffer: FramebufferName; n: Int32; var bufs: FrameBufferPart);
    external 'opengl32.dll' name 'glNamedFramebufferDrawBuffers';
    static procedure NamedFramebufferDrawBuffers(framebuffer: FramebufferName; n: Int32; bufs: pointer);
    external 'opengl32.dll' name 'glNamedFramebufferDrawBuffers';
    
    // 17.4.2
    
    static procedure ColorMask(red: boolean; green: boolean; blue: boolean; alpha: boolean);
    external 'opengl32.dll' name 'glColorMask';
    
    static procedure ColorMaski(index: UInt32; r: boolean; g: boolean; b: boolean; a: boolean);
    external 'opengl32.dll' name 'glColorMaski';
    
    static procedure DepthMask(flag: boolean);
    external 'opengl32.dll' name 'glDepthMask';
    
    static procedure StencilMask(mask: UInt32);
    external 'opengl32.dll' name 'glStencilMask';
    
    static procedure StencilMaskSeparate(face: PolygonFace; mask: UInt32);
    external 'opengl32.dll' name 'glStencilMaskSeparate';
    
    // 17.4.3
    
    static procedure Clear(mask: BufferTypeFlags);
    external 'opengl32.dll' name 'glClear';
    
    static procedure ClearColor(red: single; green: single; blue: single; alpha: single);
    external 'opengl32.dll' name 'glClearColor';
    
    static procedure ClearDepth(depth: double);
    external 'opengl32.dll' name 'glClearDepth';
    
    static procedure ClearDepthf(depth: single);
    external 'opengl32.dll' name 'glClearDepthf';
    
    static procedure ClearStencil(s: Int32);
    external 'opengl32.dll' name 'glClearStencil';
    
    // 17.4.3.1
    
    static procedure ClearBufferiv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of Vec4i);
    external 'opengl32.dll' name 'glClearBufferiv';
    static procedure ClearBufferiv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; var value: Vec4i);
    external 'opengl32.dll' name 'glClearBufferiv';
    static procedure ClearBufferiv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of Int32);
    external 'opengl32.dll' name 'glClearBufferiv';
    static procedure ClearBufferiv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; var value: Int32);
    external 'opengl32.dll' name 'glClearBufferiv';
    static procedure ClearBufferiv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; value: pointer);
    external 'opengl32.dll' name 'glClearBufferiv';
    
    static procedure ClearBufferfv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of Vec4f);
    external 'opengl32.dll' name 'glClearBufferfv';
    static procedure ClearBufferfv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; var value: Vec4f);
    external 'opengl32.dll' name 'glClearBufferfv';
    static procedure ClearBufferfv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glClearBufferfv';
    static procedure ClearBufferfv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; var value: single);
    external 'opengl32.dll' name 'glClearBufferfv';
    static procedure ClearBufferfv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; value: pointer);
    external 'opengl32.dll' name 'glClearBufferfv';
    
    static procedure ClearBufferuiv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of Vec4ui);
    external 'opengl32.dll' name 'glClearBufferuiv';
    static procedure ClearBufferuiv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; var value: Vec4ui);
    external 'opengl32.dll' name 'glClearBufferuiv';
    static procedure ClearBufferuiv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of UInt32);
    external 'opengl32.dll' name 'glClearBufferuiv';
    static procedure ClearBufferuiv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; var value: UInt32);
    external 'opengl32.dll' name 'glClearBufferuiv';
    static procedure ClearBufferuiv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; value: pointer);
    external 'opengl32.dll' name 'glClearBufferuiv';
    
    static procedure ClearNamedFramebufferiv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of Vec4i);
    external 'opengl32.dll' name 'glClearNamedFramebufferiv';
    static procedure ClearNamedFramebufferiv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; var value: Vec4i);
    external 'opengl32.dll' name 'glClearNamedFramebufferiv';
    static procedure ClearNamedFramebufferiv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of Int32);
    external 'opengl32.dll' name 'glClearNamedFramebufferiv';
    static procedure ClearNamedFramebufferiv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; var value: Int32);
    external 'opengl32.dll' name 'glClearNamedFramebufferiv';
    static procedure ClearNamedFramebufferiv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; value: pointer);
    external 'opengl32.dll' name 'glClearNamedFramebufferiv';
    
    static procedure ClearNamedFramebufferfv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of Vec4f);
    external 'opengl32.dll' name 'glClearNamedFramebufferfv';
    static procedure ClearNamedFramebufferfv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; var value: Vec4f);
    external 'opengl32.dll' name 'glClearNamedFramebufferfv';
    static procedure ClearNamedFramebufferfv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glClearNamedFramebufferfv';
    static procedure ClearNamedFramebufferfv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; var value: single);
    external 'opengl32.dll' name 'glClearNamedFramebufferfv';
    static procedure ClearNamedFramebufferfv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; value: pointer);
    external 'opengl32.dll' name 'glClearNamedFramebufferfv';
    
    static procedure ClearNamedFramebufferuiv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of Vec4ui);
    external 'opengl32.dll' name 'glClearNamedFramebufferuiv';
    static procedure ClearNamedFramebufferuiv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; var value: Vec4ui);
    external 'opengl32.dll' name 'glClearNamedFramebufferuiv';
    static procedure ClearNamedFramebufferuiv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of UInt32);
    external 'opengl32.dll' name 'glClearNamedFramebufferuiv';
    static procedure ClearNamedFramebufferuiv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; var value: UInt32);
    external 'opengl32.dll' name 'glClearNamedFramebufferuiv';
    static procedure ClearNamedFramebufferuiv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; value: pointer);
    external 'opengl32.dll' name 'glClearNamedFramebufferuiv';
    
    static procedure ClearBufferfi(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; depth: single; stencil: Int32);
    external 'opengl32.dll' name 'glClearBufferfi';
    
    static procedure ClearNamedFramebufferfi(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; depth: single; stencil: Int32);
    external 'opengl32.dll' name 'glClearNamedFramebufferfi';
    
    // 17.4.4
    
    static procedure InvalidateSubFramebuffer(target: FramebufferBindTarget; numAttachments: Int32; [MarshalAs(UnmanagedType.LPArray)] attachments: array of FramebufferAttachmentPoint);
    external 'opengl32.dll' name 'glInvalidateSubFramebuffer';
    static procedure InvalidateSubFramebuffer(target: FramebufferBindTarget; numAttachments: Int32; var attachments: FramebufferAttachmentPoint);
    external 'opengl32.dll' name 'glInvalidateSubFramebuffer';
    static procedure InvalidateSubFramebuffer(target: FramebufferBindTarget; numAttachments: Int32; attachments: pointer);
    external 'opengl32.dll' name 'glInvalidateSubFramebuffer';
    
    static procedure InvalidateNamedFramebufferSubData(framebuffer: FramebufferName; numAttachments: Int32; [MarshalAs(UnmanagedType.LPArray)] attachments: array of FramebufferAttachmentPoint);
    external 'opengl32.dll' name 'glInvalidateNamedFramebufferSubData';
    static procedure InvalidateNamedFramebufferSubData(framebuffer: FramebufferName; numAttachments: Int32; var attachments: FramebufferAttachmentPoint);
    external 'opengl32.dll' name 'glInvalidateNamedFramebufferSubData';
    static procedure InvalidateNamedFramebufferSubData(framebuffer: FramebufferName; numAttachments: Int32; attachments: pointer);
    external 'opengl32.dll' name 'glInvalidateNamedFramebufferSubData';
    
    static procedure InvalidateFramebuffer(target: FramebufferBindTarget; numAttachments: Int32; [MarshalAs(UnmanagedType.LPArray)] attachments: array of FramebufferAttachmentPoint);
    external 'opengl32.dll' name 'glInvalidateFramebuffer';
    static procedure InvalidateFramebuffer(target: FramebufferBindTarget; numAttachments: Int32; var attachments: FramebufferAttachmentPoint);
    external 'opengl32.dll' name 'glInvalidateFramebuffer';
    static procedure InvalidateFramebuffer(target: FramebufferBindTarget; numAttachments: Int32; attachments: pointer);
    external 'opengl32.dll' name 'glInvalidateFramebuffer';
    
    static procedure InvalidateNamedFramebufferData(framebuffer: FramebufferName; numAttachments: Int32; [MarshalAs(UnmanagedType.LPArray)] attachments: array of FramebufferAttachmentPoint);
    external 'opengl32.dll' name 'glInvalidateNamedFramebufferData';
    static procedure InvalidateNamedFramebufferData(framebuffer: FramebufferName; numAttachments: Int32; var attachments: FramebufferAttachmentPoint);
    external 'opengl32.dll' name 'glInvalidateNamedFramebufferData';
    static procedure InvalidateNamedFramebufferData(framebuffer: FramebufferName; numAttachments: Int32; attachments: pointer);
    external 'opengl32.dll' name 'glInvalidateNamedFramebufferData';
    
    {$endregion 17.4 - Whole Framebuffer Operations}
    
    {$endregion 17.0 - Writing Fragments and Samples to the Framebuffer}
    
    {$region 18.0 - Reading and Copying Pixels}
    
    {$region 18.2 - Reading Pixels}
    
    // 18.2.1
    
    static procedure ReadBuffer(src: FramebufferAttachmentPoint);
    external 'opengl32.dll' name 'glReadBuffer';
    
    static procedure NamedFramebufferReadBuffer(framebuffer: FramebufferName; src: FramebufferAttachmentPoint);
    external 'opengl32.dll' name 'glNamedFramebufferReadBuffer';
    
    // 18.2.2
    
    static procedure ReadPixels(x: Int32; y: Int32; width: Int32; height: Int32; format: DataFormat; &type: DataType; pixels: IntPtr);
    external 'opengl32.dll' name 'glReadPixels';
    static procedure ReadPixels(x: Int32; y: Int32; width: Int32; height: Int32; format: DataFormat; &type: DataType; pixels: pointer);
    external 'opengl32.dll' name 'glReadPixels';
    
    static procedure ReadnPixels(x: Int32; y: Int32; width: Int32; height: Int32; format: DataFormat; &type: DataType; bufSize: Int32; data: IntPtr);
    external 'opengl32.dll' name 'glReadnPixels';
    static procedure ReadnPixels(x: Int32; y: Int32; width: Int32; height: Int32; format: DataFormat; &type: DataType; bufSize: Int32; data: pointer);
    external 'opengl32.dll' name 'glReadnPixels';
    
    // 18.2.8
    
    static procedure ClampColor(target: ColorClampTarget; clamp: UInt32);
    external 'opengl32.dll' name 'glClampColor';
    
    {$endregion 18.2 - Reading Pixels}
    
    {$region 18.3 - Copying Pixels}
    
    // 18.3.1
    
    static procedure BlitFramebuffer(srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: BufferTypeFlags; filter: PixelMagFilterMode);
    external 'opengl32.dll' name 'glBlitFramebuffer';
    
    static procedure BlitNamedFramebuffer(readFramebuffer: FramebufferName; drawFramebuffer: FramebufferName; srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: BufferTypeFlags; filter: PixelMagFilterMode);
    external 'opengl32.dll' name 'glBlitNamedFramebuffer';
    
    // 18.3.2
    
    // BufferBindType автоматически конвертируется в CopyableImageType
    static procedure CopyImageSubData(srcName: UInt32; srcTarget: CopyableImageType; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: CopyableImageType; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32);
    external 'opengl32.dll' name 'glCopyImageSubData';
    
    {$endregion 18.3 - Copying Pixels}
    
    {$endregion 18.0 - Reading and Copying Pixels}
    
    {$region 19.0 - Compute Shaders}
    
    static procedure DispatchCompute(num_groups_x: UInt32; num_groups_y: UInt32; num_groups_z: UInt32);
    external 'opengl32.dll' name 'glDispatchCompute';
    
    static procedure DispatchComputeIndirect(indirect: IntPtr);
    external 'opengl32.dll' name 'glDispatchComputeIndirect';
    
    {$endregion 19.0 - Compute Shaders}
    
    {$region 20.0 - Debug Output}
    
    {$region 20.2 - Debug Message Callback}
    
    static procedure DebugMessageCallback(callback: GLDEBUGPROC; userParam: IntPtr);
    external 'opengl32.dll' name 'glDebugMessageCallback';
    static procedure DebugMessageCallback(callback: GLDEBUGPROC; userParam: pointer);
    external 'opengl32.dll' name 'glDebugMessageCallback';
    
    {$endregion 20.2 - Debug Message Callback}
    
    {$region 20.4 - Controlling Debug Messages}
    
    static procedure DebugMessageControl(source: DebugSourceType; &type: DebugMessageType; severity: DebugSeverityLevel; count: Int32; [MarshalAs(UnmanagedType.LPArray)] ids: array of UInt32; enabled: boolean);
    external 'opengl32.dll' name 'glDebugMessageControl';
    static procedure DebugMessageControl(source: DebugSourceType; &type: DebugMessageType; severity: DebugSeverityLevel; count: Int32; var ids: UInt32; enabled: boolean);
    external 'opengl32.dll' name 'glDebugMessageControl';
    static procedure DebugMessageControl(source: DebugSourceType; &type: DebugMessageType; severity: DebugSeverityLevel; count: Int32; ids: IntPtr; enabled: boolean);
    external 'opengl32.dll' name 'glDebugMessageControl';
    
    {$endregion 20.4 - Controlling Debug Messages}
    
    {$region 20.5 - Externally Generated Messages}
    
    static procedure DebugMessageInsert(source: DebugSourceType; &type: DebugMessageType; id: UInt32; severity: DebugSeverityLevel; length: Int32; [MarshalAs(UnmanagedType.LPStr)] buf: string);
    external 'opengl32.dll' name 'glDebugMessageInsert';
    static procedure DebugMessageInsert(source: DebugSourceType; &type: DebugMessageType; id: UInt32; severity: DebugSeverityLevel; length: Int32; buf: IntPtr);
    external 'opengl32.dll' name 'glDebugMessageInsert';
    
    {$endregion 20.5 - Externally Generated Messages}
    
    {$region 20.6 - Debug Groups}
    
    static procedure PushDebugGroup(source: DebugSourceType; id: UInt32; length: Int32; [MarshalAs(UnmanagedType.LPStr)] message: string);
    external 'opengl32.dll' name 'glPushDebugGroup';
    static procedure PushDebugGroup(source: DebugSourceType; id: UInt32; length: Int32; message: IntPtr);
    external 'opengl32.dll' name 'glPushDebugGroup';
    
    static procedure PopDebugGroup;
    external 'opengl32.dll' name 'glPopDebugGroup';
    
    {$endregion 20.6 - Debug Groups}
    
    {$region 20.7 - Debug Labels}
    
    static procedure ObjectLabel(identifier: ObjectType; name: UInt32; length: Int32; [MarshalAs(UnmanagedType.LPStr)] &label: string);
    external 'opengl32.dll' name 'glObjectLabel';
    static procedure ObjectLabel(identifier: ObjectType; name: UInt32; length: Int32; &label: IntPtr);
    external 'opengl32.dll' name 'glObjectLabel';
    
    static procedure ObjectPtrLabel(ptr: IntPtr; length: Int32; [MarshalAs(UnmanagedType.LPStr)] &label: string);
    external 'opengl32.dll' name 'glObjectPtrLabel';
    static procedure ObjectPtrLabel(ptr: IntPtr; length: Int32; &label: IntPtr);
    external 'opengl32.dll' name 'glObjectPtrLabel';
    static procedure ObjectPtrLabel(ptr: pointer; length: Int32; [MarshalAs(UnmanagedType.LPStr)] &label: string);
    external 'opengl32.dll' name 'glObjectPtrLabel';
    static procedure ObjectPtrLabel(ptr: pointer; length: Int32; &label: IntPtr);
    external 'opengl32.dll' name 'glObjectPtrLabel';
    
    {$endregion 20.7 - Debug Labels}
    
    {$region 20.9 - Debug Output Queries}
    
    // ВНИМАНИЕ! messageLog является суммой count нуль-терминированных строк, то есть символ 0 будет после каждого сообщения. Обычные методы перевода тут не будут работать, надо ручками
    static function GetDebugMessageLog(count: UInt32; bufSize: Int32; [MarshalAs(UnmanagedType.LPArray)] sources: array of DebugSourceType; [MarshalAs(UnmanagedType.LPArray)] types: array of DebugMessageType; [MarshalAs(UnmanagedType.LPArray)] ids: array of UInt32; [MarshalAs(UnmanagedType.LPArray)] severities: array of DebugSeverityLevel; [MarshalAs(UnmanagedType.LPArray)] lengths: array of Int32; [MarshalAs(UnmanagedType.HString)] &messageLog: string): UInt32;
    external 'opengl32.dll' name 'glGetDebugMessageLog';
    static function GetDebugMessageLog(count: UInt32; bufSize: Int32; [MarshalAs(UnmanagedType.LPArray)] sources: array of DebugSourceType; [MarshalAs(UnmanagedType.LPArray)] types: array of DebugMessageType; [MarshalAs(UnmanagedType.LPArray)] ids: array of UInt32; [MarshalAs(UnmanagedType.LPArray)] severities: array of DebugSeverityLevel; [MarshalAs(UnmanagedType.LPArray)] lengths: array of Int32; messageLog: IntPtr): UInt32;
    external 'opengl32.dll' name 'glGetDebugMessageLog';
    static function GetDebugMessageLog(count: UInt32; bufSize: Int32; var sources: DebugSourceType; var types: DebugMessageType; var ids: UInt32; var severities: DebugSeverityLevel; var lengths: Int32; [MarshalAs(UnmanagedType.HString)] &messageLog: string): UInt32;
    external 'opengl32.dll' name 'glGetDebugMessageLog';
    static function GetDebugMessageLog(count: UInt32; bufSize: Int32; var sources: DebugSourceType; var types: DebugMessageType; var ids: UInt32; var severities: DebugSeverityLevel; var lengths: Int32; messageLog: IntPtr): UInt32;
    external 'opengl32.dll' name 'glGetDebugMessageLog';
    static function GetDebugMessageLog(count: UInt32; bufSize: Int32; sources: IntPtr; types: IntPtr; ids: IntPtr; severities: IntPtr; lengths: IntPtr; [MarshalAs(UnmanagedType.HString)] &messageLog: string): UInt32;
    external 'opengl32.dll' name 'glGetDebugMessageLog';
    static function GetDebugMessageLog(count: UInt32; bufSize: Int32; sources: IntPtr; types: IntPtr; ids: IntPtr; severities: IntPtr; lengths: IntPtr; messageLog: IntPtr): UInt32;
    external 'opengl32.dll' name 'glGetDebugMessageLog';
    
    static procedure GetObjectLabel(identifier: ObjectType; name: UInt32; bufSize: Int32; var length: Int32; [MarshalAs(UnmanagedType.LPStr)] &label: string);
    external 'opengl32.dll' name 'glGetObjectLabel';
    static procedure GetObjectLabel(identifier: ObjectType; name: UInt32; bufSize: Int32; var length: Int32; &label: IntPtr);
    external 'opengl32.dll' name 'glGetObjectLabel';
    static procedure GetObjectLabel(identifier: ObjectType; name: UInt32; bufSize: Int32; length: pointer; [MarshalAs(UnmanagedType.LPStr)] &label: string);
    external 'opengl32.dll' name 'glGetObjectLabel';
    static procedure GetObjectLabel(identifier: ObjectType; name: UInt32; bufSize: Int32; length: pointer; &label: IntPtr);
    external 'opengl32.dll' name 'glGetObjectLabel';
    
    static procedure GetObjectPtrLabel(ptr: pointer; bufSize: Int32; var length: Int32; [MarshalAs(UnmanagedType.LPStr)] &label: string);
    external 'opengl32.dll' name 'glGetObjectPtrLabel';
    static procedure GetObjectPtrLabel(ptr: pointer; bufSize: Int32; var length: Int32; &label: IntPtr);
    external 'opengl32.dll' name 'glGetObjectPtrLabel';
    static procedure GetObjectPtrLabel(ptr: pointer; bufSize: Int32; length: pointer; [MarshalAs(UnmanagedType.LPStr)] &label: string);
    external 'opengl32.dll' name 'glGetObjectPtrLabel';
    static procedure GetObjectPtrLabel(ptr: pointer; bufSize: Int32; length: pointer; &label: IntPtr);
    external 'opengl32.dll' name 'glGetObjectPtrLabel';
    
    {$endregion 20.9 - Debug Output Queries}
    
    {$endregion 20.0 - Debug Output}
    
    {$region 21.0 - Special Functions}
    
    {$region 21.5 - Hints}
    
    static procedure Hint(target: HintType; mode: HintValue);
    external 'opengl32.dll' name 'glHint';
    
    {$endregion 21.5 - Hints}
    
    {$endregion 21.0 - Special Functions}
    
    {$region 22.0 - Context State Queries}
    
    {$region 22.1 - Simple Queries}
    
    static procedure GetBooleanv(pname: GLGetQueries; [MarshalAs(UnmanagedType.LPArray)] data: array of boolean);
    external 'opengl32.dll' name 'glGetBooleanv';
    static procedure GetBooleanv(pname: GLGetQueries; var data: boolean);
    external 'opengl32.dll' name 'glGetBooleanv';
    static procedure GetBooleanv(pname: GLGetQueries; data: pointer);
    external 'opengl32.dll' name 'glGetBooleanv';
    
    static procedure GetIntegerv(pname: GLGetQueries; [MarshalAs(UnmanagedType.LPArray)] data: array of Int32);
    external 'opengl32.dll' name 'glGetIntegerv';
    static procedure GetIntegerv(pname: GLGetQueries; var data: Int32);
    external 'opengl32.dll' name 'glGetIntegerv';
    static procedure GetIntegerv(pname: GLGetQueries; data: pointer);
    external 'opengl32.dll' name 'glGetIntegerv';
    
    static procedure GetInteger64v(pname: GLGetQueries; [MarshalAs(UnmanagedType.LPArray)] data: array of Int64);
    external 'opengl32.dll' name 'glGetInteger64v';
    static procedure GetInteger64v(pname: GLGetQueries; var data: Int64);
    external 'opengl32.dll' name 'glGetInteger64v';
    static procedure GetInteger64v(pname: GLGetQueries; data: pointer);
    external 'opengl32.dll' name 'glGetInteger64v';
    
    static procedure GetFloatv(pname: GLGetQueries; [MarshalAs(UnmanagedType.LPArray)] data: array of single);
    external 'opengl32.dll' name 'glGetFloatv';
    static procedure GetFloatv(pname: GLGetQueries; var data: single);
    external 'opengl32.dll' name 'glGetFloatv';
    static procedure GetFloatv(pname: GLGetQueries; data: pointer);
    external 'opengl32.dll' name 'glGetFloatv';
    
    static procedure GetDoublev(pname: GLGetQueries; [MarshalAs(UnmanagedType.LPArray)] data: array of double);
    external 'opengl32.dll' name 'glGetDoublev';
    static procedure GetDoublev(pname: GLGetQueries; var data: double);
    external 'opengl32.dll' name 'glGetDoublev';
    static procedure GetDoublev(pname: GLGetQueries; data: pointer);
    external 'opengl32.dll' name 'glGetDoublev';
    
    static procedure GetBooleani_v(target: GLGetQueries; index: UInt32; [MarshalAs(UnmanagedType.LPArray)] data: array of boolean);
    external 'opengl32.dll' name 'glGetBooleani_v';
    static procedure GetBooleani_v(target: GLGetQueries; index: UInt32; var data: boolean);
    external 'opengl32.dll' name 'glGetBooleani_v';
    static procedure GetBooleani_v(target: GLGetQueries; index: UInt32; data: pointer);
    external 'opengl32.dll' name 'glGetBooleani_v';
    
    static procedure GetFloati_v(target: GLGetQueries; index: UInt32; [MarshalAs(UnmanagedType.LPArray)] data: array of single);
    external 'opengl32.dll' name 'glGetFloati_v';
    static procedure GetFloati_v(target: GLGetQueries; index: UInt32; var data: single);
    external 'opengl32.dll' name 'glGetFloati_v';
    static procedure GetFloati_v(target: GLGetQueries; index: UInt32; data: pointer);
    external 'opengl32.dll' name 'glGetFloati_v';
    
    static procedure GetIntegeri_v(target: GLGetQueries; index: UInt32; [MarshalAs(UnmanagedType.LPArray)] data: array of Int32);
    external 'opengl32.dll' name 'glGetIntegeri_v';
    static procedure GetIntegeri_v(target: GLGetQueries; index: UInt32; var data: Int32);
    external 'opengl32.dll' name 'glGetIntegeri_v';
    static procedure GetIntegeri_v(target: BufferBindType; index: UInt32; var data: BufferName);
    external 'opengl32.dll' name 'glGetIntegeri_v';
    static procedure GetIntegeri_v(target: GLGetQueries; index: UInt32; data: pointer);
    external 'opengl32.dll' name 'glGetIntegeri_v';
    
    static procedure GetInteger64i_v(target: GLGetQueries; index: UInt32; [MarshalAs(UnmanagedType.LPArray)] data: array of Int64);
    external 'opengl32.dll' name 'glGetInteger64i_v';
    static procedure GetInteger64i_v(target: GLGetQueries; index: UInt32; var data: Int64);
    external 'opengl32.dll' name 'glGetInteger64i_v';
    static procedure GetInteger64i_v(target: BufferBindType; index: UInt32; var data: Vec2i64);
    external 'opengl32.dll' name 'glGetInteger64i_v';
    static procedure GetInteger64i_v(target: GLGetQueries; index: UInt32; data: pointer);
    external 'opengl32.dll' name 'glGetInteger64i_v';
	  
    static procedure GetDoublei_v(target: GLGetQueries; index: UInt32; [MarshalAs(UnmanagedType.LPArray)] data: array of double);
    external 'opengl32.dll' name 'glGetDoublei_v';
    static procedure GetDoublei_v(target: GLGetQueries; index: UInt32; var data: double);
    external 'opengl32.dll' name 'glGetDoublei_v';
    static procedure GetDoublei_v(target: GLGetQueries; index: UInt32; data: pointer);
    external 'opengl32.dll' name 'glGetDoublei_v';
    
    static function IsEnabled(cap: EnablableName): boolean;
    external 'opengl32.dll' name 'glIsEnabled';
    
    static function IsEnabledi(target: EnablableName; index: UInt32): boolean;
    external 'opengl32.dll' name 'glIsEnabledi';
    
    {$endregion 22.1 - Simple Queries}
    
    {$region 22.2 - Pointer, String, and Related Context Queries}
    
    static procedure GetPointerv(pname: GLGetQueries; [MarshalAs(UnmanagedType.LPArray)] &params: array of IntPtr);
    external 'opengl32.dll' name 'glGetPointerv';
    static procedure GetPointerv(pname: GLGetQueries; var &params: IntPtr);
    external 'opengl32.dll' name 'glGetPointerv';
    static procedure GetPointerv(pname: GLGetQueries; var &params: pointer);
    external 'opengl32.dll' name 'glGetPointerv';
    static procedure GetPointerv(pname: GLGetQueries; &params: ^IntPtr);
    external 'opengl32.dll' name 'glGetPointerv';
    
    static function GetString(name: GLGetStringQueries): string; //ToDo #2029
    external 'opengl32.dll' name 'glGetString';
    static function GetStringPtr(name: GLGetStringQueries): IntPtr;
    external 'opengl32.dll' name 'glGetString';
    
    static function GetStringi(name: GLGetStringQueries; index: UInt32): string; //ToDo #2029
    external 'opengl32.dll' name 'glGetStringi';
    static function GetStringPtri(name: GLGetStringQueries; index: UInt32): IntPtr;
    external 'opengl32.dll' name 'glGetStringi';
    
    {$endregion 22.2 - Pointer, String, and Related Context Queries}
    
    {$region 22.3 - Internal Format Queries}
    
    static procedure GetInternalformativ(target: TextureBindTarget; internalformat: InternalDataFormat; pname: InternalFormatInfoType; bufSize: Int32; var &params: Int32);
    external 'opengl32.dll' name 'glGetInternalformativ';
    static procedure GetInternalformativ(target: TextureBindTarget; internalformat: InternalDataFormat; pname: InternalFormatInfoType; bufSize: Int32; [MarshalAs(UnmanagedType.LPArray)] &params: array of Int32);
    external 'opengl32.dll' name 'glGetInternalformativ';
    static procedure GetInternalformativ(target: TextureBindTarget; internalformat: InternalDataFormat; pname: InternalFormatInfoType; bufSize: Int32; var &params: SupportLevel);
    external 'opengl32.dll' name 'glGetInternalformativ';
    static procedure GetInternalformativ(target: TextureBindTarget; internalformat: InternalDataFormat; pname: InternalFormatInfoType; bufSize: Int32; var &params: DataFormat);
    external 'opengl32.dll' name 'glGetInternalformativ';
    static procedure GetInternalformativ(target: TextureBindTarget; internalformat: InternalDataFormat; pname: InternalFormatInfoType; bufSize: Int32; var &params: DataType);
    external 'opengl32.dll' name 'glGetInternalformativ';
    static procedure GetInternalformativ(target: TextureBindTarget; internalformat: InternalDataFormat; pname: InternalFormatInfoType; bufSize: Int32; var &params: CompatibilityImageClassType);
    external 'opengl32.dll' name 'glGetInternalformativ';
    static procedure GetInternalformativ(target: TextureBindTarget; internalformat: InternalDataFormat; pname: InternalFormatInfoType; bufSize: Int32; var &params: ImageFormatCompatibilityMode);
    external 'opengl32.dll' name 'glGetInternalformativ';
    static procedure GetInternalformativ(target: TextureBindTarget; internalformat: InternalDataFormat; pname: InternalFormatInfoType; bufSize: Int32; &params: pointer);
    external 'opengl32.dll' name 'glGetInternalformativ';
    
    static procedure GetInternalformati64v(target: TextureBindTarget; internalformat: InternalDataFormat; pname: InternalFormatInfoType; bufSize: Int32; [MarshalAs(UnmanagedType.LPArray)] &params: array of Int64);
    external 'opengl32.dll' name 'glGetInternalformati64v';
    static procedure GetInternalformati64v(target: TextureBindTarget; internalformat: InternalDataFormat; pname: InternalFormatInfoType; bufSize: Int32; var &params: Int64);
    external 'opengl32.dll' name 'glGetInternalformati64v';
    static procedure GetInternalformati64v(target: TextureBindTarget; internalformat: InternalDataFormat; pname: InternalFormatInfoType; bufSize: Int32; &params: pointer);
    external 'opengl32.dll' name 'glGetInternalformati64v';
    
    {$endregion 22.3 - Internal Format Queries}
    
    {$region 22.4 - Transform Feedback State Queries}
    
    static procedure GetTransformFeedbackiv(xfb: TransformFeedbackName; pname: TransformFeedbackInfoType; var param: BufferName);
    external 'opengl32.dll' name 'glGetTransformFeedbackiv';
    static procedure GetTransformFeedbackiv(xfb: TransformFeedbackName; pname: TransformFeedbackInfoType; var param: Int32);
    external 'opengl32.dll' name 'glGetTransformFeedbackiv';
    static procedure GetTransformFeedbackiv(xfb: TransformFeedbackName; pname: TransformFeedbackInfoType; param: pointer);
    external 'opengl32.dll' name 'glGetTransformFeedbackiv';
    
    static procedure GetTransformFeedbacki_v(xfb: TransformFeedbackName; pname: TransformFeedbackInfoType; index: UInt32; var param: BufferName);
    external 'opengl32.dll' name 'glGetTransformFeedbacki_v';
    static procedure GetTransformFeedbacki_v(xfb: TransformFeedbackName; pname: TransformFeedbackInfoType; index: UInt32; var param: Int32);
    external 'opengl32.dll' name 'glGetTransformFeedbacki_v';
    static procedure GetTransformFeedbacki_v(xfb: TransformFeedbackName; pname: TransformFeedbackInfoType; index: UInt32; param: pointer);
    external 'opengl32.dll' name 'glGetTransformFeedbacki_v';
    
    static procedure GetTransformFeedbacki64_v(xfb: TransformFeedbackName; pname: TransformFeedbackInfoType; index: UInt32; var param: Int64);
    external 'opengl32.dll' name 'glGetTransformFeedbacki64_v';
    static procedure GetTransformFeedbacki64_v(xfb: TransformFeedbackName; pname: TransformFeedbackInfoType; index: UInt32; param: pointer);
    external 'opengl32.dll' name 'glGetTransformFeedbacki64_v';
    
    {$endregion 22.4 - Transform Feedback State Queries}
    
    {$endregion 22.0 - Context State Queries}
    
  end;
  
  //ToDo подчистить всё что дальше:
  
  //ToDo похоже в .h не хватает функций, констант и т.п.
  // - пройтись по личным спецификациям каждого расширения
  
  /// Расширения, которые встречаются у всех видеокарт
  gl_ARB = static class
    
    {$region ARB}
    
    static procedure PrimitiveBoundingBoxARB(minX: single; minY: single; minZ: single; minW: single; maxX: single; maxY: single; maxZ: single; maxW: single);
    external 'opengl32.dll' name 'glPrimitiveBoundingBoxARB';
    
    static function GetTextureHandleARB(texture: UInt32): UInt64;
    external 'opengl32.dll' name 'glGetTextureHandleARB';
    
    static function GetTextureSamplerHandleARB(texture: UInt32; sampler: UInt32): UInt64;
    external 'opengl32.dll' name 'glGetTextureSamplerHandleARB';
    
    static procedure MakeTextureHandleResidentARB(handle: UInt64);
    external 'opengl32.dll' name 'glMakeTextureHandleResidentARB';
    
    static procedure MakeTextureHandleNonResidentARB(handle: UInt64);
    external 'opengl32.dll' name 'glMakeTextureHandleNonResidentARB';
    
    static function GetImageHandleARB(texture: UInt32; level: Int32; layered: boolean; layer: Int32; format: UInt32): UInt64;
    external 'opengl32.dll' name 'glGetImageHandleARB';
    
    static procedure MakeImageHandleResidentARB(handle: UInt64; access: UInt32);
    external 'opengl32.dll' name 'glMakeImageHandleResidentARB';
    
    static procedure MakeImageHandleNonResidentARB(handle: UInt64);
    external 'opengl32.dll' name 'glMakeImageHandleNonResidentARB';
    
    static procedure UniformHandleui64ARB(location: Int32; value: UInt64);
    external 'opengl32.dll' name 'glUniformHandleui64ARB';
    
    static procedure UniformHandleui64vARB(location: Int32; count: Int32; value: ^UInt64);
    external 'opengl32.dll' name 'glUniformHandleui64vARB';
    
    static procedure ProgramUniformHandleui64ARB(&program: UInt32; location: Int32; value: UInt64);
    external 'opengl32.dll' name 'glProgramUniformHandleui64ARB';
    
    static procedure ProgramUniformHandleui64vARB(&program: UInt32; location: Int32; count: Int32; values: ^UInt64);
    external 'opengl32.dll' name 'glProgramUniformHandleui64vARB';
    
    static function IsTextureHandleResidentARB(handle: UInt64): boolean;
    external 'opengl32.dll' name 'glIsTextureHandleResidentARB';
    
    static function IsImageHandleResidentARB(handle: UInt64): boolean;
    external 'opengl32.dll' name 'glIsImageHandleResidentARB';
    
    static function CreateSyncFromCLeventARB(context: cl_context; &event: cl_event; flags: UInt32): GLsync;
    external 'opengl32.dll' name 'glCreateSyncFromCLeventARB';
    
    static procedure DispatchComputeGroupSizeARB(num_groups_x: UInt32; num_groups_y: UInt32; num_groups_z: UInt32; group_size_x: UInt32; group_size_y: UInt32; group_size_z: UInt32);
    external 'opengl32.dll' name 'glDispatchComputeGroupSizeARB';
    
    static procedure DebugMessageControlARB(source: UInt32; &type: UInt32; severity: UInt32; count: Int32; ids: ^UInt32; enabled: boolean);
    external 'opengl32.dll' name 'glDebugMessageControlARB';
    
    static procedure DebugMessageInsertARB(source: UInt32; &type: UInt32; id: UInt32; severity: UInt32; length: Int32; buf: ^SByte);
    external 'opengl32.dll' name 'glDebugMessageInsertARB';
    
    static procedure DebugMessageCallbackARB(callback: GLDEBUGPROC; userParam: pointer);
    external 'opengl32.dll' name 'glDebugMessageCallbackARB';
    
    static function GetDebugMessageLogARB(count: UInt32; bufSize: Int32; sources: ^UInt32; types: ^UInt32; ids: ^UInt32; severities: ^UInt32; lengths: ^Int32; messageLog: ^SByte): UInt32;
    external 'opengl32.dll' name 'glGetDebugMessageLogARB';
    
    static procedure BlendEquationiARB(buf: UInt32; mode: UInt32);
    external 'opengl32.dll' name 'glBlendEquationiARB';
    
    static procedure BlendEquationSeparateiARB(buf: UInt32; modeRGB: UInt32; modeAlpha: UInt32);
    external 'opengl32.dll' name 'glBlendEquationSeparateiARB';
    
    static procedure BlendFunciARB(buf: UInt32; src: UInt32; dst: UInt32);
    external 'opengl32.dll' name 'glBlendFunciARB';
    
    static procedure BlendFuncSeparateiARB(buf: UInt32; srcRGB: UInt32; dstRGB: UInt32; srcAlpha: UInt32; dstAlpha: UInt32);
    external 'opengl32.dll' name 'glBlendFuncSeparateiARB';
    
    static procedure DrawArraysInstancedARB(mode: UInt32; first: Int32; count: Int32; primcount: Int32);
    external 'opengl32.dll' name 'glDrawArraysInstancedARB';
    
    static procedure DrawElementsInstancedARB(mode: UInt32; count: Int32; &type: UInt32; indices: pointer; primcount: Int32);
    external 'opengl32.dll' name 'glDrawElementsInstancedARB';
    
    static procedure ProgramParameteriARB(&program: UInt32; pname: UInt32; value: Int32);
    external 'opengl32.dll' name 'glProgramParameteriARB';
    
    static procedure FramebufferTextureARB(target: UInt32; attachment: UInt32; texture: UInt32; level: Int32);
    external 'opengl32.dll' name 'glFramebufferTextureARB';
    
    static procedure FramebufferTextureLayerARB(target: UInt32; attachment: UInt32; texture: UInt32; level: Int32; layer: Int32);
    external 'opengl32.dll' name 'glFramebufferTextureLayerARB';
    
    static procedure FramebufferTextureFaceARB(target: UInt32; attachment: UInt32; texture: UInt32; level: Int32; face: UInt32);
    external 'opengl32.dll' name 'glFramebufferTextureFaceARB';
    
    static procedure SpecializeShaderARB(shader: UInt32; pEntryPoint: ^SByte; numSpecializationConstants: UInt32; pConstantIndex: ^UInt32; pConstantValue: ^UInt32);
    external 'opengl32.dll' name 'glSpecializeShaderARB';
    
    static procedure Uniform1i64ARB(location: Int32; x: Int64);
    external 'opengl32.dll' name 'glUniform1i64ARB';
    
    static procedure Uniform2i64ARB(location: Int32; x: Int64; y: Int64);
    external 'opengl32.dll' name 'glUniform2i64ARB';
    
    static procedure Uniform3i64ARB(location: Int32; x: Int64; y: Int64; z: Int64);
    external 'opengl32.dll' name 'glUniform3i64ARB';
    
    static procedure Uniform4i64ARB(location: Int32; x: Int64; y: Int64; z: Int64; w: Int64);
    external 'opengl32.dll' name 'glUniform4i64ARB';
    
    static procedure Uniform1i64vARB(location: Int32; count: Int32; value: ^Int64);
    external 'opengl32.dll' name 'glUniform1i64vARB';
    
    static procedure Uniform2i64vARB(location: Int32; count: Int32; value: ^Int64);
    external 'opengl32.dll' name 'glUniform2i64vARB';
    
    static procedure Uniform3i64vARB(location: Int32; count: Int32; value: ^Int64);
    external 'opengl32.dll' name 'glUniform3i64vARB';
    
    static procedure Uniform4i64vARB(location: Int32; count: Int32; value: ^Int64);
    external 'opengl32.dll' name 'glUniform4i64vARB';
    
    static procedure Uniform1ui64ARB(location: Int32; x: UInt64);
    external 'opengl32.dll' name 'glUniform1ui64ARB';
    
    static procedure Uniform2ui64ARB(location: Int32; x: UInt64; y: UInt64);
    external 'opengl32.dll' name 'glUniform2ui64ARB';
    
    static procedure Uniform3ui64ARB(location: Int32; x: UInt64; y: UInt64; z: UInt64);
    external 'opengl32.dll' name 'glUniform3ui64ARB';
    
    static procedure Uniform4ui64ARB(location: Int32; x: UInt64; y: UInt64; z: UInt64; w: UInt64);
    external 'opengl32.dll' name 'glUniform4ui64ARB';
    
    static procedure Uniform1ui64vARB(location: Int32; count: Int32; value: ^UInt64);
    external 'opengl32.dll' name 'glUniform1ui64vARB';
    
    static procedure Uniform2ui64vARB(location: Int32; count: Int32; value: ^UInt64);
    external 'opengl32.dll' name 'glUniform2ui64vARB';
    
    static procedure Uniform3ui64vARB(location: Int32; count: Int32; value: ^UInt64);
    external 'opengl32.dll' name 'glUniform3ui64vARB';
    
    static procedure Uniform4ui64vARB(location: Int32; count: Int32; value: ^UInt64);
    external 'opengl32.dll' name 'glUniform4ui64vARB';
    
    static procedure GetUniformi64vARB(&program: UInt32; location: Int32; &params: ^Int64);
    external 'opengl32.dll' name 'glGetUniformi64vARB';
    
    static procedure GetUniformui64vARB(&program: UInt32; location: Int32; &params: ^UInt64);
    external 'opengl32.dll' name 'glGetUniformui64vARB';
    
    static procedure GetnUniformi64vARB(&program: UInt32; location: Int32; bufSize: Int32; &params: ^Int64);
    external 'opengl32.dll' name 'glGetnUniformi64vARB';
    
    static procedure GetnUniformui64vARB(&program: UInt32; location: Int32; bufSize: Int32; &params: ^UInt64);
    external 'opengl32.dll' name 'glGetnUniformui64vARB';
    
    static procedure ProgramUniform1i64ARB(&program: UInt32; location: Int32; x: Int64);
    external 'opengl32.dll' name 'glProgramUniform1i64ARB';
    
    static procedure ProgramUniform2i64ARB(&program: UInt32; location: Int32; x: Int64; y: Int64);
    external 'opengl32.dll' name 'glProgramUniform2i64ARB';
    
    static procedure ProgramUniform3i64ARB(&program: UInt32; location: Int32; x: Int64; y: Int64; z: Int64);
    external 'opengl32.dll' name 'glProgramUniform3i64ARB';
    
    static procedure ProgramUniform4i64ARB(&program: UInt32; location: Int32; x: Int64; y: Int64; z: Int64; w: Int64);
    external 'opengl32.dll' name 'glProgramUniform4i64ARB';
    
    static procedure ProgramUniform1i64vARB(&program: UInt32; location: Int32; count: Int32; value: ^Int64);
    external 'opengl32.dll' name 'glProgramUniform1i64vARB';
    
    static procedure ProgramUniform2i64vARB(&program: UInt32; location: Int32; count: Int32; value: ^Int64);
    external 'opengl32.dll' name 'glProgramUniform2i64vARB';
    
    static procedure ProgramUniform3i64vARB(&program: UInt32; location: Int32; count: Int32; value: ^Int64);
    external 'opengl32.dll' name 'glProgramUniform3i64vARB';
    
    static procedure ProgramUniform4i64vARB(&program: UInt32; location: Int32; count: Int32; value: ^Int64);
    external 'opengl32.dll' name 'glProgramUniform4i64vARB';
    
    static procedure ProgramUniform1ui64ARB(&program: UInt32; location: Int32; x: UInt64);
    external 'opengl32.dll' name 'glProgramUniform1ui64ARB';
    
    static procedure ProgramUniform2ui64ARB(&program: UInt32; location: Int32; x: UInt64; y: UInt64);
    external 'opengl32.dll' name 'glProgramUniform2ui64ARB';
    
    static procedure ProgramUniform3ui64ARB(&program: UInt32; location: Int32; x: UInt64; y: UInt64; z: UInt64);
    external 'opengl32.dll' name 'glProgramUniform3ui64ARB';
    
    static procedure ProgramUniform4ui64ARB(&program: UInt32; location: Int32; x: UInt64; y: UInt64; z: UInt64; w: UInt64);
    external 'opengl32.dll' name 'glProgramUniform4ui64ARB';
    
    static procedure ProgramUniform1ui64vARB(&program: UInt32; location: Int32; count: Int32; value: ^UInt64);
    external 'opengl32.dll' name 'glProgramUniform1ui64vARB';
    
    static procedure ProgramUniform2ui64vARB(&program: UInt32; location: Int32; count: Int32; value: ^UInt64);
    external 'opengl32.dll' name 'glProgramUniform2ui64vARB';
    
    static procedure ProgramUniform3ui64vARB(&program: UInt32; location: Int32; count: Int32; value: ^UInt64);
    external 'opengl32.dll' name 'glProgramUniform3ui64vARB';
    
    static procedure ProgramUniform4ui64vARB(&program: UInt32; location: Int32; count: Int32; value: ^UInt64);
    external 'opengl32.dll' name 'glProgramUniform4ui64vARB';
    
    static procedure MultiDrawArraysIndirectCountARB(mode: UInt32; indirect: pointer; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32);
    external 'opengl32.dll' name 'glMultiDrawArraysIndirectCountARB';
    
    static procedure MultiDrawElementsIndirectCountARB(mode: UInt32; &type: UInt32; indirect: pointer; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32);
    external 'opengl32.dll' name 'glMultiDrawElementsIndirectCountARB';
    
    static procedure MaxShaderCompilerThreadsARB(count: UInt32);
    external 'opengl32.dll' name 'glMaxShaderCompilerThreadsARB';
    
    static procedure GetnTexImageARB(target: UInt32; level: Int32; format: UInt32; &type: UInt32; bufSize: Int32; img: pointer);
    external 'opengl32.dll' name 'glGetnTexImageARB';
    
    static procedure ReadnPixelsARB(x: Int32; y: Int32; width: Int32; height: Int32; format: UInt32; &type: UInt32; bufSize: Int32; data: pointer);
    external 'opengl32.dll' name 'glReadnPixelsARB';
    
    static procedure GetnCompressedTexImageARB(target: UInt32; lod: Int32; bufSize: Int32; img: pointer);
    external 'opengl32.dll' name 'glGetnCompressedTexImageARB';
    
    static procedure GetnUniformfvARB(&program: UInt32; location: Int32; bufSize: Int32; &params: ^single);
    external 'opengl32.dll' name 'glGetnUniformfvARB';
    
    static procedure GetnUniformivARB(&program: UInt32; location: Int32; bufSize: Int32; &params: ^Int32);
    external 'opengl32.dll' name 'glGetnUniformivARB';
    
    static procedure GetnUniformuivARB(&program: UInt32; location: Int32; bufSize: Int32; &params: ^UInt32);
    external 'opengl32.dll' name 'glGetnUniformuivARB';
    
    static procedure GetnUniformdvARB(&program: UInt32; location: Int32; bufSize: Int32; &params: ^double);
    external 'opengl32.dll' name 'glGetnUniformdvARB';
    
    static procedure FramebufferSampleLocationsfvARB(target: UInt32; start: UInt32; count: Int32; v: ^single);
    external 'opengl32.dll' name 'glFramebufferSampleLocationsfvARB';
    
    static procedure NamedFramebufferSampleLocationsfvARB(framebuffer: UInt32; start: UInt32; count: Int32; v: ^single);
    external 'opengl32.dll' name 'glNamedFramebufferSampleLocationsfvARB';
    
    static procedure EvaluateDepthValuesARB;
    external 'opengl32.dll' name 'glEvaluateDepthValuesARB';
    
    static procedure MinSampleShadingARB(value: single);
    external 'opengl32.dll' name 'glMinSampleShadingARB';
    
    static procedure NamedStringARB(&type: UInt32; namelen: Int32; name: ^SByte; stringlen: Int32; string: ^SByte);
    external 'opengl32.dll' name 'glNamedStringARB';
    
    static procedure DeleteNamedStringARB(namelen: Int32; name: ^SByte);
    external 'opengl32.dll' name 'glDeleteNamedStringARB';
    
    static procedure CompileShaderIncludeARB(shader: UInt32; count: Int32; path: ^IntPtr; length: ^Int32);
    external 'opengl32.dll' name 'glCompileShaderIncludeARB';
    
    static function IsNamedStringARB(namelen: Int32; name: ^SByte): boolean;
    external 'opengl32.dll' name 'glIsNamedStringARB';
    
    static procedure GetNamedStringARB(namelen: Int32; name: ^SByte; bufSize: Int32; stringlen: ^Int32; string: ^SByte);
    external 'opengl32.dll' name 'glGetNamedStringARB';
    
    static procedure GetNamedStringivARB(namelen: Int32; name: ^SByte; pname: UInt32; &params: ^Int32);
    external 'opengl32.dll' name 'glGetNamedStringivARB';
    
    static procedure BufferPageCommitmentARB(target: UInt32; offset: IntPtr; size: UIntPtr; commit: boolean);
    external 'opengl32.dll' name 'glBufferPageCommitmentARB';
    
    static procedure NamedBufferPageCommitmentARB(buffer: UInt32; offset: IntPtr; size: UIntPtr; commit: boolean);
    external 'opengl32.dll' name 'glNamedBufferPageCommitmentARB';
    
    static procedure TexPageCommitmentARB(target: UInt32; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; commit: boolean);
    external 'opengl32.dll' name 'glTexPageCommitmentARB';
    
    static procedure TexBufferARB(target: UInt32; internalformat: UInt32; buffer: UInt32);
    external 'opengl32.dll' name 'glTexBufferARB';
    
    static procedure VertexAttribDivisorARB(index: UInt32; divisor: UInt32);
    external 'opengl32.dll' name 'glVertexAttribDivisorARB';
    
    static procedure GetVertexAttribLui64vARB(index: UInt32; pname: UInt32; &params: ^UInt64);
    external 'opengl32.dll' name 'glGetVertexAttribLui64vARB';
    
    static procedure VertexAttribL1ui64ARB(index: UInt32; x: UInt64);
    external 'opengl32.dll' name 'glVertexAttribL1ui64ARB';
    
    static procedure VertexAttribL1ui64vARB(index: UInt32; v: ^UInt64);
    external 'opengl32.dll' name 'glVertexAttribL1ui64vARB';
    
    static procedure ClampColorARB(target: ErrorCode; clamp: ErrorCode);
    external 'opengl32.dll' name 'glClampColorARB';
    
    static procedure DrawBuffersARB(n: Int32; bufs: ^ErrorCode);
    external 'opengl32.dll' name 'glDrawBuffersARB';
    
    static procedure ProgramStringARB(target: ErrorCode; format: ErrorCode; len: Int32; string: pointer);
    external 'opengl32.dll' name 'glProgramStringARB';
    
    static procedure BindProgramARB(target: ErrorCode; &program: UInt32);
    external 'opengl32.dll' name 'glBindProgramARB';
    
    static procedure DeleteProgramsARB(n: Int32; programs: ^UInt32);
    external 'opengl32.dll' name 'glDeleteProgramsARB';
    
    static procedure GenProgramsARB(n: Int32; programs: ^UInt32);
    external 'opengl32.dll' name 'glGenProgramsARB';
    
    static procedure ProgramEnvParameter4dARB(target: ErrorCode; index: UInt32; x: double; y: double; z: double; w: double);
    external 'opengl32.dll' name 'glProgramEnvParameter4dARB';
    
    static procedure ProgramEnvParameter4dvARB(target: ErrorCode; index: UInt32; &params: ^double);
    external 'opengl32.dll' name 'glProgramEnvParameter4dvARB';
    
    static procedure ProgramEnvParameter4fARB(target: ErrorCode; index: UInt32; x: single; y: single; z: single; w: single);
    external 'opengl32.dll' name 'glProgramEnvParameter4fARB';
    
    static procedure ProgramEnvParameter4fvARB(target: ErrorCode; index: UInt32; &params: ^single);
    external 'opengl32.dll' name 'glProgramEnvParameter4fvARB';
    
    static procedure ProgramLocalParameter4dARB(target: ErrorCode; index: UInt32; x: double; y: double; z: double; w: double);
    external 'opengl32.dll' name 'glProgramLocalParameter4dARB';
    
    static procedure ProgramLocalParameter4dvARB(target: ErrorCode; index: UInt32; &params: ^double);
    external 'opengl32.dll' name 'glProgramLocalParameter4dvARB';
    
    static procedure ProgramLocalParameter4fARB(target: ErrorCode; index: UInt32; x: single; y: single; z: single; w: single);
    external 'opengl32.dll' name 'glProgramLocalParameter4fARB';
    
    static procedure ProgramLocalParameter4fvARB(target: ErrorCode; index: UInt32; &params: ^single);
    external 'opengl32.dll' name 'glProgramLocalParameter4fvARB';
    
    static procedure GetProgramEnvParameterdvARB(target: ErrorCode; index: UInt32; &params: ^double);
    external 'opengl32.dll' name 'glGetProgramEnvParameterdvARB';
    
    static procedure GetProgramEnvParameterfvARB(target: ErrorCode; index: UInt32; &params: ^single);
    external 'opengl32.dll' name 'glGetProgramEnvParameterfvARB';
    
    static procedure GetProgramLocalParameterdvARB(target: ErrorCode; index: UInt32; &params: ^double);
    external 'opengl32.dll' name 'glGetProgramLocalParameterdvARB';
    
    static procedure GetProgramLocalParameterfvARB(target: ErrorCode; index: UInt32; &params: ^single);
    external 'opengl32.dll' name 'glGetProgramLocalParameterfvARB';
    
    static procedure GetProgramivARB(target: ErrorCode; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetProgramivARB';
    
    static procedure GetProgramStringARB(target: ErrorCode; pname: ErrorCode; string: pointer);
    external 'opengl32.dll' name 'glGetProgramStringARB';
    
    static function IsProgramARB(&program: UInt32): Byte;
    external 'opengl32.dll' name 'glIsProgramARB';
    
    static procedure CurrentPaletteMatrixARB(index: Int32);
    external 'opengl32.dll' name 'glCurrentPaletteMatrixARB';
    
    static procedure MatrixIndexubvARB(size: Int32; indices: ^Byte);
    external 'opengl32.dll' name 'glMatrixIndexubvARB';
    
    static procedure MatrixIndexusvARB(size: Int32; indices: ^UInt16);
    external 'opengl32.dll' name 'glMatrixIndexusvARB';
    
    static procedure MatrixIndexuivARB(size: Int32; indices: ^UInt32);
    external 'opengl32.dll' name 'glMatrixIndexuivARB';
    
    static procedure MatrixIndexPointerARB(size: Int32; &type: ErrorCode; stride: Int32; _pointer: pointer);
    external 'opengl32.dll' name 'glMatrixIndexPointerARB';
    
    static procedure SampleCoverageARB(value: single; invert: Byte);
    external 'opengl32.dll' name 'glSampleCoverageARB';
    
    static procedure ActiveTextureARB(texture: ErrorCode);
    external 'opengl32.dll' name 'glActiveTextureARB';
    
    static procedure ClientActiveTextureARB(texture: ErrorCode);
    external 'opengl32.dll' name 'glClientActiveTextureARB';
    
    static procedure MultiTexCoord1dARB(target: ErrorCode; s: double);
    external 'opengl32.dll' name 'glMultiTexCoord1dARB';
    
    static procedure MultiTexCoord1dvARB(target: ErrorCode; v: ^double);
    external 'opengl32.dll' name 'glMultiTexCoord1dvARB';
    
    static procedure MultiTexCoord1fARB(target: ErrorCode; s: single);
    external 'opengl32.dll' name 'glMultiTexCoord1fARB';
    
    static procedure MultiTexCoord1fvARB(target: ErrorCode; v: ^single);
    external 'opengl32.dll' name 'glMultiTexCoord1fvARB';
    
    static procedure MultiTexCoord1iARB(target: ErrorCode; s: Int32);
    external 'opengl32.dll' name 'glMultiTexCoord1iARB';
    
    static procedure MultiTexCoord1ivARB(target: ErrorCode; v: ^Int32);
    external 'opengl32.dll' name 'glMultiTexCoord1ivARB';
    
    static procedure MultiTexCoord1sARB(target: ErrorCode; s: Int16);
    external 'opengl32.dll' name 'glMultiTexCoord1sARB';
    
    static procedure MultiTexCoord1svARB(target: ErrorCode; v: ^Int16);
    external 'opengl32.dll' name 'glMultiTexCoord1svARB';
    
    static procedure MultiTexCoord2dARB(target: ErrorCode; s: double; t: double);
    external 'opengl32.dll' name 'glMultiTexCoord2dARB';
    
    static procedure MultiTexCoord2dvARB(target: ErrorCode; v: ^double);
    external 'opengl32.dll' name 'glMultiTexCoord2dvARB';
    
    static procedure MultiTexCoord2fARB(target: ErrorCode; s: single; t: single);
    external 'opengl32.dll' name 'glMultiTexCoord2fARB';
    
    static procedure MultiTexCoord2fvARB(target: ErrorCode; v: ^single);
    external 'opengl32.dll' name 'glMultiTexCoord2fvARB';
    
    static procedure MultiTexCoord2iARB(target: ErrorCode; s: Int32; t: Int32);
    external 'opengl32.dll' name 'glMultiTexCoord2iARB';
    
    static procedure MultiTexCoord2ivARB(target: ErrorCode; v: ^Int32);
    external 'opengl32.dll' name 'glMultiTexCoord2ivARB';
    
    static procedure MultiTexCoord2sARB(target: ErrorCode; s: Int16; t: Int16);
    external 'opengl32.dll' name 'glMultiTexCoord2sARB';
    
    static procedure MultiTexCoord2svARB(target: ErrorCode; v: ^Int16);
    external 'opengl32.dll' name 'glMultiTexCoord2svARB';
    
    static procedure MultiTexCoord3dARB(target: ErrorCode; s: double; t: double; r: double);
    external 'opengl32.dll' name 'glMultiTexCoord3dARB';
    
    static procedure MultiTexCoord3dvARB(target: ErrorCode; v: ^double);
    external 'opengl32.dll' name 'glMultiTexCoord3dvARB';
    
    static procedure MultiTexCoord3fARB(target: ErrorCode; s: single; t: single; r: single);
    external 'opengl32.dll' name 'glMultiTexCoord3fARB';
    
    static procedure MultiTexCoord3fvARB(target: ErrorCode; v: ^single);
    external 'opengl32.dll' name 'glMultiTexCoord3fvARB';
    
    static procedure MultiTexCoord3iARB(target: ErrorCode; s: Int32; t: Int32; r: Int32);
    external 'opengl32.dll' name 'glMultiTexCoord3iARB';
    
    static procedure MultiTexCoord3ivARB(target: ErrorCode; v: ^Int32);
    external 'opengl32.dll' name 'glMultiTexCoord3ivARB';
    
    static procedure MultiTexCoord3sARB(target: ErrorCode; s: Int16; t: Int16; r: Int16);
    external 'opengl32.dll' name 'glMultiTexCoord3sARB';
    
    static procedure MultiTexCoord3svARB(target: ErrorCode; v: ^Int16);
    external 'opengl32.dll' name 'glMultiTexCoord3svARB';
    
    static procedure MultiTexCoord4dARB(target: ErrorCode; s: double; t: double; r: double; q: double);
    external 'opengl32.dll' name 'glMultiTexCoord4dARB';
    
    static procedure MultiTexCoord4dvARB(target: ErrorCode; v: ^double);
    external 'opengl32.dll' name 'glMultiTexCoord4dvARB';
    
    static procedure MultiTexCoord4fARB(target: ErrorCode; s: single; t: single; r: single; q: single);
    external 'opengl32.dll' name 'glMultiTexCoord4fARB';
    
    static procedure MultiTexCoord4fvARB(target: ErrorCode; v: ^single);
    external 'opengl32.dll' name 'glMultiTexCoord4fvARB';
    
    static procedure MultiTexCoord4iARB(target: ErrorCode; s: Int32; t: Int32; r: Int32; q: Int32);
    external 'opengl32.dll' name 'glMultiTexCoord4iARB';
    
    static procedure MultiTexCoord4ivARB(target: ErrorCode; v: ^Int32);
    external 'opengl32.dll' name 'glMultiTexCoord4ivARB';
    
    static procedure MultiTexCoord4sARB(target: ErrorCode; s: Int16; t: Int16; r: Int16; q: Int16);
    external 'opengl32.dll' name 'glMultiTexCoord4sARB';
    
    static procedure MultiTexCoord4svARB(target: ErrorCode; v: ^Int16);
    external 'opengl32.dll' name 'glMultiTexCoord4svARB';
    
    static procedure GenQueriesARB(n: Int32; ids: ^UInt32);
    external 'opengl32.dll' name 'glGenQueriesARB';
    
    static procedure DeleteQueriesARB(n: Int32; ids: ^UInt32);
    external 'opengl32.dll' name 'glDeleteQueriesARB';
    
    static function IsQueryARB(id: UInt32): Byte;
    external 'opengl32.dll' name 'glIsQueryARB';
    
    static procedure BeginQueryARB(target: ErrorCode; id: UInt32);
    external 'opengl32.dll' name 'glBeginQueryARB';
    
    static procedure EndQueryARB(target: ErrorCode);
    external 'opengl32.dll' name 'glEndQueryARB';
    
    static procedure GetQueryivARB(target: ErrorCode; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetQueryivARB';
    
    static procedure GetQueryObjectivARB(id: UInt32; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetQueryObjectivARB';
    
    static procedure GetQueryObjectuivARB(id: UInt32; pname: ErrorCode; &params: ^UInt32);
    external 'opengl32.dll' name 'glGetQueryObjectuivARB';
    
    static procedure PointParameterfARB(pname: ErrorCode; param: single);
    external 'opengl32.dll' name 'glPointParameterfARB';
    
    static procedure PointParameterfvARB(pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glPointParameterfvARB';
    
    static function GetGraphicsResetStatusARB: ErrorCode;
    external 'opengl32.dll' name 'glGetGraphicsResetStatusARB';
    
    static procedure GetnMapdvARB(target: ErrorCode; query: ErrorCode; bufSize: Int32; v: ^double);
    external 'opengl32.dll' name 'glGetnMapdvARB';
    
    static procedure GetnMapfvARB(target: ErrorCode; query: ErrorCode; bufSize: Int32; v: ^single);
    external 'opengl32.dll' name 'glGetnMapfvARB';
    
    static procedure GetnMapivARB(target: ErrorCode; query: ErrorCode; bufSize: Int32; v: ^Int32);
    external 'opengl32.dll' name 'glGetnMapivARB';
    
    static procedure GetnPixelMapfvARB(map: ErrorCode; bufSize: Int32; values: ^single);
    external 'opengl32.dll' name 'glGetnPixelMapfvARB';
    
    static procedure GetnPixelMapuivARB(map: ErrorCode; bufSize: Int32; values: ^UInt32);
    external 'opengl32.dll' name 'glGetnPixelMapuivARB';
    
    static procedure GetnPixelMapusvARB(map: ErrorCode; bufSize: Int32; values: ^UInt16);
    external 'opengl32.dll' name 'glGetnPixelMapusvARB';
    
    static procedure GetnPolygonStippleARB(bufSize: Int32; pattern: ^Byte);
    external 'opengl32.dll' name 'glGetnPolygonStippleARB';
    
    static procedure GetnColorTableARB(target: ErrorCode; format: ErrorCode; &type: ErrorCode; bufSize: Int32; table: pointer);
    external 'opengl32.dll' name 'glGetnColorTableARB';
    
    static procedure GetnConvolutionFilterARB(target: ErrorCode; format: ErrorCode; &type: ErrorCode; bufSize: Int32; image: pointer);
    external 'opengl32.dll' name 'glGetnConvolutionFilterARB';
    
    static procedure GetnSeparableFilterARB(target: ErrorCode; format: ErrorCode; &type: ErrorCode; rowBufSize: Int32; row: pointer; columnBufSize: Int32; column: pointer; span: pointer);
    external 'opengl32.dll' name 'glGetnSeparableFilterARB';
    
    static procedure GetnHistogramARB(target: ErrorCode; reset: Byte; format: ErrorCode; &type: ErrorCode; bufSize: Int32; values: pointer);
    external 'opengl32.dll' name 'glGetnHistogramARB';
    
    static procedure GetnMinmaxARB(target: ErrorCode; reset: Byte; format: ErrorCode; &type: ErrorCode; bufSize: Int32; values: pointer);
    external 'opengl32.dll' name 'glGetnMinmaxARB';
    
    static procedure DeleteObjectARB(obj: GLhandleARB);
    external 'opengl32.dll' name 'glDeleteObjectARB';
    
    static function GetHandleARB(pname: ErrorCode): GLhandleARB;
    external 'opengl32.dll' name 'glGetHandleARB';
    
    static procedure DetachObjectARB(containerObj: GLhandleARB; attachedObj: GLhandleARB);
    external 'opengl32.dll' name 'glDetachObjectARB';
    
    static function CreateShaderObjectARB(shaderType: ErrorCode): GLhandleARB;
    external 'opengl32.dll' name 'glCreateShaderObjectARB';
    
    static procedure ShaderSourceARB(shaderObj: GLhandleARB; count: Int32; string: ^^Byte; length: ^Int32);
    external 'opengl32.dll' name 'glShaderSourceARB';
    
    static procedure CompileShaderARB(shaderObj: GLhandleARB);
    external 'opengl32.dll' name 'glCompileShaderARB';
    
    static function CreateProgramObjectARB: GLhandleARB;
    external 'opengl32.dll' name 'glCreateProgramObjectARB';
    
    static procedure AttachObjectARB(containerObj: GLhandleARB; obj: GLhandleARB);
    external 'opengl32.dll' name 'glAttachObjectARB';
    
    static procedure LinkProgramARB(programObj: GLhandleARB);
    external 'opengl32.dll' name 'glLinkProgramARB';
    
    static procedure UseProgramObjectARB(programObj: GLhandleARB);
    external 'opengl32.dll' name 'glUseProgramObjectARB';
    
    static procedure ValidateProgramARB(programObj: GLhandleARB);
    external 'opengl32.dll' name 'glValidateProgramARB';
    
    static procedure Uniform1fARB(location: Int32; v0: single);
    external 'opengl32.dll' name 'glUniform1fARB';
    
    static procedure Uniform2fARB(location: Int32; v0: single; v1: single);
    external 'opengl32.dll' name 'glUniform2fARB';
    
    static procedure Uniform3fARB(location: Int32; v0: single; v1: single; v2: single);
    external 'opengl32.dll' name 'glUniform3fARB';
    
    static procedure Uniform4fARB(location: Int32; v0: single; v1: single; v2: single; v3: single);
    external 'opengl32.dll' name 'glUniform4fARB';
    
    static procedure Uniform1iARB(location: Int32; v0: Int32);
    external 'opengl32.dll' name 'glUniform1iARB';
    
    static procedure Uniform2iARB(location: Int32; v0: Int32; v1: Int32);
    external 'opengl32.dll' name 'glUniform2iARB';
    
    static procedure Uniform3iARB(location: Int32; v0: Int32; v1: Int32; v2: Int32);
    external 'opengl32.dll' name 'glUniform3iARB';
    
    static procedure Uniform4iARB(location: Int32; v0: Int32; v1: Int32; v2: Int32; v3: Int32);
    external 'opengl32.dll' name 'glUniform4iARB';
    
    static procedure Uniform1fvARB(location: Int32; count: Int32; value: ^single);
    external 'opengl32.dll' name 'glUniform1fvARB';
    
    static procedure Uniform2fvARB(location: Int32; count: Int32; value: ^single);
    external 'opengl32.dll' name 'glUniform2fvARB';
    
    static procedure Uniform3fvARB(location: Int32; count: Int32; value: ^single);
    external 'opengl32.dll' name 'glUniform3fvARB';
    
    static procedure Uniform4fvARB(location: Int32; count: Int32; value: ^single);
    external 'opengl32.dll' name 'glUniform4fvARB';
    
    static procedure Uniform1ivARB(location: Int32; count: Int32; value: ^Int32);
    external 'opengl32.dll' name 'glUniform1ivARB';
    
    static procedure Uniform2ivARB(location: Int32; count: Int32; value: ^Int32);
    external 'opengl32.dll' name 'glUniform2ivARB';
    
    static procedure Uniform3ivARB(location: Int32; count: Int32; value: ^Int32);
    external 'opengl32.dll' name 'glUniform3ivARB';
    
    static procedure Uniform4ivARB(location: Int32; count: Int32; value: ^Int32);
    external 'opengl32.dll' name 'glUniform4ivARB';
    
    static procedure UniformMatrix2fvARB(location: Int32; count: Int32; transpose: Byte; value: ^single);
    external 'opengl32.dll' name 'glUniformMatrix2fvARB';
    
    static procedure UniformMatrix3fvARB(location: Int32; count: Int32; transpose: Byte; value: ^single);
    external 'opengl32.dll' name 'glUniformMatrix3fvARB';
    
    static procedure UniformMatrix4fvARB(location: Int32; count: Int32; transpose: Byte; value: ^single);
    external 'opengl32.dll' name 'glUniformMatrix4fvARB';
    
    static procedure GetObjectParameterfvARB(obj: GLhandleARB; pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glGetObjectParameterfvARB';
    
    static procedure GetObjectParameterivARB(obj: GLhandleARB; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetObjectParameterivARB';
    
    static procedure GetInfoLogARB(obj: GLhandleARB; maxLength: Int32; length: ^Int32; infoLog: ^Byte);
    external 'opengl32.dll' name 'glGetInfoLogARB';
    
    static procedure GetAttachedObjectsARB(containerObj: GLhandleARB; maxCount: Int32; count: ^Int32; obj: ^GLhandleARB);
    external 'opengl32.dll' name 'glGetAttachedObjectsARB';
    
    static function GetUniformLocationARB(programObj: GLhandleARB; name: ^Byte): Int32;
    external 'opengl32.dll' name 'glGetUniformLocationARB';
    
    static procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: ^Int32; size: ^Int32; &type: ^ErrorCode; name: ^Byte);
    external 'opengl32.dll' name 'glGetActiveUniformARB';
    
    static procedure GetUniformfvARB(programObj: GLhandleARB; location: Int32; &params: ^single);
    external 'opengl32.dll' name 'glGetUniformfvARB';
    
    static procedure GetUniformivARB(programObj: GLhandleARB; location: Int32; &params: ^Int32);
    external 'opengl32.dll' name 'glGetUniformivARB';
    
    static procedure GetShaderSourceARB(obj: GLhandleARB; maxLength: Int32; length: ^Int32; source: ^Byte);
    external 'opengl32.dll' name 'glGetShaderSourceARB';
    
    static procedure CompressedTexImage3DARB(target: ErrorCode; level: Int32; internalformat: ErrorCode; width: Int32; height: Int32; depth: Int32; border: Int32; imageSize: Int32; data: pointer);
    external 'opengl32.dll' name 'glCompressedTexImage3DARB';
    
    static procedure CompressedTexImage2DARB(target: ErrorCode; level: Int32; internalformat: ErrorCode; width: Int32; height: Int32; border: Int32; imageSize: Int32; data: pointer);
    external 'opengl32.dll' name 'glCompressedTexImage2DARB';
    
    static procedure CompressedTexImage1DARB(target: ErrorCode; level: Int32; internalformat: ErrorCode; width: Int32; border: Int32; imageSize: Int32; data: pointer);
    external 'opengl32.dll' name 'glCompressedTexImage1DARB';
    
    static procedure CompressedTexSubImage3DARB(target: ErrorCode; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: ErrorCode; imageSize: Int32; data: pointer);
    external 'opengl32.dll' name 'glCompressedTexSubImage3DARB';
    
    static procedure CompressedTexSubImage2DARB(target: ErrorCode; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: ErrorCode; imageSize: Int32; data: pointer);
    external 'opengl32.dll' name 'glCompressedTexSubImage2DARB';
    
    static procedure CompressedTexSubImage1DARB(target: ErrorCode; level: Int32; xoffset: Int32; width: Int32; format: ErrorCode; imageSize: Int32; data: pointer);
    external 'opengl32.dll' name 'glCompressedTexSubImage1DARB';
    
    static procedure GetCompressedTexImageARB(target: ErrorCode; level: Int32; img: pointer);
    external 'opengl32.dll' name 'glGetCompressedTexImageARB';
    
    static procedure LoadTransposeMatrixfARB(m: ^single);
    external 'opengl32.dll' name 'glLoadTransposeMatrixfARB';
    
    static procedure LoadTransposeMatrixdARB(m: ^double);
    external 'opengl32.dll' name 'glLoadTransposeMatrixdARB';
    
    static procedure MultTransposeMatrixfARB(m: ^single);
    external 'opengl32.dll' name 'glMultTransposeMatrixfARB';
    
    static procedure MultTransposeMatrixdARB(m: ^double);
    external 'opengl32.dll' name 'glMultTransposeMatrixdARB';
    
    static procedure WeightbvARB(size: Int32; weights: ^SByte);
    external 'opengl32.dll' name 'glWeightbvARB';
    
    static procedure WeightsvARB(size: Int32; weights: ^Int16);
    external 'opengl32.dll' name 'glWeightsvARB';
    
    static procedure WeightivARB(size: Int32; weights: ^Int32);
    external 'opengl32.dll' name 'glWeightivARB';
    
    static procedure WeightfvARB(size: Int32; weights: ^single);
    external 'opengl32.dll' name 'glWeightfvARB';
    
    static procedure WeightdvARB(size: Int32; weights: ^double);
    external 'opengl32.dll' name 'glWeightdvARB';
    
    static procedure WeightubvARB(size: Int32; weights: ^Byte);
    external 'opengl32.dll' name 'glWeightubvARB';
    
    static procedure WeightusvARB(size: Int32; weights: ^UInt16);
    external 'opengl32.dll' name 'glWeightusvARB';
    
    static procedure WeightuivARB(size: Int32; weights: ^UInt32);
    external 'opengl32.dll' name 'glWeightuivARB';
    
    static procedure WeightPointerARB(size: Int32; &type: ErrorCode; stride: Int32; _pointer: pointer);
    external 'opengl32.dll' name 'glWeightPointerARB';
    
    static procedure VertexBlendARB(count: Int32);
    external 'opengl32.dll' name 'glVertexBlendARB';
    
    static procedure BindBufferARB(target: ErrorCode; buffer: UInt32);
    external 'opengl32.dll' name 'glBindBufferARB';
    
    static procedure DeleteBuffersARB(n: Int32; buffers: ^UInt32);
    external 'opengl32.dll' name 'glDeleteBuffersARB';
    
    static procedure GenBuffersARB(n: Int32; buffers: ^UInt32);
    external 'opengl32.dll' name 'glGenBuffersARB';
    
    static function IsBufferARB(buffer: UInt32): Byte;
    external 'opengl32.dll' name 'glIsBufferARB';
    
    static procedure BufferDataARB(target: ErrorCode; size: UIntPtr; data: pointer; usage: ErrorCode);
    external 'opengl32.dll' name 'glBufferDataARB';
    
    static procedure BufferSubDataARB(target: ErrorCode; offset: IntPtr; size: UIntPtr; data: pointer);
    external 'opengl32.dll' name 'glBufferSubDataARB';
    
    static procedure GetBufferSubDataARB(target: ErrorCode; offset: IntPtr; size: UIntPtr; data: pointer);
    external 'opengl32.dll' name 'glGetBufferSubDataARB';
    
    static function MapBufferARB(target: ErrorCode; access: ErrorCode): pointer;
    external 'opengl32.dll' name 'glMapBufferARB';
    
    static function UnmapBufferARB(target: ErrorCode): Byte;
    external 'opengl32.dll' name 'glUnmapBufferARB';
    
    static procedure GetBufferParameterivARB(target: ErrorCode; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetBufferParameterivARB';
    
    static procedure GetBufferPointervARB(target: ErrorCode; pname: ErrorCode; &params: ^pointer);
    external 'opengl32.dll' name 'glGetBufferPointervARB';
    
    static procedure VertexAttrib1dARB(index: UInt32; x: double);
    external 'opengl32.dll' name 'glVertexAttrib1dARB';
    
    static procedure VertexAttrib1dvARB(index: UInt32; v: ^double);
    external 'opengl32.dll' name 'glVertexAttrib1dvARB';
    
    static procedure VertexAttrib1fARB(index: UInt32; x: single);
    external 'opengl32.dll' name 'glVertexAttrib1fARB';
    
    static procedure VertexAttrib1fvARB(index: UInt32; v: ^single);
    external 'opengl32.dll' name 'glVertexAttrib1fvARB';
    
    static procedure VertexAttrib1sARB(index: UInt32; x: Int16);
    external 'opengl32.dll' name 'glVertexAttrib1sARB';
    
    static procedure VertexAttrib1svARB(index: UInt32; v: ^Int16);
    external 'opengl32.dll' name 'glVertexAttrib1svARB';
    
    static procedure VertexAttrib2dARB(index: UInt32; x: double; y: double);
    external 'opengl32.dll' name 'glVertexAttrib2dARB';
    
    static procedure VertexAttrib2dvARB(index: UInt32; v: ^double);
    external 'opengl32.dll' name 'glVertexAttrib2dvARB';
    
    static procedure VertexAttrib2fARB(index: UInt32; x: single; y: single);
    external 'opengl32.dll' name 'glVertexAttrib2fARB';
    
    static procedure VertexAttrib2fvARB(index: UInt32; v: ^single);
    external 'opengl32.dll' name 'glVertexAttrib2fvARB';
    
    static procedure VertexAttrib2sARB(index: UInt32; x: Int16; y: Int16);
    external 'opengl32.dll' name 'glVertexAttrib2sARB';
    
    static procedure VertexAttrib2svARB(index: UInt32; v: ^Int16);
    external 'opengl32.dll' name 'glVertexAttrib2svARB';
    
    static procedure VertexAttrib3dARB(index: UInt32; x: double; y: double; z: double);
    external 'opengl32.dll' name 'glVertexAttrib3dARB';
    
    static procedure VertexAttrib3dvARB(index: UInt32; v: ^double);
    external 'opengl32.dll' name 'glVertexAttrib3dvARB';
    
    static procedure VertexAttrib3fARB(index: UInt32; x: single; y: single; z: single);
    external 'opengl32.dll' name 'glVertexAttrib3fARB';
    
    static procedure VertexAttrib3fvARB(index: UInt32; v: ^single);
    external 'opengl32.dll' name 'glVertexAttrib3fvARB';
    
    static procedure VertexAttrib3sARB(index: UInt32; x: Int16; y: Int16; z: Int16);
    external 'opengl32.dll' name 'glVertexAttrib3sARB';
    
    static procedure VertexAttrib3svARB(index: UInt32; v: ^Int16);
    external 'opengl32.dll' name 'glVertexAttrib3svARB';
    
    static procedure VertexAttrib4NbvARB(index: UInt32; v: ^SByte);
    external 'opengl32.dll' name 'glVertexAttrib4NbvARB';
    
    static procedure VertexAttrib4NivARB(index: UInt32; v: ^Int32);
    external 'opengl32.dll' name 'glVertexAttrib4NivARB';
    
    static procedure VertexAttrib4NsvARB(index: UInt32; v: ^Int16);
    external 'opengl32.dll' name 'glVertexAttrib4NsvARB';
    
    static procedure VertexAttrib4NubARB(index: UInt32; x: Byte; y: Byte; z: Byte; w: Byte);
    external 'opengl32.dll' name 'glVertexAttrib4NubARB';
    
    static procedure VertexAttrib4NubvARB(index: UInt32; v: ^Byte);
    external 'opengl32.dll' name 'glVertexAttrib4NubvARB';
    
    static procedure VertexAttrib4NuivARB(index: UInt32; v: ^UInt32);
    external 'opengl32.dll' name 'glVertexAttrib4NuivARB';
    
    static procedure VertexAttrib4NusvARB(index: UInt32; v: ^UInt16);
    external 'opengl32.dll' name 'glVertexAttrib4NusvARB';
    
    static procedure VertexAttrib4bvARB(index: UInt32; v: ^SByte);
    external 'opengl32.dll' name 'glVertexAttrib4bvARB';
    
    static procedure VertexAttrib4dARB(index: UInt32; x: double; y: double; z: double; w: double);
    external 'opengl32.dll' name 'glVertexAttrib4dARB';
    
    static procedure VertexAttrib4dvARB(index: UInt32; v: ^double);
    external 'opengl32.dll' name 'glVertexAttrib4dvARB';
    
    static procedure VertexAttrib4fARB(index: UInt32; x: single; y: single; z: single; w: single);
    external 'opengl32.dll' name 'glVertexAttrib4fARB';
    
    static procedure VertexAttrib4fvARB(index: UInt32; v: ^single);
    external 'opengl32.dll' name 'glVertexAttrib4fvARB';
    
    static procedure VertexAttrib4ivARB(index: UInt32; v: ^Int32);
    external 'opengl32.dll' name 'glVertexAttrib4ivARB';
    
    static procedure VertexAttrib4sARB(index: UInt32; x: Int16; y: Int16; z: Int16; w: Int16);
    external 'opengl32.dll' name 'glVertexAttrib4sARB';
    
    static procedure VertexAttrib4svARB(index: UInt32; v: ^Int16);
    external 'opengl32.dll' name 'glVertexAttrib4svARB';
    
    static procedure VertexAttrib4ubvARB(index: UInt32; v: ^Byte);
    external 'opengl32.dll' name 'glVertexAttrib4ubvARB';
    
    static procedure VertexAttrib4uivARB(index: UInt32; v: ^UInt32);
    external 'opengl32.dll' name 'glVertexAttrib4uivARB';
    
    static procedure VertexAttrib4usvARB(index: UInt32; v: ^UInt16);
    external 'opengl32.dll' name 'glVertexAttrib4usvARB';
    
    static procedure VertexAttribPointerARB(index: UInt32; size: Int32; &type: ErrorCode; normalized: Byte; stride: Int32; _pointer: pointer);
    external 'opengl32.dll' name 'glVertexAttribPointerARB';
    
    static procedure EnableVertexAttribArrayARB(index: UInt32);
    external 'opengl32.dll' name 'glEnableVertexAttribArrayARB';
    
    static procedure DisableVertexAttribArrayARB(index: UInt32);
    external 'opengl32.dll' name 'glDisableVertexAttribArrayARB';
    
    static procedure GetVertexAttribdvARB(index: UInt32; pname: ErrorCode; &params: ^double);
    external 'opengl32.dll' name 'glGetVertexAttribdvARB';
    
    static procedure GetVertexAttribfvARB(index: UInt32; pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glGetVertexAttribfvARB';
    
    static procedure GetVertexAttribivARB(index: UInt32; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetVertexAttribivARB';
    
    static procedure GetVertexAttribPointervARB(index: UInt32; pname: ErrorCode; _pointer: ^pointer);
    external 'opengl32.dll' name 'glGetVertexAttribPointervARB';
    
    static procedure BindAttribLocationARB(programObj: GLhandleARB; index: UInt32; name: ^Byte);
    external 'opengl32.dll' name 'glBindAttribLocationARB';
    
    static procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: ^Int32; size: ^Int32; &type: ^ErrorCode; name: ^Byte);
    external 'opengl32.dll' name 'glGetActiveAttribARB';
    
    static function GetAttribLocationARB(programObj: GLhandleARB; name: ^Byte): Int32;
    external 'opengl32.dll' name 'glGetAttribLocationARB';
    
    static procedure WindowPos2dARB(x: double; y: double);
    external 'opengl32.dll' name 'glWindowPos2dARB';
    
    static procedure WindowPos2dvARB(v: ^double);
    external 'opengl32.dll' name 'glWindowPos2dvARB';
    
    static procedure WindowPos2fARB(x: single; y: single);
    external 'opengl32.dll' name 'glWindowPos2fARB';
    
    static procedure WindowPos2fvARB(v: ^single);
    external 'opengl32.dll' name 'glWindowPos2fvARB';
    
    static procedure WindowPos2iARB(x: Int32; y: Int32);
    external 'opengl32.dll' name 'glWindowPos2iARB';
    
    static procedure WindowPos2ivARB(v: ^Int32);
    external 'opengl32.dll' name 'glWindowPos2ivARB';
    
    static procedure WindowPos2sARB(x: Int16; y: Int16);
    external 'opengl32.dll' name 'glWindowPos2sARB';
    
    static procedure WindowPos2svARB(v: ^Int16);
    external 'opengl32.dll' name 'glWindowPos2svARB';
    
    static procedure WindowPos3dARB(x: double; y: double; z: double);
    external 'opengl32.dll' name 'glWindowPos3dARB';
    
    static procedure WindowPos3dvARB(v: ^double);
    external 'opengl32.dll' name 'glWindowPos3dvARB';
    
    static procedure WindowPos3fARB(x: single; y: single; z: single);
    external 'opengl32.dll' name 'glWindowPos3fARB';
    
    static procedure WindowPos3fvARB(v: ^single);
    external 'opengl32.dll' name 'glWindowPos3fvARB';
    
    static procedure WindowPos3iARB(x: Int32; y: Int32; z: Int32);
    external 'opengl32.dll' name 'glWindowPos3iARB';
    
    static procedure WindowPos3ivARB(v: ^Int32);
    external 'opengl32.dll' name 'glWindowPos3ivARB';
    
    static procedure WindowPos3sARB(x: Int16; y: Int16; z: Int16);
    external 'opengl32.dll' name 'glWindowPos3sARB';
    
    static procedure WindowPos3svARB(v: ^Int16);
    external 'opengl32.dll' name 'glWindowPos3svARB';
    
    {$endregion ARB}
    
  end;
  
  /// Расширения, которые встречаются у многих видеокарт
  gl_EXT = static class
    
    {$region EXT}
    
    static procedure NamedBufferPageCommitmentEXT(buffer: UInt32; offset: IntPtr; size: UIntPtr; commit: boolean);
    external 'opengl32.dll' name 'glNamedBufferPageCommitmentEXT';
    
    static procedure EGLImageTargetTexStorageEXT(target: UInt32; image: GLeglImageOES; attrib_list: ^Int32);
    external 'opengl32.dll' name 'glEGLImageTargetTexStorageEXT';
    
    static procedure EGLImageTargetTextureStorageEXT(texture: UInt32; image: GLeglImageOES; attrib_list: ^Int32);
    external 'opengl32.dll' name 'glEGLImageTargetTextureStorageEXT';
    
    static procedure LabelObjectEXT(&type: UInt32; object: UInt32; length: Int32; &label: ^SByte);
    external 'opengl32.dll' name 'glLabelObjectEXT';
    
    static procedure GetObjectLabelEXT(&type: UInt32; object: UInt32; bufSize: Int32; length: ^Int32; &label: ^SByte);
    external 'opengl32.dll' name 'glGetObjectLabelEXT';
    
    static procedure InsertEventMarkerEXT(length: Int32; marker: ^SByte);
    external 'opengl32.dll' name 'glInsertEventMarkerEXT';
    
    static procedure PushGroupMarkerEXT(length: Int32; marker: ^SByte);
    external 'opengl32.dll' name 'glPushGroupMarkerEXT';
    
    static procedure PopGroupMarkerEXT;
    external 'opengl32.dll' name 'glPopGroupMarkerEXT';
    
    static procedure MatrixLoadfEXT(mode: UInt32; m: ^single);
    external 'opengl32.dll' name 'glMatrixLoadfEXT';
    
    static procedure MatrixLoaddEXT(mode: UInt32; m: ^double);
    external 'opengl32.dll' name 'glMatrixLoaddEXT';
    
    static procedure MatrixMultfEXT(mode: UInt32; m: ^single);
    external 'opengl32.dll' name 'glMatrixMultfEXT';
    
    static procedure MatrixMultdEXT(mode: UInt32; m: ^double);
    external 'opengl32.dll' name 'glMatrixMultdEXT';
    
    static procedure MatrixLoadIdentityEXT(mode: UInt32);
    external 'opengl32.dll' name 'glMatrixLoadIdentityEXT';
    
    static procedure MatrixRotatefEXT(mode: UInt32; angle: single; x: single; y: single; z: single);
    external 'opengl32.dll' name 'glMatrixRotatefEXT';
    
    static procedure MatrixRotatedEXT(mode: UInt32; angle: double; x: double; y: double; z: double);
    external 'opengl32.dll' name 'glMatrixRotatedEXT';
    
    static procedure MatrixScalefEXT(mode: UInt32; x: single; y: single; z: single);
    external 'opengl32.dll' name 'glMatrixScalefEXT';
    
    static procedure MatrixScaledEXT(mode: UInt32; x: double; y: double; z: double);
    external 'opengl32.dll' name 'glMatrixScaledEXT';
    
    static procedure MatrixTranslatefEXT(mode: UInt32; x: single; y: single; z: single);
    external 'opengl32.dll' name 'glMatrixTranslatefEXT';
    
    static procedure MatrixTranslatedEXT(mode: UInt32; x: double; y: double; z: double);
    external 'opengl32.dll' name 'glMatrixTranslatedEXT';
    
    static procedure MatrixFrustumEXT(mode: UInt32; left: double; right: double; bottom: double; top: double; zNear: double; zFar: double);
    external 'opengl32.dll' name 'glMatrixFrustumEXT';
    
    static procedure MatrixOrthoEXT(mode: UInt32; left: double; right: double; bottom: double; top: double; zNear: double; zFar: double);
    external 'opengl32.dll' name 'glMatrixOrthoEXT';
    
    static procedure MatrixPopEXT(mode: UInt32);
    external 'opengl32.dll' name 'glMatrixPopEXT';
    
    static procedure MatrixPushEXT(mode: UInt32);
    external 'opengl32.dll' name 'glMatrixPushEXT';
    
    static procedure ClientAttribDefaultEXT(mask: UInt32);
    external 'opengl32.dll' name 'glClientAttribDefaultEXT';
    
    static procedure PushClientAttribDefaultEXT(mask: UInt32);
    external 'opengl32.dll' name 'glPushClientAttribDefaultEXT';
    
    static procedure TextureParameterfEXT(texture: UInt32; target: UInt32; pname: UInt32; param: single);
    external 'opengl32.dll' name 'glTextureParameterfEXT';
    
    static procedure TextureParameterfvEXT(texture: UInt32; target: UInt32; pname: UInt32; &params: ^single);
    external 'opengl32.dll' name 'glTextureParameterfvEXT';
    
    static procedure TextureParameteriEXT(texture: UInt32; target: UInt32; pname: UInt32; param: Int32);
    external 'opengl32.dll' name 'glTextureParameteriEXT';
    
    static procedure TextureParameterivEXT(texture: UInt32; target: UInt32; pname: UInt32; &params: ^Int32);
    external 'opengl32.dll' name 'glTextureParameterivEXT';
    
    static procedure TextureImage1DEXT(texture: UInt32; target: UInt32; level: Int32; internalformat: Int32; width: Int32; border: Int32; format: UInt32; &type: UInt32; pixels: pointer);
    external 'opengl32.dll' name 'glTextureImage1DEXT';
    
    static procedure TextureImage2DEXT(texture: UInt32; target: UInt32; level: Int32; internalformat: Int32; width: Int32; height: Int32; border: Int32; format: UInt32; &type: UInt32; pixels: pointer);
    external 'opengl32.dll' name 'glTextureImage2DEXT';
    
    static procedure TextureSubImage1DEXT(texture: UInt32; target: UInt32; level: Int32; xoffset: Int32; width: Int32; format: UInt32; &type: UInt32; pixels: pointer);
    external 'opengl32.dll' name 'glTextureSubImage1DEXT';
    
    static procedure TextureSubImage2DEXT(texture: UInt32; target: UInt32; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: UInt32; &type: UInt32; pixels: pointer);
    external 'opengl32.dll' name 'glTextureSubImage2DEXT';
    
    static procedure CopyTextureImage1DEXT(texture: UInt32; target: UInt32; level: Int32; internalformat: UInt32; x: Int32; y: Int32; width: Int32; border: Int32);
    external 'opengl32.dll' name 'glCopyTextureImage1DEXT';
    
    static procedure CopyTextureImage2DEXT(texture: UInt32; target: UInt32; level: Int32; internalformat: UInt32; x: Int32; y: Int32; width: Int32; height: Int32; border: Int32);
    external 'opengl32.dll' name 'glCopyTextureImage2DEXT';
    
    static procedure CopyTextureSubImage1DEXT(texture: UInt32; target: UInt32; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32);
    external 'opengl32.dll' name 'glCopyTextureSubImage1DEXT';
    
    static procedure CopyTextureSubImage2DEXT(texture: UInt32; target: UInt32; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glCopyTextureSubImage2DEXT';
    
    static procedure GetTextureImageEXT(texture: UInt32; target: UInt32; level: Int32; format: UInt32; &type: UInt32; pixels: pointer);
    external 'opengl32.dll' name 'glGetTextureImageEXT';
    
    static procedure GetTextureParameterfvEXT(texture: UInt32; target: UInt32; pname: UInt32; &params: ^single);
    external 'opengl32.dll' name 'glGetTextureParameterfvEXT';
    
    static procedure GetTextureParameterivEXT(texture: UInt32; target: UInt32; pname: UInt32; &params: ^Int32);
    external 'opengl32.dll' name 'glGetTextureParameterivEXT';
    
    static procedure GetTextureLevelParameterfvEXT(texture: UInt32; target: UInt32; level: Int32; pname: UInt32; &params: ^single);
    external 'opengl32.dll' name 'glGetTextureLevelParameterfvEXT';
    
    static procedure GetTextureLevelParameterivEXT(texture: UInt32; target: UInt32; level: Int32; pname: UInt32; &params: ^Int32);
    external 'opengl32.dll' name 'glGetTextureLevelParameterivEXT';
    
    static procedure TextureImage3DEXT(texture: UInt32; target: UInt32; level: Int32; internalformat: Int32; width: Int32; height: Int32; depth: Int32; border: Int32; format: UInt32; &type: UInt32; pixels: pointer);
    external 'opengl32.dll' name 'glTextureImage3DEXT';
    
    static procedure TextureSubImage3DEXT(texture: UInt32; target: UInt32; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: UInt32; &type: UInt32; pixels: pointer);
    external 'opengl32.dll' name 'glTextureSubImage3DEXT';
    
    static procedure CopyTextureSubImage3DEXT(texture: UInt32; target: UInt32; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glCopyTextureSubImage3DEXT';
    
    static procedure BindMultiTextureEXT(texunit: UInt32; target: UInt32; texture: UInt32);
    external 'opengl32.dll' name 'glBindMultiTextureEXT';
    
    static procedure MultiTexCoordPointerEXT(texunit: UInt32; size: Int32; &type: UInt32; stride: Int32; _pointer: pointer);
    external 'opengl32.dll' name 'glMultiTexCoordPointerEXT';
    
    static procedure MultiTexEnvfEXT(texunit: UInt32; target: UInt32; pname: UInt32; param: single);
    external 'opengl32.dll' name 'glMultiTexEnvfEXT';
    
    static procedure MultiTexEnvfvEXT(texunit: UInt32; target: UInt32; pname: UInt32; &params: ^single);
    external 'opengl32.dll' name 'glMultiTexEnvfvEXT';
    
    static procedure MultiTexEnviEXT(texunit: UInt32; target: UInt32; pname: UInt32; param: Int32);
    external 'opengl32.dll' name 'glMultiTexEnviEXT';
    
    static procedure MultiTexEnvivEXT(texunit: UInt32; target: UInt32; pname: UInt32; &params: ^Int32);
    external 'opengl32.dll' name 'glMultiTexEnvivEXT';
    
    static procedure MultiTexGendEXT(texunit: UInt32; coord: UInt32; pname: UInt32; param: double);
    external 'opengl32.dll' name 'glMultiTexGendEXT';
    
    static procedure MultiTexGendvEXT(texunit: UInt32; coord: UInt32; pname: UInt32; &params: ^double);
    external 'opengl32.dll' name 'glMultiTexGendvEXT';
    
    static procedure MultiTexGenfEXT(texunit: UInt32; coord: UInt32; pname: UInt32; param: single);
    external 'opengl32.dll' name 'glMultiTexGenfEXT';
    
    static procedure MultiTexGenfvEXT(texunit: UInt32; coord: UInt32; pname: UInt32; &params: ^single);
    external 'opengl32.dll' name 'glMultiTexGenfvEXT';
    
    static procedure MultiTexGeniEXT(texunit: UInt32; coord: UInt32; pname: UInt32; param: Int32);
    external 'opengl32.dll' name 'glMultiTexGeniEXT';
    
    static procedure MultiTexGenivEXT(texunit: UInt32; coord: UInt32; pname: UInt32; &params: ^Int32);
    external 'opengl32.dll' name 'glMultiTexGenivEXT';
    
    static procedure GetMultiTexEnvfvEXT(texunit: UInt32; target: UInt32; pname: UInt32; &params: ^single);
    external 'opengl32.dll' name 'glGetMultiTexEnvfvEXT';
    
    static procedure GetMultiTexEnvivEXT(texunit: UInt32; target: UInt32; pname: UInt32; &params: ^Int32);
    external 'opengl32.dll' name 'glGetMultiTexEnvivEXT';
    
    static procedure GetMultiTexGendvEXT(texunit: UInt32; coord: UInt32; pname: UInt32; &params: ^double);
    external 'opengl32.dll' name 'glGetMultiTexGendvEXT';
    
    static procedure GetMultiTexGenfvEXT(texunit: UInt32; coord: UInt32; pname: UInt32; &params: ^single);
    external 'opengl32.dll' name 'glGetMultiTexGenfvEXT';
    
    static procedure GetMultiTexGenivEXT(texunit: UInt32; coord: UInt32; pname: UInt32; &params: ^Int32);
    external 'opengl32.dll' name 'glGetMultiTexGenivEXT';
    
    static procedure MultiTexParameteriEXT(texunit: UInt32; target: UInt32; pname: UInt32; param: Int32);
    external 'opengl32.dll' name 'glMultiTexParameteriEXT';
    
    static procedure MultiTexParameterivEXT(texunit: UInt32; target: UInt32; pname: UInt32; &params: ^Int32);
    external 'opengl32.dll' name 'glMultiTexParameterivEXT';
    
    static procedure MultiTexParameterfEXT(texunit: UInt32; target: UInt32; pname: UInt32; param: single);
    external 'opengl32.dll' name 'glMultiTexParameterfEXT';
    
    static procedure MultiTexParameterfvEXT(texunit: UInt32; target: UInt32; pname: UInt32; &params: ^single);
    external 'opengl32.dll' name 'glMultiTexParameterfvEXT';
    
    static procedure MultiTexImage1DEXT(texunit: UInt32; target: UInt32; level: Int32; internalformat: Int32; width: Int32; border: Int32; format: UInt32; &type: UInt32; pixels: pointer);
    external 'opengl32.dll' name 'glMultiTexImage1DEXT';
    
    static procedure MultiTexImage2DEXT(texunit: UInt32; target: UInt32; level: Int32; internalformat: Int32; width: Int32; height: Int32; border: Int32; format: UInt32; &type: UInt32; pixels: pointer);
    external 'opengl32.dll' name 'glMultiTexImage2DEXT';
    
    static procedure MultiTexSubImage1DEXT(texunit: UInt32; target: UInt32; level: Int32; xoffset: Int32; width: Int32; format: UInt32; &type: UInt32; pixels: pointer);
    external 'opengl32.dll' name 'glMultiTexSubImage1DEXT';
    
    static procedure MultiTexSubImage2DEXT(texunit: UInt32; target: UInt32; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: UInt32; &type: UInt32; pixels: pointer);
    external 'opengl32.dll' name 'glMultiTexSubImage2DEXT';
    
    static procedure CopyMultiTexImage1DEXT(texunit: UInt32; target: UInt32; level: Int32; internalformat: UInt32; x: Int32; y: Int32; width: Int32; border: Int32);
    external 'opengl32.dll' name 'glCopyMultiTexImage1DEXT';
    
    static procedure CopyMultiTexImage2DEXT(texunit: UInt32; target: UInt32; level: Int32; internalformat: UInt32; x: Int32; y: Int32; width: Int32; height: Int32; border: Int32);
    external 'opengl32.dll' name 'glCopyMultiTexImage2DEXT';
    
    static procedure CopyMultiTexSubImage1DEXT(texunit: UInt32; target: UInt32; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32);
    external 'opengl32.dll' name 'glCopyMultiTexSubImage1DEXT';
    
    static procedure CopyMultiTexSubImage2DEXT(texunit: UInt32; target: UInt32; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glCopyMultiTexSubImage2DEXT';
    
    static procedure GetMultiTexImageEXT(texunit: UInt32; target: UInt32; level: Int32; format: UInt32; &type: UInt32; pixels: pointer);
    external 'opengl32.dll' name 'glGetMultiTexImageEXT';
    
    static procedure GetMultiTexParameterfvEXT(texunit: UInt32; target: UInt32; pname: UInt32; &params: ^single);
    external 'opengl32.dll' name 'glGetMultiTexParameterfvEXT';
    
    static procedure GetMultiTexParameterivEXT(texunit: UInt32; target: UInt32; pname: UInt32; &params: ^Int32);
    external 'opengl32.dll' name 'glGetMultiTexParameterivEXT';
    
    static procedure GetMultiTexLevelParameterfvEXT(texunit: UInt32; target: UInt32; level: Int32; pname: UInt32; &params: ^single);
    external 'opengl32.dll' name 'glGetMultiTexLevelParameterfvEXT';
    
    static procedure GetMultiTexLevelParameterivEXT(texunit: UInt32; target: UInt32; level: Int32; pname: UInt32; &params: ^Int32);
    external 'opengl32.dll' name 'glGetMultiTexLevelParameterivEXT';
    
    static procedure MultiTexImage3DEXT(texunit: UInt32; target: UInt32; level: Int32; internalformat: Int32; width: Int32; height: Int32; depth: Int32; border: Int32; format: UInt32; &type: UInt32; pixels: pointer);
    external 'opengl32.dll' name 'glMultiTexImage3DEXT';
    
    static procedure MultiTexSubImage3DEXT(texunit: UInt32; target: UInt32; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: UInt32; &type: UInt32; pixels: pointer);
    external 'opengl32.dll' name 'glMultiTexSubImage3DEXT';
    
    static procedure CopyMultiTexSubImage3DEXT(texunit: UInt32; target: UInt32; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glCopyMultiTexSubImage3DEXT';
    
    static procedure EnableClientStateIndexedEXT(&array: UInt32; index: UInt32);
    external 'opengl32.dll' name 'glEnableClientStateIndexedEXT';
    
    static procedure DisableClientStateIndexedEXT(&array: UInt32; index: UInt32);
    external 'opengl32.dll' name 'glDisableClientStateIndexedEXT';
    
    static procedure GetFloatIndexedvEXT(target: UInt32; index: UInt32; data: ^single);
    external 'opengl32.dll' name 'glGetFloatIndexedvEXT';
    
    static procedure GetDoubleIndexedvEXT(target: UInt32; index: UInt32; data: ^double);
    external 'opengl32.dll' name 'glGetDoubleIndexedvEXT';
    
    static procedure GetPointerIndexedvEXT(target: UInt32; index: UInt32; data: ^IntPtr);
    external 'opengl32.dll' name 'glGetPointerIndexedvEXT';
    
    static procedure EnableIndexedEXT(target: UInt32; index: UInt32);
    external 'opengl32.dll' name 'glEnableIndexedEXT';
    
    static procedure DisableIndexedEXT(target: UInt32; index: UInt32);
    external 'opengl32.dll' name 'glDisableIndexedEXT';
    
    static function IsEnabledIndexedEXT(target: UInt32; index: UInt32): boolean;
    external 'opengl32.dll' name 'glIsEnabledIndexedEXT';
    
    static procedure GetIntegerIndexedvEXT(target: UInt32; index: UInt32; data: ^Int32);
    external 'opengl32.dll' name 'glGetIntegerIndexedvEXT';
    
    static procedure GetBooleanIndexedvEXT(target: UInt32; index: UInt32; data: ^boolean);
    external 'opengl32.dll' name 'glGetBooleanIndexedvEXT';
    
    static procedure CompressedTextureImage3DEXT(texture: UInt32; target: UInt32; level: Int32; internalformat: UInt32; width: Int32; height: Int32; depth: Int32; border: Int32; imageSize: Int32; bits: pointer);
    external 'opengl32.dll' name 'glCompressedTextureImage3DEXT';
    
    static procedure CompressedTextureImage2DEXT(texture: UInt32; target: UInt32; level: Int32; internalformat: UInt32; width: Int32; height: Int32; border: Int32; imageSize: Int32; bits: pointer);
    external 'opengl32.dll' name 'glCompressedTextureImage2DEXT';
    
    static procedure CompressedTextureImage1DEXT(texture: UInt32; target: UInt32; level: Int32; internalformat: UInt32; width: Int32; border: Int32; imageSize: Int32; bits: pointer);
    external 'opengl32.dll' name 'glCompressedTextureImage1DEXT';
    
    static procedure CompressedTextureSubImage3DEXT(texture: UInt32; target: UInt32; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: UInt32; imageSize: Int32; bits: pointer);
    external 'opengl32.dll' name 'glCompressedTextureSubImage3DEXT';
    
    static procedure CompressedTextureSubImage2DEXT(texture: UInt32; target: UInt32; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: UInt32; imageSize: Int32; bits: pointer);
    external 'opengl32.dll' name 'glCompressedTextureSubImage2DEXT';
    
    static procedure CompressedTextureSubImage1DEXT(texture: UInt32; target: UInt32; level: Int32; xoffset: Int32; width: Int32; format: UInt32; imageSize: Int32; bits: pointer);
    external 'opengl32.dll' name 'glCompressedTextureSubImage1DEXT';
    
    static procedure GetCompressedTextureImageEXT(texture: UInt32; target: UInt32; lod: Int32; img: pointer);
    external 'opengl32.dll' name 'glGetCompressedTextureImageEXT';
    
    static procedure CompressedMultiTexImage3DEXT(texunit: UInt32; target: UInt32; level: Int32; internalformat: UInt32; width: Int32; height: Int32; depth: Int32; border: Int32; imageSize: Int32; bits: pointer);
    external 'opengl32.dll' name 'glCompressedMultiTexImage3DEXT';
    
    static procedure CompressedMultiTexImage2DEXT(texunit: UInt32; target: UInt32; level: Int32; internalformat: UInt32; width: Int32; height: Int32; border: Int32; imageSize: Int32; bits: pointer);
    external 'opengl32.dll' name 'glCompressedMultiTexImage2DEXT';
    
    static procedure CompressedMultiTexImage1DEXT(texunit: UInt32; target: UInt32; level: Int32; internalformat: UInt32; width: Int32; border: Int32; imageSize: Int32; bits: pointer);
    external 'opengl32.dll' name 'glCompressedMultiTexImage1DEXT';
    
    static procedure CompressedMultiTexSubImage3DEXT(texunit: UInt32; target: UInt32; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: UInt32; imageSize: Int32; bits: pointer);
    external 'opengl32.dll' name 'glCompressedMultiTexSubImage3DEXT';
    
    static procedure CompressedMultiTexSubImage2DEXT(texunit: UInt32; target: UInt32; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: UInt32; imageSize: Int32; bits: pointer);
    external 'opengl32.dll' name 'glCompressedMultiTexSubImage2DEXT';
    
    static procedure CompressedMultiTexSubImage1DEXT(texunit: UInt32; target: UInt32; level: Int32; xoffset: Int32; width: Int32; format: UInt32; imageSize: Int32; bits: pointer);
    external 'opengl32.dll' name 'glCompressedMultiTexSubImage1DEXT';
    
    static procedure GetCompressedMultiTexImageEXT(texunit: UInt32; target: UInt32; lod: Int32; img: pointer);
    external 'opengl32.dll' name 'glGetCompressedMultiTexImageEXT';
    
    static procedure MatrixLoadTransposefEXT(mode: UInt32; m: ^single);
    external 'opengl32.dll' name 'glMatrixLoadTransposefEXT';
    
    static procedure MatrixLoadTransposedEXT(mode: UInt32; m: ^double);
    external 'opengl32.dll' name 'glMatrixLoadTransposedEXT';
    
    static procedure MatrixMultTransposefEXT(mode: UInt32; m: ^single);
    external 'opengl32.dll' name 'glMatrixMultTransposefEXT';
    
    static procedure MatrixMultTransposedEXT(mode: UInt32; m: ^double);
    external 'opengl32.dll' name 'glMatrixMultTransposedEXT';
    
    static procedure NamedBufferDataEXT(buffer: UInt32; size: UIntPtr; data: pointer; usage: UInt32);
    external 'opengl32.dll' name 'glNamedBufferDataEXT';
    
    static procedure NamedBufferSubDataEXT(buffer: UInt32; offset: IntPtr; size: UIntPtr; data: pointer);
    external 'opengl32.dll' name 'glNamedBufferSubDataEXT';
    
    static function MapNamedBufferEXT(buffer: UInt32; access: UInt32): pointer;
    external 'opengl32.dll' name 'glMapNamedBufferEXT';
    
    static function UnmapNamedBufferEXT(buffer: UInt32): boolean;
    external 'opengl32.dll' name 'glUnmapNamedBufferEXT';
    
    static procedure GetNamedBufferParameterivEXT(buffer: UInt32; pname: UInt32; &params: ^Int32);
    external 'opengl32.dll' name 'glGetNamedBufferParameterivEXT';
    
    static procedure GetNamedBufferPointervEXT(buffer: UInt32; pname: UInt32; &params: ^IntPtr);
    external 'opengl32.dll' name 'glGetNamedBufferPointervEXT';
    
    static procedure GetNamedBufferSubDataEXT(buffer: UInt32; offset: IntPtr; size: UIntPtr; data: pointer);
    external 'opengl32.dll' name 'glGetNamedBufferSubDataEXT';
    
    static procedure ProgramUniform1fEXT(&program: UInt32; location: Int32; v0: single);
    external 'opengl32.dll' name 'glProgramUniform1fEXT';
    
    static procedure ProgramUniform2fEXT(&program: UInt32; location: Int32; v0: single; v1: single);
    external 'opengl32.dll' name 'glProgramUniform2fEXT';
    
    static procedure ProgramUniform3fEXT(&program: UInt32; location: Int32; v0: single; v1: single; v2: single);
    external 'opengl32.dll' name 'glProgramUniform3fEXT';
    
    static procedure ProgramUniform4fEXT(&program: UInt32; location: Int32; v0: single; v1: single; v2: single; v3: single);
    external 'opengl32.dll' name 'glProgramUniform4fEXT';
    
    static procedure ProgramUniform1iEXT(&program: UInt32; location: Int32; v0: Int32);
    external 'opengl32.dll' name 'glProgramUniform1iEXT';
    
    static procedure ProgramUniform2iEXT(&program: UInt32; location: Int32; v0: Int32; v1: Int32);
    external 'opengl32.dll' name 'glProgramUniform2iEXT';
    
    static procedure ProgramUniform3iEXT(&program: UInt32; location: Int32; v0: Int32; v1: Int32; v2: Int32);
    external 'opengl32.dll' name 'glProgramUniform3iEXT';
    
    static procedure ProgramUniform4iEXT(&program: UInt32; location: Int32; v0: Int32; v1: Int32; v2: Int32; v3: Int32);
    external 'opengl32.dll' name 'glProgramUniform4iEXT';
    
    static procedure ProgramUniform1fvEXT(&program: UInt32; location: Int32; count: Int32; value: ^single);
    external 'opengl32.dll' name 'glProgramUniform1fvEXT';
    
    static procedure ProgramUniform2fvEXT(&program: UInt32; location: Int32; count: Int32; value: ^single);
    external 'opengl32.dll' name 'glProgramUniform2fvEXT';
    
    static procedure ProgramUniform3fvEXT(&program: UInt32; location: Int32; count: Int32; value: ^single);
    external 'opengl32.dll' name 'glProgramUniform3fvEXT';
    
    static procedure ProgramUniform4fvEXT(&program: UInt32; location: Int32; count: Int32; value: ^single);
    external 'opengl32.dll' name 'glProgramUniform4fvEXT';
    
    static procedure ProgramUniform1ivEXT(&program: UInt32; location: Int32; count: Int32; value: ^Int32);
    external 'opengl32.dll' name 'glProgramUniform1ivEXT';
    
    static procedure ProgramUniform2ivEXT(&program: UInt32; location: Int32; count: Int32; value: ^Int32);
    external 'opengl32.dll' name 'glProgramUniform2ivEXT';
    
    static procedure ProgramUniform3ivEXT(&program: UInt32; location: Int32; count: Int32; value: ^Int32);
    external 'opengl32.dll' name 'glProgramUniform3ivEXT';
    
    static procedure ProgramUniform4ivEXT(&program: UInt32; location: Int32; count: Int32; value: ^Int32);
    external 'opengl32.dll' name 'glProgramUniform4ivEXT';
    
    static procedure ProgramUniformMatrix2fvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: ^single);
    external 'opengl32.dll' name 'glProgramUniformMatrix2fvEXT';
    
    static procedure ProgramUniformMatrix3fvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: ^single);
    external 'opengl32.dll' name 'glProgramUniformMatrix3fvEXT';
    
    static procedure ProgramUniformMatrix4fvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: ^single);
    external 'opengl32.dll' name 'glProgramUniformMatrix4fvEXT';
    
    static procedure ProgramUniformMatrix2x3fvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: ^single);
    external 'opengl32.dll' name 'glProgramUniformMatrix2x3fvEXT';
    
    static procedure ProgramUniformMatrix3x2fvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: ^single);
    external 'opengl32.dll' name 'glProgramUniformMatrix3x2fvEXT';
    
    static procedure ProgramUniformMatrix2x4fvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: ^single);
    external 'opengl32.dll' name 'glProgramUniformMatrix2x4fvEXT';
    
    static procedure ProgramUniformMatrix4x2fvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: ^single);
    external 'opengl32.dll' name 'glProgramUniformMatrix4x2fvEXT';
    
    static procedure ProgramUniformMatrix3x4fvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: ^single);
    external 'opengl32.dll' name 'glProgramUniformMatrix3x4fvEXT';
    
    static procedure ProgramUniformMatrix4x3fvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: ^single);
    external 'opengl32.dll' name 'glProgramUniformMatrix4x3fvEXT';
    
    static procedure TextureBufferEXT(texture: UInt32; target: UInt32; internalformat: UInt32; buffer: UInt32);
    external 'opengl32.dll' name 'glTextureBufferEXT';
    
    static procedure MultiTexBufferEXT(texunit: UInt32; target: UInt32; internalformat: UInt32; buffer: UInt32);
    external 'opengl32.dll' name 'glMultiTexBufferEXT';
    
    static procedure TextureParameterIivEXT(texture: UInt32; target: UInt32; pname: UInt32; &params: ^Int32);
    external 'opengl32.dll' name 'glTextureParameterIivEXT';
    
    static procedure TextureParameterIuivEXT(texture: UInt32; target: UInt32; pname: UInt32; &params: ^UInt32);
    external 'opengl32.dll' name 'glTextureParameterIuivEXT';
    
    static procedure GetTextureParameterIivEXT(texture: UInt32; target: UInt32; pname: UInt32; &params: ^Int32);
    external 'opengl32.dll' name 'glGetTextureParameterIivEXT';
    
    static procedure GetTextureParameterIuivEXT(texture: UInt32; target: UInt32; pname: UInt32; &params: ^UInt32);
    external 'opengl32.dll' name 'glGetTextureParameterIuivEXT';
    
    static procedure MultiTexParameterIivEXT(texunit: UInt32; target: UInt32; pname: UInt32; &params: ^Int32);
    external 'opengl32.dll' name 'glMultiTexParameterIivEXT';
    
    static procedure MultiTexParameterIuivEXT(texunit: UInt32; target: UInt32; pname: UInt32; &params: ^UInt32);
    external 'opengl32.dll' name 'glMultiTexParameterIuivEXT';
    
    static procedure GetMultiTexParameterIivEXT(texunit: UInt32; target: UInt32; pname: UInt32; &params: ^Int32);
    external 'opengl32.dll' name 'glGetMultiTexParameterIivEXT';
    
    static procedure GetMultiTexParameterIuivEXT(texunit: UInt32; target: UInt32; pname: UInt32; &params: ^UInt32);
    external 'opengl32.dll' name 'glGetMultiTexParameterIuivEXT';
    
    static procedure ProgramUniform1uiEXT(&program: UInt32; location: Int32; v0: UInt32);
    external 'opengl32.dll' name 'glProgramUniform1uiEXT';
    
    static procedure ProgramUniform2uiEXT(&program: UInt32; location: Int32; v0: UInt32; v1: UInt32);
    external 'opengl32.dll' name 'glProgramUniform2uiEXT';
    
    static procedure ProgramUniform3uiEXT(&program: UInt32; location: Int32; v0: UInt32; v1: UInt32; v2: UInt32);
    external 'opengl32.dll' name 'glProgramUniform3uiEXT';
    
    static procedure ProgramUniform4uiEXT(&program: UInt32; location: Int32; v0: UInt32; v1: UInt32; v2: UInt32; v3: UInt32);
    external 'opengl32.dll' name 'glProgramUniform4uiEXT';
    
    static procedure ProgramUniform1uivEXT(&program: UInt32; location: Int32; count: Int32; value: ^UInt32);
    external 'opengl32.dll' name 'glProgramUniform1uivEXT';
    
    static procedure ProgramUniform2uivEXT(&program: UInt32; location: Int32; count: Int32; value: ^UInt32);
    external 'opengl32.dll' name 'glProgramUniform2uivEXT';
    
    static procedure ProgramUniform3uivEXT(&program: UInt32; location: Int32; count: Int32; value: ^UInt32);
    external 'opengl32.dll' name 'glProgramUniform3uivEXT';
    
    static procedure ProgramUniform4uivEXT(&program: UInt32; location: Int32; count: Int32; value: ^UInt32);
    external 'opengl32.dll' name 'glProgramUniform4uivEXT';
    
    static procedure NamedProgramLocalParameters4fvEXT(&program: UInt32; target: UInt32; index: UInt32; count: Int32; &params: ^single);
    external 'opengl32.dll' name 'glNamedProgramLocalParameters4fvEXT';
    
    static procedure NamedProgramLocalParameterI4iEXT(&program: UInt32; target: UInt32; index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32);
    external 'opengl32.dll' name 'glNamedProgramLocalParameterI4iEXT';
    
    static procedure NamedProgramLocalParameterI4ivEXT(&program: UInt32; target: UInt32; index: UInt32; &params: ^Int32);
    external 'opengl32.dll' name 'glNamedProgramLocalParameterI4ivEXT';
    
    static procedure NamedProgramLocalParametersI4ivEXT(&program: UInt32; target: UInt32; index: UInt32; count: Int32; &params: ^Int32);
    external 'opengl32.dll' name 'glNamedProgramLocalParametersI4ivEXT';
    
    static procedure NamedProgramLocalParameterI4uiEXT(&program: UInt32; target: UInt32; index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32);
    external 'opengl32.dll' name 'glNamedProgramLocalParameterI4uiEXT';
    
    static procedure NamedProgramLocalParameterI4uivEXT(&program: UInt32; target: UInt32; index: UInt32; &params: ^UInt32);
    external 'opengl32.dll' name 'glNamedProgramLocalParameterI4uivEXT';
    
    static procedure NamedProgramLocalParametersI4uivEXT(&program: UInt32; target: UInt32; index: UInt32; count: Int32; &params: ^UInt32);
    external 'opengl32.dll' name 'glNamedProgramLocalParametersI4uivEXT';
    
    static procedure GetNamedProgramLocalParameterIivEXT(&program: UInt32; target: UInt32; index: UInt32; &params: ^Int32);
    external 'opengl32.dll' name 'glGetNamedProgramLocalParameterIivEXT';
    
    static procedure GetNamedProgramLocalParameterIuivEXT(&program: UInt32; target: UInt32; index: UInt32; &params: ^UInt32);
    external 'opengl32.dll' name 'glGetNamedProgramLocalParameterIuivEXT';
    
    static procedure EnableClientStateiEXT(&array: UInt32; index: UInt32);
    external 'opengl32.dll' name 'glEnableClientStateiEXT';
    
    static procedure DisableClientStateiEXT(&array: UInt32; index: UInt32);
    external 'opengl32.dll' name 'glDisableClientStateiEXT';
    
    static procedure GetFloati_vEXT(pname: UInt32; index: UInt32; &params: ^single);
    external 'opengl32.dll' name 'glGetFloati_vEXT';
    
    static procedure GetDoublei_vEXT(pname: UInt32; index: UInt32; &params: ^double);
    external 'opengl32.dll' name 'glGetDoublei_vEXT';
    
    static procedure GetPointeri_vEXT(pname: UInt32; index: UInt32; &params: ^IntPtr);
    external 'opengl32.dll' name 'glGetPointeri_vEXT';
    
    static procedure NamedProgramStringEXT(&program: UInt32; target: UInt32; format: UInt32; len: Int32; string: pointer);
    external 'opengl32.dll' name 'glNamedProgramStringEXT';
    
    static procedure NamedProgramLocalParameter4dEXT(&program: UInt32; target: UInt32; index: UInt32; x: double; y: double; z: double; w: double);
    external 'opengl32.dll' name 'glNamedProgramLocalParameter4dEXT';
    
    static procedure NamedProgramLocalParameter4dvEXT(&program: UInt32; target: UInt32; index: UInt32; &params: ^double);
    external 'opengl32.dll' name 'glNamedProgramLocalParameter4dvEXT';
    
    static procedure NamedProgramLocalParameter4fEXT(&program: UInt32; target: UInt32; index: UInt32; x: single; y: single; z: single; w: single);
    external 'opengl32.dll' name 'glNamedProgramLocalParameter4fEXT';
    
    static procedure NamedProgramLocalParameter4fvEXT(&program: UInt32; target: UInt32; index: UInt32; &params: ^single);
    external 'opengl32.dll' name 'glNamedProgramLocalParameter4fvEXT';
    
    static procedure GetNamedProgramLocalParameterdvEXT(&program: UInt32; target: UInt32; index: UInt32; &params: ^double);
    external 'opengl32.dll' name 'glGetNamedProgramLocalParameterdvEXT';
    
    static procedure GetNamedProgramLocalParameterfvEXT(&program: UInt32; target: UInt32; index: UInt32; &params: ^single);
    external 'opengl32.dll' name 'glGetNamedProgramLocalParameterfvEXT';
    
    static procedure GetNamedProgramivEXT(&program: UInt32; target: UInt32; pname: UInt32; &params: ^Int32);
    external 'opengl32.dll' name 'glGetNamedProgramivEXT';
    
    static procedure GetNamedProgramStringEXT(&program: UInt32; target: UInt32; pname: UInt32; string: pointer);
    external 'opengl32.dll' name 'glGetNamedProgramStringEXT';
    
    static procedure NamedRenderbufferStorageEXT(renderbuffer: UInt32; internalformat: UInt32; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glNamedRenderbufferStorageEXT';
    
    static procedure GetNamedRenderbufferParameterivEXT(renderbuffer: UInt32; pname: UInt32; &params: ^Int32);
    external 'opengl32.dll' name 'glGetNamedRenderbufferParameterivEXT';
    
    static procedure NamedRenderbufferStorageMultisampleEXT(renderbuffer: UInt32; samples: Int32; internalformat: UInt32; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glNamedRenderbufferStorageMultisampleEXT';
    
    static procedure NamedRenderbufferStorageMultisampleCoverageEXT(renderbuffer: UInt32; coverageSamples: Int32; colorSamples: Int32; internalformat: UInt32; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glNamedRenderbufferStorageMultisampleCoverageEXT';
    
    static function CheckNamedFramebufferStatusEXT(framebuffer: UInt32; target: UInt32): UInt32;
    external 'opengl32.dll' name 'glCheckNamedFramebufferStatusEXT';
    
    static procedure NamedFramebufferTexture1DEXT(framebuffer: UInt32; attachment: UInt32; textarget: UInt32; texture: UInt32; level: Int32);
    external 'opengl32.dll' name 'glNamedFramebufferTexture1DEXT';
    
    static procedure NamedFramebufferTexture2DEXT(framebuffer: UInt32; attachment: UInt32; textarget: UInt32; texture: UInt32; level: Int32);
    external 'opengl32.dll' name 'glNamedFramebufferTexture2DEXT';
    
    static procedure NamedFramebufferTexture3DEXT(framebuffer: UInt32; attachment: UInt32; textarget: UInt32; texture: UInt32; level: Int32; zoffset: Int32);
    external 'opengl32.dll' name 'glNamedFramebufferTexture3DEXT';
    
    static procedure NamedFramebufferRenderbufferEXT(framebuffer: UInt32; attachment: UInt32; renderbuffertarget: UInt32; renderbuffer: UInt32);
    external 'opengl32.dll' name 'glNamedFramebufferRenderbufferEXT';
    
    static procedure GetNamedFramebufferAttachmentParameterivEXT(framebuffer: UInt32; attachment: UInt32; pname: UInt32; &params: ^Int32);
    external 'opengl32.dll' name 'glGetNamedFramebufferAttachmentParameterivEXT';
    
    static procedure GenerateTextureMipmapEXT(texture: UInt32; target: UInt32);
    external 'opengl32.dll' name 'glGenerateTextureMipmapEXT';
    
    static procedure GenerateMultiTexMipmapEXT(texunit: UInt32; target: UInt32);
    external 'opengl32.dll' name 'glGenerateMultiTexMipmapEXT';
    
    static procedure FramebufferDrawBufferEXT(framebuffer: UInt32; mode: UInt32);
    external 'opengl32.dll' name 'glFramebufferDrawBufferEXT';
    
    static procedure FramebufferDrawBuffersEXT(framebuffer: UInt32; n: Int32; bufs: ^UInt32);
    external 'opengl32.dll' name 'glFramebufferDrawBuffersEXT';
    
    static procedure FramebufferReadBufferEXT(framebuffer: UInt32; mode: UInt32);
    external 'opengl32.dll' name 'glFramebufferReadBufferEXT';
    
    static procedure GetFramebufferParameterivEXT(framebuffer: UInt32; pname: UInt32; &params: ^Int32);
    external 'opengl32.dll' name 'glGetFramebufferParameterivEXT';
    
    static procedure NamedCopyBufferSubDataEXT(readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr);
    external 'opengl32.dll' name 'glNamedCopyBufferSubDataEXT';
    
    static procedure NamedFramebufferTextureEXT(framebuffer: UInt32; attachment: UInt32; texture: UInt32; level: Int32);
    external 'opengl32.dll' name 'glNamedFramebufferTextureEXT';
    
    static procedure NamedFramebufferTextureLayerEXT(framebuffer: UInt32; attachment: UInt32; texture: UInt32; level: Int32; layer: Int32);
    external 'opengl32.dll' name 'glNamedFramebufferTextureLayerEXT';
    
    static procedure NamedFramebufferTextureFaceEXT(framebuffer: UInt32; attachment: UInt32; texture: UInt32; level: Int32; face: UInt32);
    external 'opengl32.dll' name 'glNamedFramebufferTextureFaceEXT';
    
    static procedure TextureRenderbufferEXT(texture: UInt32; target: UInt32; renderbuffer: UInt32);
    external 'opengl32.dll' name 'glTextureRenderbufferEXT';
    
    static procedure MultiTexRenderbufferEXT(texunit: UInt32; target: UInt32; renderbuffer: UInt32);
    external 'opengl32.dll' name 'glMultiTexRenderbufferEXT';
    
    static procedure VertexArrayVertexOffsetEXT(vaobj: UInt32; buffer: UInt32; size: Int32; &type: UInt32; stride: Int32; offset: IntPtr);
    external 'opengl32.dll' name 'glVertexArrayVertexOffsetEXT';
    
    static procedure VertexArrayColorOffsetEXT(vaobj: UInt32; buffer: UInt32; size: Int32; &type: UInt32; stride: Int32; offset: IntPtr);
    external 'opengl32.dll' name 'glVertexArrayColorOffsetEXT';
    
    static procedure VertexArrayEdgeFlagOffsetEXT(vaobj: UInt32; buffer: UInt32; stride: Int32; offset: IntPtr);
    external 'opengl32.dll' name 'glVertexArrayEdgeFlagOffsetEXT';
    
    static procedure VertexArrayIndexOffsetEXT(vaobj: UInt32; buffer: UInt32; &type: UInt32; stride: Int32; offset: IntPtr);
    external 'opengl32.dll' name 'glVertexArrayIndexOffsetEXT';
    
    static procedure VertexArrayNormalOffsetEXT(vaobj: UInt32; buffer: UInt32; &type: UInt32; stride: Int32; offset: IntPtr);
    external 'opengl32.dll' name 'glVertexArrayNormalOffsetEXT';
    
    static procedure VertexArrayTexCoordOffsetEXT(vaobj: UInt32; buffer: UInt32; size: Int32; &type: UInt32; stride: Int32; offset: IntPtr);
    external 'opengl32.dll' name 'glVertexArrayTexCoordOffsetEXT';
    
    static procedure VertexArrayMultiTexCoordOffsetEXT(vaobj: UInt32; buffer: UInt32; texunit: UInt32; size: Int32; &type: UInt32; stride: Int32; offset: IntPtr);
    external 'opengl32.dll' name 'glVertexArrayMultiTexCoordOffsetEXT';
    
    static procedure VertexArrayFogCoordOffsetEXT(vaobj: UInt32; buffer: UInt32; &type: UInt32; stride: Int32; offset: IntPtr);
    external 'opengl32.dll' name 'glVertexArrayFogCoordOffsetEXT';
    
    static procedure VertexArraySecondaryColorOffsetEXT(vaobj: UInt32; buffer: UInt32; size: Int32; &type: UInt32; stride: Int32; offset: IntPtr);
    external 'opengl32.dll' name 'glVertexArraySecondaryColorOffsetEXT';
    
    static procedure VertexArrayVertexAttribOffsetEXT(vaobj: UInt32; buffer: UInt32; index: UInt32; size: Int32; &type: UInt32; normalized: boolean; stride: Int32; offset: IntPtr);
    external 'opengl32.dll' name 'glVertexArrayVertexAttribOffsetEXT';
    
    static procedure VertexArrayVertexAttribIOffsetEXT(vaobj: UInt32; buffer: UInt32; index: UInt32; size: Int32; &type: UInt32; stride: Int32; offset: IntPtr);
    external 'opengl32.dll' name 'glVertexArrayVertexAttribIOffsetEXT';
    
    static procedure EnableVertexArrayEXT(vaobj: UInt32; &array: UInt32);
    external 'opengl32.dll' name 'glEnableVertexArrayEXT';
    
    static procedure DisableVertexArrayEXT(vaobj: UInt32; &array: UInt32);
    external 'opengl32.dll' name 'glDisableVertexArrayEXT';
    
    static procedure EnableVertexArrayAttribEXT(vaobj: UInt32; index: UInt32);
    external 'opengl32.dll' name 'glEnableVertexArrayAttribEXT';
    
    static procedure DisableVertexArrayAttribEXT(vaobj: UInt32; index: UInt32);
    external 'opengl32.dll' name 'glDisableVertexArrayAttribEXT';
    
    static procedure GetVertexArrayIntegervEXT(vaobj: UInt32; pname: UInt32; param: ^Int32);
    external 'opengl32.dll' name 'glGetVertexArrayIntegervEXT';
    
    static procedure GetVertexArrayPointervEXT(vaobj: UInt32; pname: UInt32; param: ^IntPtr);
    external 'opengl32.dll' name 'glGetVertexArrayPointervEXT';
    
    static procedure GetVertexArrayIntegeri_vEXT(vaobj: UInt32; index: UInt32; pname: UInt32; param: ^Int32);
    external 'opengl32.dll' name 'glGetVertexArrayIntegeri_vEXT';
    
    static procedure GetVertexArrayPointeri_vEXT(vaobj: UInt32; index: UInt32; pname: UInt32; param: ^IntPtr);
    external 'opengl32.dll' name 'glGetVertexArrayPointeri_vEXT';
    
    static function MapNamedBufferRangeEXT(buffer: UInt32; offset: IntPtr; length: UIntPtr; access: UInt32): pointer;
    external 'opengl32.dll' name 'glMapNamedBufferRangeEXT';
    
    static procedure FlushMappedNamedBufferRangeEXT(buffer: UInt32; offset: IntPtr; length: UIntPtr);
    external 'opengl32.dll' name 'glFlushMappedNamedBufferRangeEXT';
    
    static procedure NamedBufferStorageEXT(buffer: UInt32; size: UIntPtr; data: pointer; flags: UInt32);
    external 'opengl32.dll' name 'glNamedBufferStorageEXT';
    
    static procedure ClearNamedBufferDataEXT(buffer: UInt32; internalformat: UInt32; format: UInt32; &type: UInt32; data: pointer);
    external 'opengl32.dll' name 'glClearNamedBufferDataEXT';
    
    static procedure ClearNamedBufferSubDataEXT(buffer: UInt32; internalformat: UInt32; offset: UIntPtr; size: UIntPtr; format: UInt32; &type: UInt32; data: pointer);
    external 'opengl32.dll' name 'glClearNamedBufferSubDataEXT';
    
    static procedure NamedFramebufferParameteriEXT(framebuffer: UInt32; pname: UInt32; param: Int32);
    external 'opengl32.dll' name 'glNamedFramebufferParameteriEXT';
    
    static procedure GetNamedFramebufferParameterivEXT(framebuffer: UInt32; pname: UInt32; &params: ^Int32);
    external 'opengl32.dll' name 'glGetNamedFramebufferParameterivEXT';
    
    static procedure ProgramUniform1dEXT(&program: UInt32; location: Int32; x: double);
    external 'opengl32.dll' name 'glProgramUniform1dEXT';
    
    static procedure ProgramUniform2dEXT(&program: UInt32; location: Int32; x: double; y: double);
    external 'opengl32.dll' name 'glProgramUniform2dEXT';
    
    static procedure ProgramUniform3dEXT(&program: UInt32; location: Int32; x: double; y: double; z: double);
    external 'opengl32.dll' name 'glProgramUniform3dEXT';
    
    static procedure ProgramUniform4dEXT(&program: UInt32; location: Int32; x: double; y: double; z: double; w: double);
    external 'opengl32.dll' name 'glProgramUniform4dEXT';
    
    static procedure ProgramUniform1dvEXT(&program: UInt32; location: Int32; count: Int32; value: ^double);
    external 'opengl32.dll' name 'glProgramUniform1dvEXT';
    
    static procedure ProgramUniform2dvEXT(&program: UInt32; location: Int32; count: Int32; value: ^double);
    external 'opengl32.dll' name 'glProgramUniform2dvEXT';
    
    static procedure ProgramUniform3dvEXT(&program: UInt32; location: Int32; count: Int32; value: ^double);
    external 'opengl32.dll' name 'glProgramUniform3dvEXT';
    
    static procedure ProgramUniform4dvEXT(&program: UInt32; location: Int32; count: Int32; value: ^double);
    external 'opengl32.dll' name 'glProgramUniform4dvEXT';
    
    static procedure ProgramUniformMatrix2dvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: ^double);
    external 'opengl32.dll' name 'glProgramUniformMatrix2dvEXT';
    
    static procedure ProgramUniformMatrix3dvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: ^double);
    external 'opengl32.dll' name 'glProgramUniformMatrix3dvEXT';
    
    static procedure ProgramUniformMatrix4dvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: ^double);
    external 'opengl32.dll' name 'glProgramUniformMatrix4dvEXT';
    
    static procedure ProgramUniformMatrix2x3dvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: ^double);
    external 'opengl32.dll' name 'glProgramUniformMatrix2x3dvEXT';
    
    static procedure ProgramUniformMatrix2x4dvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: ^double);
    external 'opengl32.dll' name 'glProgramUniformMatrix2x4dvEXT';
    
    static procedure ProgramUniformMatrix3x2dvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: ^double);
    external 'opengl32.dll' name 'glProgramUniformMatrix3x2dvEXT';
    
    static procedure ProgramUniformMatrix3x4dvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: ^double);
    external 'opengl32.dll' name 'glProgramUniformMatrix3x4dvEXT';
    
    static procedure ProgramUniformMatrix4x2dvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: ^double);
    external 'opengl32.dll' name 'glProgramUniformMatrix4x2dvEXT';
    
    static procedure ProgramUniformMatrix4x3dvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: ^double);
    external 'opengl32.dll' name 'glProgramUniformMatrix4x3dvEXT';
    
    static procedure TextureBufferRangeEXT(texture: UInt32; target: UInt32; internalformat: UInt32; buffer: UInt32; offset: IntPtr; size: UIntPtr);
    external 'opengl32.dll' name 'glTextureBufferRangeEXT';
    
    static procedure TextureStorage1DEXT(texture: UInt32; target: UInt32; levels: Int32; internalformat: UInt32; width: Int32);
    external 'opengl32.dll' name 'glTextureStorage1DEXT';
    
    static procedure TextureStorage2DEXT(texture: UInt32; target: UInt32; levels: Int32; internalformat: UInt32; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glTextureStorage2DEXT';
    
    static procedure TextureStorage3DEXT(texture: UInt32; target: UInt32; levels: Int32; internalformat: UInt32; width: Int32; height: Int32; depth: Int32);
    external 'opengl32.dll' name 'glTextureStorage3DEXT';
    
    static procedure TextureStorage2DMultisampleEXT(texture: UInt32; target: UInt32; samples: Int32; internalformat: UInt32; width: Int32; height: Int32; fixedsamplelocations: boolean);
    external 'opengl32.dll' name 'glTextureStorage2DMultisampleEXT';
    
    static procedure TextureStorage3DMultisampleEXT(texture: UInt32; target: UInt32; samples: Int32; internalformat: UInt32; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: boolean);
    external 'opengl32.dll' name 'glTextureStorage3DMultisampleEXT';
    
    static procedure VertexArrayBindVertexBufferEXT(vaobj: UInt32; bindingindex: UInt32; buffer: UInt32; offset: IntPtr; stride: Int32);
    external 'opengl32.dll' name 'glVertexArrayBindVertexBufferEXT';
    
    static procedure VertexArrayVertexAttribFormatEXT(vaobj: UInt32; attribindex: UInt32; size: Int32; &type: UInt32; normalized: boolean; relativeoffset: UInt32);
    external 'opengl32.dll' name 'glVertexArrayVertexAttribFormatEXT';
    
    static procedure VertexArrayVertexAttribIFormatEXT(vaobj: UInt32; attribindex: UInt32; size: Int32; &type: UInt32; relativeoffset: UInt32);
    external 'opengl32.dll' name 'glVertexArrayVertexAttribIFormatEXT';
    
    static procedure VertexArrayVertexAttribLFormatEXT(vaobj: UInt32; attribindex: UInt32; size: Int32; &type: UInt32; relativeoffset: UInt32);
    external 'opengl32.dll' name 'glVertexArrayVertexAttribLFormatEXT';
    
    static procedure VertexArrayVertexAttribBindingEXT(vaobj: UInt32; attribindex: UInt32; bindingindex: UInt32);
    external 'opengl32.dll' name 'glVertexArrayVertexAttribBindingEXT';
    
    static procedure VertexArrayVertexBindingDivisorEXT(vaobj: UInt32; bindingindex: UInt32; divisor: UInt32);
    external 'opengl32.dll' name 'glVertexArrayVertexBindingDivisorEXT';
    
    static procedure VertexArrayVertexAttribLOffsetEXT(vaobj: UInt32; buffer: UInt32; index: UInt32; size: Int32; &type: UInt32; stride: Int32; offset: IntPtr);
    external 'opengl32.dll' name 'glVertexArrayVertexAttribLOffsetEXT';
    
    static procedure TexturePageCommitmentEXT(texture: UInt32; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; commit: boolean);
    external 'opengl32.dll' name 'glTexturePageCommitmentEXT';
    
    static procedure VertexArrayVertexAttribDivisorEXT(vaobj: UInt32; index: UInt32; divisor: UInt32);
    external 'opengl32.dll' name 'glVertexArrayVertexAttribDivisorEXT';
    
    static procedure DrawArraysInstancedEXT(mode: UInt32; start: Int32; count: Int32; primcount: Int32);
    external 'opengl32.dll' name 'glDrawArraysInstancedEXT';
    
    static procedure DrawElementsInstancedEXT(mode: UInt32; count: Int32; &type: UInt32; indices: pointer; primcount: Int32);
    external 'opengl32.dll' name 'glDrawElementsInstancedEXT';
    
    static procedure PolygonOffsetClampEXT(factor: single; units: single; clamp: single);
    external 'opengl32.dll' name 'glPolygonOffsetClampEXT';
    
    static procedure RasterSamplesEXT(samples: UInt32; fixedsamplelocations: boolean);
    external 'opengl32.dll' name 'glRasterSamplesEXT';
    
    static procedure UseShaderProgramEXT(&type: UInt32; &program: UInt32);
    external 'opengl32.dll' name 'glUseShaderProgramEXT';
    
    static procedure ActiveProgramEXT(&program: UInt32);
    external 'opengl32.dll' name 'glActiveProgramEXT';
    
    static function CreateShaderProgramEXT(&type: UInt32; string: ^SByte): UInt32;
    external 'opengl32.dll' name 'glCreateShaderProgramEXT';
    
    static procedure FramebufferFetchBarrierEXT;
    external 'opengl32.dll' name 'glFramebufferFetchBarrierEXT';
    
    static procedure WindowRectanglesEXT(mode: UInt32; count: Int32; box: ^Int32);
    external 'opengl32.dll' name 'glWindowRectanglesEXT';
    
    static procedure ColorSubTableEXT(target: UInt32; start: Int32; count: Int32; format: UInt32; &type: UInt32; table: pointer);
    external 'opengl32.dll' name 'glColorSubTableEXT';
    
    static procedure ColorTableEXT(target: UInt32; internalformat: UInt32; width: Int32; format: UInt32; &type: UInt32; table: pointer);
    external 'opengl32.dll' name 'glColorTableEXT';
    
    static procedure GetColorTableEXT(target: UInt32; format: UInt32; &type: UInt32; table: pointer);
    external 'opengl32.dll' name 'glGetColorTableEXT';
    
    static procedure GetColorTableParameterivEXT(target: UInt32; pname: UInt32; &params: ^Int32);
    external 'opengl32.dll' name 'glGetColorTableParameterivEXT';
    
    static procedure UniformBufferEXT(&program: UInt32; location: Int32; buffer: UInt32);
    external 'opengl32.dll' name 'glUniformBufferEXT';
    
    static function GetUniformBufferSizeEXT(&program: UInt32; location: Int32): Int32;
    external 'opengl32.dll' name 'glGetUniformBufferSizeEXT';
    
    static function GetUniformOffsetEXT(&program: UInt32; location: Int32): IntPtr;
    external 'opengl32.dll' name 'glGetUniformOffsetEXT';
    
    static procedure BlendColorEXT(red: single; green: single; blue: single; alpha: single);
    external 'opengl32.dll' name 'glBlendColorEXT';
    
    static procedure BlendEquationSeparateEXT(modeRGB: ErrorCode; modeAlpha: ErrorCode);
    external 'opengl32.dll' name 'glBlendEquationSeparateEXT';
    
    static procedure BlendFuncSeparateEXT(sfactorRGB: ErrorCode; dfactorRGB: ErrorCode; sfactorAlpha: ErrorCode; dfactorAlpha: ErrorCode);
    external 'opengl32.dll' name 'glBlendFuncSeparateEXT';
    
    static procedure BlendEquationEXT(mode: ErrorCode);
    external 'opengl32.dll' name 'glBlendEquationEXT';
    
    static procedure CopyColorSubTableEXT(target: ErrorCode; start: Int32; x: Int32; y: Int32; width: Int32);
    external 'opengl32.dll' name 'glCopyColorSubTableEXT';
    
    static procedure LockArraysEXT(first: Int32; count: Int32);
    external 'opengl32.dll' name 'glLockArraysEXT';
    
    static procedure UnlockArraysEXT;
    external 'opengl32.dll' name 'glUnlockArraysEXT';
    
    static procedure ConvolutionFilter1DEXT(target: ErrorCode; internalformat: ErrorCode; width: Int32; format: ErrorCode; &type: ErrorCode; image: pointer);
    external 'opengl32.dll' name 'glConvolutionFilter1DEXT';
    
    static procedure ConvolutionFilter2DEXT(target: ErrorCode; internalformat: ErrorCode; width: Int32; height: Int32; format: ErrorCode; &type: ErrorCode; image: pointer);
    external 'opengl32.dll' name 'glConvolutionFilter2DEXT';
    
    static procedure ConvolutionParameterfEXT(target: ErrorCode; pname: ErrorCode; &params: single);
    external 'opengl32.dll' name 'glConvolutionParameterfEXT';
    
    static procedure ConvolutionParameterfvEXT(target: ErrorCode; pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glConvolutionParameterfvEXT';
    
    static procedure ConvolutionParameteriEXT(target: ErrorCode; pname: ErrorCode; &params: Int32);
    external 'opengl32.dll' name 'glConvolutionParameteriEXT';
    
    static procedure ConvolutionParameterivEXT(target: ErrorCode; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glConvolutionParameterivEXT';
    
    static procedure CopyConvolutionFilter1DEXT(target: ErrorCode; internalformat: ErrorCode; x: Int32; y: Int32; width: Int32);
    external 'opengl32.dll' name 'glCopyConvolutionFilter1DEXT';
    
    static procedure CopyConvolutionFilter2DEXT(target: ErrorCode; internalformat: ErrorCode; x: Int32; y: Int32; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glCopyConvolutionFilter2DEXT';
    
    static procedure GetConvolutionFilterEXT(target: ErrorCode; format: ErrorCode; &type: ErrorCode; image: pointer);
    external 'opengl32.dll' name 'glGetConvolutionFilterEXT';
    
    static procedure GetConvolutionParameterfvEXT(target: ErrorCode; pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glGetConvolutionParameterfvEXT';
    
    static procedure GetConvolutionParameterivEXT(target: ErrorCode; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetConvolutionParameterivEXT';
    
    static procedure GetSeparableFilterEXT(target: ErrorCode; format: ErrorCode; &type: ErrorCode; row: pointer; column: pointer; span: pointer);
    external 'opengl32.dll' name 'glGetSeparableFilterEXT';
    
    static procedure SeparableFilter2DEXT(target: ErrorCode; internalformat: ErrorCode; width: Int32; height: Int32; format: ErrorCode; &type: ErrorCode; row: pointer; column: pointer);
    external 'opengl32.dll' name 'glSeparableFilter2DEXT';
    
    static procedure Tangent3bEXT(tx: SByte; ty: SByte; tz: SByte);
    external 'opengl32.dll' name 'glTangent3bEXT';
    
    static procedure Tangent3bvEXT(v: ^SByte);
    external 'opengl32.dll' name 'glTangent3bvEXT';
    
    static procedure Tangent3dEXT(tx: double; ty: double; tz: double);
    external 'opengl32.dll' name 'glTangent3dEXT';
    
    static procedure Tangent3dvEXT(v: ^double);
    external 'opengl32.dll' name 'glTangent3dvEXT';
    
    static procedure Tangent3fEXT(tx: single; ty: single; tz: single);
    external 'opengl32.dll' name 'glTangent3fEXT';
    
    static procedure Tangent3fvEXT(v: ^single);
    external 'opengl32.dll' name 'glTangent3fvEXT';
    
    static procedure Tangent3iEXT(tx: Int32; ty: Int32; tz: Int32);
    external 'opengl32.dll' name 'glTangent3iEXT';
    
    static procedure Tangent3ivEXT(v: ^Int32);
    external 'opengl32.dll' name 'glTangent3ivEXT';
    
    static procedure Tangent3sEXT(tx: Int16; ty: Int16; tz: Int16);
    external 'opengl32.dll' name 'glTangent3sEXT';
    
    static procedure Tangent3svEXT(v: ^Int16);
    external 'opengl32.dll' name 'glTangent3svEXT';
    
    static procedure Binormal3bEXT(bx: SByte; by: SByte; bz: SByte);
    external 'opengl32.dll' name 'glBinormal3bEXT';
    
    static procedure Binormal3bvEXT(v: ^SByte);
    external 'opengl32.dll' name 'glBinormal3bvEXT';
    
    static procedure Binormal3dEXT(bx: double; by: double; bz: double);
    external 'opengl32.dll' name 'glBinormal3dEXT';
    
    static procedure Binormal3dvEXT(v: ^double);
    external 'opengl32.dll' name 'glBinormal3dvEXT';
    
    static procedure Binormal3fEXT(bx: single; by: single; bz: single);
    external 'opengl32.dll' name 'glBinormal3fEXT';
    
    static procedure Binormal3fvEXT(v: ^single);
    external 'opengl32.dll' name 'glBinormal3fvEXT';
    
    static procedure Binormal3iEXT(bx: Int32; by: Int32; bz: Int32);
    external 'opengl32.dll' name 'glBinormal3iEXT';
    
    static procedure Binormal3ivEXT(v: ^Int32);
    external 'opengl32.dll' name 'glBinormal3ivEXT';
    
    static procedure Binormal3sEXT(bx: Int16; by: Int16; bz: Int16);
    external 'opengl32.dll' name 'glBinormal3sEXT';
    
    static procedure Binormal3svEXT(v: ^Int16);
    external 'opengl32.dll' name 'glBinormal3svEXT';
    
    static procedure TangentPointerEXT(&type: ErrorCode; stride: Int32; _pointer: pointer);
    external 'opengl32.dll' name 'glTangentPointerEXT';
    
    static procedure BinormalPointerEXT(&type: ErrorCode; stride: Int32; _pointer: pointer);
    external 'opengl32.dll' name 'glBinormalPointerEXT';
    
    static procedure CopyTexImage1DEXT(target: ErrorCode; level: Int32; internalformat: ErrorCode; x: Int32; y: Int32; width: Int32; border: Int32);
    external 'opengl32.dll' name 'glCopyTexImage1DEXT';
    
    static procedure CopyTexImage2DEXT(target: ErrorCode; level: Int32; internalformat: ErrorCode; x: Int32; y: Int32; width: Int32; height: Int32; border: Int32);
    external 'opengl32.dll' name 'glCopyTexImage2DEXT';
    
    static procedure CopyTexSubImage1DEXT(target: ErrorCode; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32);
    external 'opengl32.dll' name 'glCopyTexSubImage1DEXT';
    
    static procedure CopyTexSubImage2DEXT(target: ErrorCode; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glCopyTexSubImage2DEXT';
    
    static procedure CopyTexSubImage3DEXT(target: ErrorCode; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glCopyTexSubImage3DEXT';
    
    static procedure CullParameterdvEXT(pname: ErrorCode; &params: ^double);
    external 'opengl32.dll' name 'glCullParameterdvEXT';
    
    static procedure CullParameterfvEXT(pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glCullParameterfvEXT';
    
    static procedure DepthBoundsEXT(zmin: double; zmax: double);
    external 'opengl32.dll' name 'glDepthBoundsEXT';
    
    static procedure ColorMaskIndexedEXT(index: UInt32; r: Byte; g: Byte; b: Byte; a: Byte);
    external 'opengl32.dll' name 'glColorMaskIndexedEXT';
    
    static procedure DrawRangeElementsEXT(mode: ErrorCode; start: UInt32; &end: UInt32; count: Int32; &type: ErrorCode; indices: pointer);
    external 'opengl32.dll' name 'glDrawRangeElementsEXT';
    
    static procedure BufferStorageExternalEXT(target: ErrorCode; offset: IntPtr; size: UIntPtr; clientBuffer: GLeglClientBufferEXT; flags: UInt32);
    external 'opengl32.dll' name 'glBufferStorageExternalEXT';
    
    static procedure NamedBufferStorageExternalEXT(buffer: UInt32; offset: IntPtr; size: UIntPtr; clientBuffer: GLeglClientBufferEXT; flags: UInt32);
    external 'opengl32.dll' name 'glNamedBufferStorageExternalEXT';
    
    static procedure FogCoordfEXT(coord: single);
    external 'opengl32.dll' name 'glFogCoordfEXT';
    
    static procedure FogCoordfvEXT(coord: ^single);
    external 'opengl32.dll' name 'glFogCoordfvEXT';
    
    static procedure FogCoorddEXT(coord: double);
    external 'opengl32.dll' name 'glFogCoorddEXT';
    
    static procedure FogCoorddvEXT(coord: ^double);
    external 'opengl32.dll' name 'glFogCoorddvEXT';
    
    static procedure FogCoordPointerEXT(&type: ErrorCode; stride: Int32; _pointer: pointer);
    external 'opengl32.dll' name 'glFogCoordPointerEXT';
    
    static procedure BlitFramebufferEXT(srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: UInt32; filter: ErrorCode);
    external 'opengl32.dll' name 'glBlitFramebufferEXT';
    
    static procedure RenderbufferStorageMultisampleEXT(target: ErrorCode; samples: Int32; internalformat: ErrorCode; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glRenderbufferStorageMultisampleEXT';
    
    static function IsRenderbufferEXT(renderbuffer: UInt32): Byte;
    external 'opengl32.dll' name 'glIsRenderbufferEXT';
    
    static procedure BindRenderbufferEXT(target: ErrorCode; renderbuffer: UInt32);
    external 'opengl32.dll' name 'glBindRenderbufferEXT';
    
    static procedure DeleteRenderbuffersEXT(n: Int32; renderbuffers: ^UInt32);
    external 'opengl32.dll' name 'glDeleteRenderbuffersEXT';
    
    static procedure GenRenderbuffersEXT(n: Int32; renderbuffers: ^UInt32);
    external 'opengl32.dll' name 'glGenRenderbuffersEXT';
    
    static procedure RenderbufferStorageEXT(target: ErrorCode; internalformat: ErrorCode; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glRenderbufferStorageEXT';
    
    static procedure GetRenderbufferParameterivEXT(target: ErrorCode; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetRenderbufferParameterivEXT';
    
    static function IsFramebufferEXT(framebuffer: UInt32): Byte;
    external 'opengl32.dll' name 'glIsFramebufferEXT';
    
    static procedure BindFramebufferEXT(target: ErrorCode; framebuffer: UInt32);
    external 'opengl32.dll' name 'glBindFramebufferEXT';
    
    static procedure DeleteFramebuffersEXT(n: Int32; framebuffers: ^UInt32);
    external 'opengl32.dll' name 'glDeleteFramebuffersEXT';
    
    static procedure GenFramebuffersEXT(n: Int32; framebuffers: ^UInt32);
    external 'opengl32.dll' name 'glGenFramebuffersEXT';
    
    static function CheckFramebufferStatusEXT(target: ErrorCode): ErrorCode;
    external 'opengl32.dll' name 'glCheckFramebufferStatusEXT';
    
    static procedure FramebufferTexture1DEXT(target: ErrorCode; attachment: ErrorCode; textarget: ErrorCode; texture: UInt32; level: Int32);
    external 'opengl32.dll' name 'glFramebufferTexture1DEXT';
    
    static procedure FramebufferTexture2DEXT(target: ErrorCode; attachment: ErrorCode; textarget: ErrorCode; texture: UInt32; level: Int32);
    external 'opengl32.dll' name 'glFramebufferTexture2DEXT';
    
    static procedure FramebufferTexture3DEXT(target: ErrorCode; attachment: ErrorCode; textarget: ErrorCode; texture: UInt32; level: Int32; zoffset: Int32);
    external 'opengl32.dll' name 'glFramebufferTexture3DEXT';
    
    static procedure FramebufferRenderbufferEXT(target: ErrorCode; attachment: ErrorCode; renderbuffertarget: ErrorCode; renderbuffer: UInt32);
    external 'opengl32.dll' name 'glFramebufferRenderbufferEXT';
    
    static procedure GetFramebufferAttachmentParameterivEXT(target: ErrorCode; attachment: ErrorCode; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetFramebufferAttachmentParameterivEXT';
    
    static procedure GenerateMipmapEXT(target: ErrorCode);
    external 'opengl32.dll' name 'glGenerateMipmapEXT';
    
    static procedure ProgramParameteriEXT(&program: UInt32; pname: ErrorCode; value: Int32);
    external 'opengl32.dll' name 'glProgramParameteriEXT';
    
    static procedure ProgramEnvParameters4fvEXT(target: ErrorCode; index: UInt32; count: Int32; &params: ^single);
    external 'opengl32.dll' name 'glProgramEnvParameters4fvEXT';
    
    static procedure ProgramLocalParameters4fvEXT(target: ErrorCode; index: UInt32; count: Int32; &params: ^single);
    external 'opengl32.dll' name 'glProgramLocalParameters4fvEXT';
    
    static procedure GetUniformuivEXT(&program: UInt32; location: Int32; &params: ^UInt32);
    external 'opengl32.dll' name 'glGetUniformuivEXT';
    
    static procedure BindFragDataLocationEXT(&program: UInt32; color: UInt32; name: ^Byte);
    external 'opengl32.dll' name 'glBindFragDataLocationEXT';
    
    static function GetFragDataLocationEXT(&program: UInt32; name: ^Byte): Int32;
    external 'opengl32.dll' name 'glGetFragDataLocationEXT';
    
    static procedure Uniform1uiEXT(location: Int32; v0: UInt32);
    external 'opengl32.dll' name 'glUniform1uiEXT';
    
    static procedure Uniform2uiEXT(location: Int32; v0: UInt32; v1: UInt32);
    external 'opengl32.dll' name 'glUniform2uiEXT';
    
    static procedure Uniform3uiEXT(location: Int32; v0: UInt32; v1: UInt32; v2: UInt32);
    external 'opengl32.dll' name 'glUniform3uiEXT';
    
    static procedure Uniform4uiEXT(location: Int32; v0: UInt32; v1: UInt32; v2: UInt32; v3: UInt32);
    external 'opengl32.dll' name 'glUniform4uiEXT';
    
    static procedure Uniform1uivEXT(location: Int32; count: Int32; value: ^UInt32);
    external 'opengl32.dll' name 'glUniform1uivEXT';
    
    static procedure Uniform2uivEXT(location: Int32; count: Int32; value: ^UInt32);
    external 'opengl32.dll' name 'glUniform2uivEXT';
    
    static procedure Uniform3uivEXT(location: Int32; count: Int32; value: ^UInt32);
    external 'opengl32.dll' name 'glUniform3uivEXT';
    
    static procedure Uniform4uivEXT(location: Int32; count: Int32; value: ^UInt32);
    external 'opengl32.dll' name 'glUniform4uivEXT';
    
    static procedure GetHistogramEXT(target: ErrorCode; reset: Byte; format: ErrorCode; &type: ErrorCode; values: pointer);
    external 'opengl32.dll' name 'glGetHistogramEXT';
    
    static procedure GetHistogramParameterfvEXT(target: ErrorCode; pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glGetHistogramParameterfvEXT';
    
    static procedure GetHistogramParameterivEXT(target: ErrorCode; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetHistogramParameterivEXT';
    
    static procedure GetMinmaxEXT(target: ErrorCode; reset: Byte; format: ErrorCode; &type: ErrorCode; values: pointer);
    external 'opengl32.dll' name 'glGetMinmaxEXT';
    
    static procedure GetMinmaxParameterfvEXT(target: ErrorCode; pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glGetMinmaxParameterfvEXT';
    
    static procedure GetMinmaxParameterivEXT(target: ErrorCode; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetMinmaxParameterivEXT';
    
    static procedure HistogramEXT(target: ErrorCode; width: Int32; internalformat: ErrorCode; sink: Byte);
    external 'opengl32.dll' name 'glHistogramEXT';
    
    static procedure MinmaxEXT(target: ErrorCode; internalformat: ErrorCode; sink: Byte);
    external 'opengl32.dll' name 'glMinmaxEXT';
    
    static procedure ResetHistogramEXT(target: ErrorCode);
    external 'opengl32.dll' name 'glResetHistogramEXT';
    
    static procedure ResetMinmaxEXT(target: ErrorCode);
    external 'opengl32.dll' name 'glResetMinmaxEXT';
    
    static procedure IndexFuncEXT(func: ErrorCode; ref: single);
    external 'opengl32.dll' name 'glIndexFuncEXT';
    
    static procedure IndexMaterialEXT(face: ErrorCode; mode: ErrorCode);
    external 'opengl32.dll' name 'glIndexMaterialEXT';
    
    static procedure ApplyTextureEXT(mode: ErrorCode);
    external 'opengl32.dll' name 'glApplyTextureEXT';
    
    static procedure TextureLightEXT(pname: ErrorCode);
    external 'opengl32.dll' name 'glTextureLightEXT';
    
    static procedure TextureMaterialEXT(face: ErrorCode; mode: ErrorCode);
    external 'opengl32.dll' name 'glTextureMaterialEXT';
    
    static procedure GetUnsignedBytevEXT(pname: ErrorCode; data: ^Byte);
    external 'opengl32.dll' name 'glGetUnsignedBytevEXT';
    
    static procedure GetUnsignedBytei_vEXT(target: ErrorCode; index: UInt32; data: ^Byte);
    external 'opengl32.dll' name 'glGetUnsignedBytei_vEXT';
    
    static procedure DeleteMemoryObjectsEXT(n: Int32; memoryObjects: ^UInt32);
    external 'opengl32.dll' name 'glDeleteMemoryObjectsEXT';
    
    static function IsMemoryObjectEXT(memoryObject: UInt32): Byte;
    external 'opengl32.dll' name 'glIsMemoryObjectEXT';
    
    static procedure CreateMemoryObjectsEXT(n: Int32; memoryObjects: ^UInt32);
    external 'opengl32.dll' name 'glCreateMemoryObjectsEXT';
    
    static procedure MemoryObjectParameterivEXT(memoryObject: UInt32; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glMemoryObjectParameterivEXT';
    
    static procedure GetMemoryObjectParameterivEXT(memoryObject: UInt32; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetMemoryObjectParameterivEXT';
    
    static procedure TexStorageMem2DEXT(target: ErrorCode; levels: Int32; internalFormat: ErrorCode; width: Int32; height: Int32; memory: UInt32; offset: UInt64);
    external 'opengl32.dll' name 'glTexStorageMem2DEXT';
    
    static procedure TexStorageMem2DMultisampleEXT(target: ErrorCode; samples: Int32; internalFormat: ErrorCode; width: Int32; height: Int32; fixedSampleLocations: Byte; memory: UInt32; offset: UInt64);
    external 'opengl32.dll' name 'glTexStorageMem2DMultisampleEXT';
    
    static procedure TexStorageMem3DEXT(target: ErrorCode; levels: Int32; internalFormat: ErrorCode; width: Int32; height: Int32; depth: Int32; memory: UInt32; offset: UInt64);
    external 'opengl32.dll' name 'glTexStorageMem3DEXT';
    
    static procedure TexStorageMem3DMultisampleEXT(target: ErrorCode; samples: Int32; internalFormat: ErrorCode; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: Byte; memory: UInt32; offset: UInt64);
    external 'opengl32.dll' name 'glTexStorageMem3DMultisampleEXT';
    
    static procedure BufferStorageMemEXT(target: ErrorCode; size: UIntPtr; memory: UInt32; offset: UInt64);
    external 'opengl32.dll' name 'glBufferStorageMemEXT';
    
    static procedure TextureStorageMem2DEXT(texture: UInt32; levels: Int32; internalFormat: ErrorCode; width: Int32; height: Int32; memory: UInt32; offset: UInt64);
    external 'opengl32.dll' name 'glTextureStorageMem2DEXT';
    
    static procedure TextureStorageMem2DMultisampleEXT(texture: UInt32; samples: Int32; internalFormat: ErrorCode; width: Int32; height: Int32; fixedSampleLocations: Byte; memory: UInt32; offset: UInt64);
    external 'opengl32.dll' name 'glTextureStorageMem2DMultisampleEXT';
    
    static procedure TextureStorageMem3DEXT(texture: UInt32; levels: Int32; internalFormat: ErrorCode; width: Int32; height: Int32; depth: Int32; memory: UInt32; offset: UInt64);
    external 'opengl32.dll' name 'glTextureStorageMem3DEXT';
    
    static procedure TextureStorageMem3DMultisampleEXT(texture: UInt32; samples: Int32; internalFormat: ErrorCode; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: Byte; memory: UInt32; offset: UInt64);
    external 'opengl32.dll' name 'glTextureStorageMem3DMultisampleEXT';
    
    static procedure NamedBufferStorageMemEXT(buffer: UInt32; size: UIntPtr; memory: UInt32; offset: UInt64);
    external 'opengl32.dll' name 'glNamedBufferStorageMemEXT';
    
    static procedure TexStorageMem1DEXT(target: ErrorCode; levels: Int32; internalFormat: ErrorCode; width: Int32; memory: UInt32; offset: UInt64);
    external 'opengl32.dll' name 'glTexStorageMem1DEXT';
    
    static procedure TextureStorageMem1DEXT(texture: UInt32; levels: Int32; internalFormat: ErrorCode; width: Int32; memory: UInt32; offset: UInt64);
    external 'opengl32.dll' name 'glTextureStorageMem1DEXT';
    
    static procedure ImportMemoryFdEXT(memory: UInt32; size: UInt64; handleType: ErrorCode; fd: Int32);
    external 'opengl32.dll' name 'glImportMemoryFdEXT';
    
    static procedure ImportMemoryWin32HandleEXT(memory: UInt32; size: UInt64; handleType: ErrorCode; handle: pointer);
    external 'opengl32.dll' name 'glImportMemoryWin32HandleEXT';
    
    static procedure ImportMemoryWin32NameEXT(memory: UInt32; size: UInt64; handleType: ErrorCode; name: pointer);
    external 'opengl32.dll' name 'glImportMemoryWin32NameEXT';
    
    static procedure MultiDrawArraysEXT(mode: ErrorCode; first: ^Int32; count: ^Int32; primcount: Int32);
    external 'opengl32.dll' name 'glMultiDrawArraysEXT';
    
    static procedure MultiDrawElementsEXT(mode: ErrorCode; count: ^Int32; &type: ErrorCode; indices: ^pointer; primcount: Int32);
    external 'opengl32.dll' name 'glMultiDrawElementsEXT';
    
    static procedure SampleMaskEXT(value: single; invert: Byte);
    external 'opengl32.dll' name 'glSampleMaskEXT';
    
    static procedure SamplePatternEXT(pattern: ErrorCode);
    external 'opengl32.dll' name 'glSamplePatternEXT';
    
    static procedure GetColorTableParameterfvEXT(target: ErrorCode; pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glGetColorTableParameterfvEXT';
    
    static procedure PixelTransformParameteriEXT(target: ErrorCode; pname: ErrorCode; param: Int32);
    external 'opengl32.dll' name 'glPixelTransformParameteriEXT';
    
    static procedure PixelTransformParameterfEXT(target: ErrorCode; pname: ErrorCode; param: single);
    external 'opengl32.dll' name 'glPixelTransformParameterfEXT';
    
    static procedure PixelTransformParameterivEXT(target: ErrorCode; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glPixelTransformParameterivEXT';
    
    static procedure PixelTransformParameterfvEXT(target: ErrorCode; pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glPixelTransformParameterfvEXT';
    
    static procedure GetPixelTransformParameterivEXT(target: ErrorCode; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetPixelTransformParameterivEXT';
    
    static procedure GetPixelTransformParameterfvEXT(target: ErrorCode; pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glGetPixelTransformParameterfvEXT';
    
    static procedure PointParameterfEXT(pname: ErrorCode; param: single);
    external 'opengl32.dll' name 'glPointParameterfEXT';
    
    static procedure PointParameterfvEXT(pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glPointParameterfvEXT';
    
    static procedure PolygonOffsetEXT(factor: single; bias: single);
    external 'opengl32.dll' name 'glPolygonOffsetEXT';
    
    static procedure ProvokingVertexEXT(mode: ErrorCode);
    external 'opengl32.dll' name 'glProvokingVertexEXT';
    
    static procedure SecondaryColor3bEXT(red: SByte; green: SByte; blue: SByte);
    external 'opengl32.dll' name 'glSecondaryColor3bEXT';
    
    static procedure SecondaryColor3bvEXT(v: ^SByte);
    external 'opengl32.dll' name 'glSecondaryColor3bvEXT';
    
    static procedure SecondaryColor3dEXT(red: double; green: double; blue: double);
    external 'opengl32.dll' name 'glSecondaryColor3dEXT';
    
    static procedure SecondaryColor3dvEXT(v: ^double);
    external 'opengl32.dll' name 'glSecondaryColor3dvEXT';
    
    static procedure SecondaryColor3fEXT(red: single; green: single; blue: single);
    external 'opengl32.dll' name 'glSecondaryColor3fEXT';
    
    static procedure SecondaryColor3fvEXT(v: ^single);
    external 'opengl32.dll' name 'glSecondaryColor3fvEXT';
    
    static procedure SecondaryColor3iEXT(red: Int32; green: Int32; blue: Int32);
    external 'opengl32.dll' name 'glSecondaryColor3iEXT';
    
    static procedure SecondaryColor3ivEXT(v: ^Int32);
    external 'opengl32.dll' name 'glSecondaryColor3ivEXT';
    
    static procedure SecondaryColor3sEXT(red: Int16; green: Int16; blue: Int16);
    external 'opengl32.dll' name 'glSecondaryColor3sEXT';
    
    static procedure SecondaryColor3svEXT(v: ^Int16);
    external 'opengl32.dll' name 'glSecondaryColor3svEXT';
    
    static procedure SecondaryColor3ubEXT(red: Byte; green: Byte; blue: Byte);
    external 'opengl32.dll' name 'glSecondaryColor3ubEXT';
    
    static procedure SecondaryColor3ubvEXT(v: ^Byte);
    external 'opengl32.dll' name 'glSecondaryColor3ubvEXT';
    
    static procedure SecondaryColor3uiEXT(red: UInt32; green: UInt32; blue: UInt32);
    external 'opengl32.dll' name 'glSecondaryColor3uiEXT';
    
    static procedure SecondaryColor3uivEXT(v: ^UInt32);
    external 'opengl32.dll' name 'glSecondaryColor3uivEXT';
    
    static procedure SecondaryColor3usEXT(red: UInt16; green: UInt16; blue: UInt16);
    external 'opengl32.dll' name 'glSecondaryColor3usEXT';
    
    static procedure SecondaryColor3usvEXT(v: ^UInt16);
    external 'opengl32.dll' name 'glSecondaryColor3usvEXT';
    
    static procedure SecondaryColorPointerEXT(size: Int32; &type: ErrorCode; stride: Int32; _pointer: pointer);
    external 'opengl32.dll' name 'glSecondaryColorPointerEXT';
    
    static procedure GenSemaphoresEXT(n: Int32; semaphores: ^UInt32);
    external 'opengl32.dll' name 'glGenSemaphoresEXT';
    
    static procedure DeleteSemaphoresEXT(n: Int32; semaphores: ^UInt32);
    external 'opengl32.dll' name 'glDeleteSemaphoresEXT';
    
    static function IsSemaphoreEXT(semaphore: UInt32): Byte;
    external 'opengl32.dll' name 'glIsSemaphoreEXT';
    
    static procedure SemaphoreParameterui64vEXT(semaphore: UInt32; pname: ErrorCode; &params: ^UInt64);
    external 'opengl32.dll' name 'glSemaphoreParameterui64vEXT';
    
    static procedure GetSemaphoreParameterui64vEXT(semaphore: UInt32; pname: ErrorCode; &params: ^UInt64);
    external 'opengl32.dll' name 'glGetSemaphoreParameterui64vEXT';
    
    static procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: ^UInt32; numTextureBarriers: UInt32; textures: ^UInt32; srcLayouts: ^ErrorCode);
    external 'opengl32.dll' name 'glWaitSemaphoreEXT';
    
    static procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: ^UInt32; numTextureBarriers: UInt32; textures: ^UInt32; dstLayouts: ^ErrorCode);
    external 'opengl32.dll' name 'glSignalSemaphoreEXT';
    
    static procedure ImportSemaphoreFdEXT(semaphore: UInt32; handleType: ErrorCode; fd: Int32);
    external 'opengl32.dll' name 'glImportSemaphoreFdEXT';
    
    static procedure ImportSemaphoreWin32HandleEXT(semaphore: UInt32; handleType: ErrorCode; handle: pointer);
    external 'opengl32.dll' name 'glImportSemaphoreWin32HandleEXT';
    
    static procedure ImportSemaphoreWin32NameEXT(semaphore: UInt32; handleType: ErrorCode; name: pointer);
    external 'opengl32.dll' name 'glImportSemaphoreWin32NameEXT';
    
    static procedure BindImageTextureEXT(index: UInt32; texture: UInt32; level: Int32; layered: Byte; layer: Int32; access: ErrorCode; format: Int32);
    external 'opengl32.dll' name 'glBindImageTextureEXT';
    
    static procedure MemoryBarrierEXT(barriers: UInt32);
    external 'opengl32.dll' name 'glMemoryBarrierEXT';
    
    static procedure StencilClearTagEXT(stencilTagBits: Int32; stencilClearTag: UInt32);
    external 'opengl32.dll' name 'glStencilClearTagEXT';
    
    static procedure ActiveStencilFaceEXT(face: ErrorCode);
    external 'opengl32.dll' name 'glActiveStencilFaceEXT';
    
    static procedure TexSubImage1DEXT(target: ErrorCode; level: Int32; xoffset: Int32; width: Int32; format: ErrorCode; &type: ErrorCode; pixels: pointer);
    external 'opengl32.dll' name 'glTexSubImage1DEXT';
    
    static procedure TexSubImage2DEXT(target: ErrorCode; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: ErrorCode; &type: ErrorCode; pixels: pointer);
    external 'opengl32.dll' name 'glTexSubImage2DEXT';
    
    static procedure TexImage3DEXT(target: ErrorCode; level: Int32; internalformat: ErrorCode; width: Int32; height: Int32; depth: Int32; border: Int32; format: ErrorCode; &type: ErrorCode; pixels: pointer);
    external 'opengl32.dll' name 'glTexImage3DEXT';
    
    static procedure TexSubImage3DEXT(target: ErrorCode; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: ErrorCode; &type: ErrorCode; pixels: pointer);
    external 'opengl32.dll' name 'glTexSubImage3DEXT';
    
    static procedure FramebufferTextureLayerEXT(target: ErrorCode; attachment: ErrorCode; texture: UInt32; level: Int32; layer: Int32);
    external 'opengl32.dll' name 'glFramebufferTextureLayerEXT';
    
    static procedure TexBufferEXT(target: ErrorCode; internalformat: ErrorCode; buffer: UInt32);
    external 'opengl32.dll' name 'glTexBufferEXT';
    
    static procedure TexParameterIivEXT(target: ErrorCode; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glTexParameterIivEXT';
    
    static procedure TexParameterIuivEXT(target: ErrorCode; pname: ErrorCode; &params: ^UInt32);
    external 'opengl32.dll' name 'glTexParameterIuivEXT';
    
    static procedure GetTexParameterIivEXT(target: ErrorCode; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetTexParameterIivEXT';
    
    static procedure GetTexParameterIuivEXT(target: ErrorCode; pname: ErrorCode; &params: ^UInt32);
    external 'opengl32.dll' name 'glGetTexParameterIuivEXT';
    
    static procedure ClearColorIiEXT(red: Int32; green: Int32; blue: Int32; alpha: Int32);
    external 'opengl32.dll' name 'glClearColorIiEXT';
    
    static procedure ClearColorIuiEXT(red: UInt32; green: UInt32; blue: UInt32; alpha: UInt32);
    external 'opengl32.dll' name 'glClearColorIuiEXT';
    
    static function AreTexturesResidentEXT(n: Int32; textures: ^UInt32; residences: ^Byte): Byte;
    external 'opengl32.dll' name 'glAreTexturesResidentEXT';
    
    static procedure BindTextureEXT(target: ErrorCode; texture: UInt32);
    external 'opengl32.dll' name 'glBindTextureEXT';
    
    static procedure DeleteTexturesEXT(n: Int32; textures: ^UInt32);
    external 'opengl32.dll' name 'glDeleteTexturesEXT';
    
    static procedure GenTexturesEXT(n: Int32; textures: ^UInt32);
    external 'opengl32.dll' name 'glGenTexturesEXT';
    
    static function IsTextureEXT(texture: UInt32): Byte;
    external 'opengl32.dll' name 'glIsTextureEXT';
    
    static procedure PrioritizeTexturesEXT(n: Int32; textures: ^UInt32; priorities: ^single);
    external 'opengl32.dll' name 'glPrioritizeTexturesEXT';
    
    static procedure TextureNormalEXT(mode: ErrorCode);
    external 'opengl32.dll' name 'glTextureNormalEXT';
    
    static procedure GetQueryObjecti64vEXT(id: UInt32; pname: ErrorCode; &params: ^Int64);
    external 'opengl32.dll' name 'glGetQueryObjecti64vEXT';
    
    static procedure GetQueryObjectui64vEXT(id: UInt32; pname: ErrorCode; &params: ^UInt64);
    external 'opengl32.dll' name 'glGetQueryObjectui64vEXT';
    
    static procedure BeginTransformFeedbackEXT(primitiveMode: ErrorCode);
    external 'opengl32.dll' name 'glBeginTransformFeedbackEXT';
    
    static procedure EndTransformFeedbackEXT;
    external 'opengl32.dll' name 'glEndTransformFeedbackEXT';
    
    static procedure BindBufferRangeEXT(target: ErrorCode; index: UInt32; buffer: UInt32; offset: IntPtr; size: UIntPtr);
    external 'opengl32.dll' name 'glBindBufferRangeEXT';
    
    static procedure BindBufferOffsetEXT(target: ErrorCode; index: UInt32; buffer: UInt32; offset: IntPtr);
    external 'opengl32.dll' name 'glBindBufferOffsetEXT';
    
    static procedure BindBufferBaseEXT(target: ErrorCode; index: UInt32; buffer: UInt32);
    external 'opengl32.dll' name 'glBindBufferBaseEXT';
    
    static procedure TransformFeedbackVaryingsEXT(&program: UInt32; count: Int32; varyings: ^^Byte; bufferMode: ErrorCode);
    external 'opengl32.dll' name 'glTransformFeedbackVaryingsEXT';
    
    static procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; length: ^Int32; size: ^Int32; &type: ^ErrorCode; name: ^Byte);
    external 'opengl32.dll' name 'glGetTransformFeedbackVaryingEXT';
    
    static procedure ArrayElementEXT(i: Int32);
    external 'opengl32.dll' name 'glArrayElementEXT';
    
    static procedure ColorPointerEXT(size: Int32; &type: ErrorCode; stride: Int32; count: Int32; _pointer: pointer);
    external 'opengl32.dll' name 'glColorPointerEXT';
    
    static procedure DrawArraysEXT(mode: ErrorCode; first: Int32; count: Int32);
    external 'opengl32.dll' name 'glDrawArraysEXT';
    
    static procedure EdgeFlagPointerEXT(stride: Int32; count: Int32; _pointer: ^Byte);
    external 'opengl32.dll' name 'glEdgeFlagPointerEXT';
    
    static procedure GetPointervEXT(pname: ErrorCode; &params: ^pointer);
    external 'opengl32.dll' name 'glGetPointervEXT';
    
    static procedure IndexPointerEXT(&type: ErrorCode; stride: Int32; count: Int32; _pointer: pointer);
    external 'opengl32.dll' name 'glIndexPointerEXT';
    
    static procedure NormalPointerEXT(&type: ErrorCode; stride: Int32; count: Int32; _pointer: pointer);
    external 'opengl32.dll' name 'glNormalPointerEXT';
    
    static procedure TexCoordPointerEXT(size: Int32; &type: ErrorCode; stride: Int32; count: Int32; _pointer: pointer);
    external 'opengl32.dll' name 'glTexCoordPointerEXT';
    
    static procedure VertexPointerEXT(size: Int32; &type: ErrorCode; stride: Int32; count: Int32; _pointer: pointer);
    external 'opengl32.dll' name 'glVertexPointerEXT';
    
    static procedure VertexAttribL1dEXT(index: UInt32; x: double);
    external 'opengl32.dll' name 'glVertexAttribL1dEXT';
    
    static procedure VertexAttribL2dEXT(index: UInt32; x: double; y: double);
    external 'opengl32.dll' name 'glVertexAttribL2dEXT';
    
    static procedure VertexAttribL3dEXT(index: UInt32; x: double; y: double; z: double);
    external 'opengl32.dll' name 'glVertexAttribL3dEXT';
    
    static procedure VertexAttribL4dEXT(index: UInt32; x: double; y: double; z: double; w: double);
    external 'opengl32.dll' name 'glVertexAttribL4dEXT';
    
    static procedure VertexAttribL1dvEXT(index: UInt32; v: ^double);
    external 'opengl32.dll' name 'glVertexAttribL1dvEXT';
    
    static procedure VertexAttribL2dvEXT(index: UInt32; v: ^double);
    external 'opengl32.dll' name 'glVertexAttribL2dvEXT';
    
    static procedure VertexAttribL3dvEXT(index: UInt32; v: ^double);
    external 'opengl32.dll' name 'glVertexAttribL3dvEXT';
    
    static procedure VertexAttribL4dvEXT(index: UInt32; v: ^double);
    external 'opengl32.dll' name 'glVertexAttribL4dvEXT';
    
    static procedure VertexAttribLPointerEXT(index: UInt32; size: Int32; &type: ErrorCode; stride: Int32; _pointer: pointer);
    external 'opengl32.dll' name 'glVertexAttribLPointerEXT';
    
    static procedure GetVertexAttribLdvEXT(index: UInt32; pname: ErrorCode; &params: ^double);
    external 'opengl32.dll' name 'glGetVertexAttribLdvEXT';
    
    static procedure BeginVertexShaderEXT;
    external 'opengl32.dll' name 'glBeginVertexShaderEXT';
    
    static procedure EndVertexShaderEXT;
    external 'opengl32.dll' name 'glEndVertexShaderEXT';
    
    static procedure BindVertexShaderEXT(id: UInt32);
    external 'opengl32.dll' name 'glBindVertexShaderEXT';
    
    static function GenVertexShadersEXT(range: UInt32): UInt32;
    external 'opengl32.dll' name 'glGenVertexShadersEXT';
    
    static procedure DeleteVertexShaderEXT(id: UInt32);
    external 'opengl32.dll' name 'glDeleteVertexShaderEXT';
    
    static procedure ShaderOp1EXT(op: ErrorCode; res: UInt32; arg1: UInt32);
    external 'opengl32.dll' name 'glShaderOp1EXT';
    
    static procedure ShaderOp2EXT(op: ErrorCode; res: UInt32; arg1: UInt32; arg2: UInt32);
    external 'opengl32.dll' name 'glShaderOp2EXT';
    
    static procedure ShaderOp3EXT(op: ErrorCode; res: UInt32; arg1: UInt32; arg2: UInt32; arg3: UInt32);
    external 'opengl32.dll' name 'glShaderOp3EXT';
    
    static procedure SwizzleEXT(res: UInt32; &in: UInt32; outX: ErrorCode; outY: ErrorCode; outZ: ErrorCode; outW: ErrorCode);
    external 'opengl32.dll' name 'glSwizzleEXT';
    
    static procedure WriteMaskEXT(res: UInt32; &in: UInt32; outX: ErrorCode; outY: ErrorCode; outZ: ErrorCode; outW: ErrorCode);
    external 'opengl32.dll' name 'glWriteMaskEXT';
    
    static procedure InsertComponentEXT(res: UInt32; src: UInt32; num: UInt32);
    external 'opengl32.dll' name 'glInsertComponentEXT';
    
    static procedure ExtractComponentEXT(res: UInt32; src: UInt32; num: UInt32);
    external 'opengl32.dll' name 'glExtractComponentEXT';
    
    static function GenSymbolsEXT(datatype: ErrorCode; storagetype: ErrorCode; range: ErrorCode; components: UInt32): UInt32;
    external 'opengl32.dll' name 'glGenSymbolsEXT';
    
    static procedure SetInvariantEXT(id: UInt32; &type: ErrorCode; addr: pointer);
    external 'opengl32.dll' name 'glSetInvariantEXT';
    
    static procedure SetLocalConstantEXT(id: UInt32; &type: ErrorCode; addr: pointer);
    external 'opengl32.dll' name 'glSetLocalConstantEXT';
    
    static procedure VariantbvEXT(id: UInt32; addr: ^SByte);
    external 'opengl32.dll' name 'glVariantbvEXT';
    
    static procedure VariantsvEXT(id: UInt32; addr: ^Int16);
    external 'opengl32.dll' name 'glVariantsvEXT';
    
    static procedure VariantivEXT(id: UInt32; addr: ^Int32);
    external 'opengl32.dll' name 'glVariantivEXT';
    
    static procedure VariantfvEXT(id: UInt32; addr: ^single);
    external 'opengl32.dll' name 'glVariantfvEXT';
    
    static procedure VariantdvEXT(id: UInt32; addr: ^double);
    external 'opengl32.dll' name 'glVariantdvEXT';
    
    static procedure VariantubvEXT(id: UInt32; addr: ^Byte);
    external 'opengl32.dll' name 'glVariantubvEXT';
    
    static procedure VariantusvEXT(id: UInt32; addr: ^UInt16);
    external 'opengl32.dll' name 'glVariantusvEXT';
    
    static procedure VariantuivEXT(id: UInt32; addr: ^UInt32);
    external 'opengl32.dll' name 'glVariantuivEXT';
    
    static procedure VariantPointerEXT(id: UInt32; &type: ErrorCode; stride: UInt32; addr: pointer);
    external 'opengl32.dll' name 'glVariantPointerEXT';
    
    static procedure EnableVariantClientStateEXT(id: UInt32);
    external 'opengl32.dll' name 'glEnableVariantClientStateEXT';
    
    static procedure DisableVariantClientStateEXT(id: UInt32);
    external 'opengl32.dll' name 'glDisableVariantClientStateEXT';
    
    static function BindLightParameterEXT(light: ErrorCode; value: ErrorCode): UInt32;
    external 'opengl32.dll' name 'glBindLightParameterEXT';
    
    static function BindMaterialParameterEXT(face: ErrorCode; value: ErrorCode): UInt32;
    external 'opengl32.dll' name 'glBindMaterialParameterEXT';
    
    static function BindTexGenParameterEXT(&unit: ErrorCode; coord: ErrorCode; value: ErrorCode): UInt32;
    external 'opengl32.dll' name 'glBindTexGenParameterEXT';
    
    static function BindTextureUnitParameterEXT(&unit: ErrorCode; value: ErrorCode): UInt32;
    external 'opengl32.dll' name 'glBindTextureUnitParameterEXT';
    
    static function BindParameterEXT(value: ErrorCode): UInt32;
    external 'opengl32.dll' name 'glBindParameterEXT';
    
    static function IsVariantEnabledEXT(id: UInt32; cap: ErrorCode): Byte;
    external 'opengl32.dll' name 'glIsVariantEnabledEXT';
    
    static procedure GetVariantBooleanvEXT(id: UInt32; value: ErrorCode; data: ^Byte);
    external 'opengl32.dll' name 'glGetVariantBooleanvEXT';
    
    static procedure GetVariantIntegervEXT(id: UInt32; value: ErrorCode; data: ^Int32);
    external 'opengl32.dll' name 'glGetVariantIntegervEXT';
    
    static procedure GetVariantFloatvEXT(id: UInt32; value: ErrorCode; data: ^single);
    external 'opengl32.dll' name 'glGetVariantFloatvEXT';
    
    static procedure GetVariantPointervEXT(id: UInt32; value: ErrorCode; data: ^pointer);
    external 'opengl32.dll' name 'glGetVariantPointervEXT';
    
    static procedure GetInvariantBooleanvEXT(id: UInt32; value: ErrorCode; data: ^Byte);
    external 'opengl32.dll' name 'glGetInvariantBooleanvEXT';
    
    static procedure GetInvariantIntegervEXT(id: UInt32; value: ErrorCode; data: ^Int32);
    external 'opengl32.dll' name 'glGetInvariantIntegervEXT';
    
    static procedure GetInvariantFloatvEXT(id: UInt32; value: ErrorCode; data: ^single);
    external 'opengl32.dll' name 'glGetInvariantFloatvEXT';
    
    static procedure GetLocalConstantBooleanvEXT(id: UInt32; value: ErrorCode; data: ^Byte);
    external 'opengl32.dll' name 'glGetLocalConstantBooleanvEXT';
    
    static procedure GetLocalConstantIntegervEXT(id: UInt32; value: ErrorCode; data: ^Int32);
    external 'opengl32.dll' name 'glGetLocalConstantIntegervEXT';
    
    static procedure GetLocalConstantFloatvEXT(id: UInt32; value: ErrorCode; data: ^single);
    external 'opengl32.dll' name 'glGetLocalConstantFloatvEXT';
    
    static procedure VertexWeightfEXT(weight: single);
    external 'opengl32.dll' name 'glVertexWeightfEXT';
    
    static procedure VertexWeightfvEXT(weight: ^single);
    external 'opengl32.dll' name 'glVertexWeightfvEXT';
    
    static procedure VertexWeightPointerEXT(size: Int32; &type: ErrorCode; stride: Int32; _pointer: pointer);
    external 'opengl32.dll' name 'glVertexWeightPointerEXT';
    
    static function AcquireKeyedMutexWin32EXT(memory: UInt32; key: UInt64; timeout: UInt32): Byte;
    external 'opengl32.dll' name 'glAcquireKeyedMutexWin32EXT';
    
    static function ReleaseKeyedMutexWin32EXT(memory: UInt32; key: UInt64): Byte;
    external 'opengl32.dll' name 'glReleaseKeyedMutexWin32EXT';
    
    static function ImportSyncEXT(external_sync_type: ErrorCode; external_sync: IntPtr; flags: UInt32): GLsync;
    external 'opengl32.dll' name 'glImportSyncEXT';
    
    static procedure FramebufferTextureEXT(target: ErrorCode; attachment: ErrorCode; texture: UInt32; level: Int32);
    external 'opengl32.dll' name 'glFramebufferTextureEXT';
    
    static procedure FramebufferTextureFaceEXT(target: ErrorCode; attachment: ErrorCode; texture: UInt32; level: Int32; face: ErrorCode);
    external 'opengl32.dll' name 'glFramebufferTextureFaceEXT';
    
    static procedure VertexAttribI1iEXT(index: UInt32; x: Int32);
    external 'opengl32.dll' name 'glVertexAttribI1iEXT';
    
    static procedure VertexAttribI2iEXT(index: UInt32; x: Int32; y: Int32);
    external 'opengl32.dll' name 'glVertexAttribI2iEXT';
    
    static procedure VertexAttribI3iEXT(index: UInt32; x: Int32; y: Int32; z: Int32);
    external 'opengl32.dll' name 'glVertexAttribI3iEXT';
    
    static procedure VertexAttribI4iEXT(index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32);
    external 'opengl32.dll' name 'glVertexAttribI4iEXT';
    
    static procedure VertexAttribI1uiEXT(index: UInt32; x: UInt32);
    external 'opengl32.dll' name 'glVertexAttribI1uiEXT';
    
    static procedure VertexAttribI2uiEXT(index: UInt32; x: UInt32; y: UInt32);
    external 'opengl32.dll' name 'glVertexAttribI2uiEXT';
    
    static procedure VertexAttribI3uiEXT(index: UInt32; x: UInt32; y: UInt32; z: UInt32);
    external 'opengl32.dll' name 'glVertexAttribI3uiEXT';
    
    static procedure VertexAttribI4uiEXT(index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32);
    external 'opengl32.dll' name 'glVertexAttribI4uiEXT';
    
    static procedure VertexAttribI1ivEXT(index: UInt32; v: ^Int32);
    external 'opengl32.dll' name 'glVertexAttribI1ivEXT';
    
    static procedure VertexAttribI2ivEXT(index: UInt32; v: ^Int32);
    external 'opengl32.dll' name 'glVertexAttribI2ivEXT';
    
    static procedure VertexAttribI3ivEXT(index: UInt32; v: ^Int32);
    external 'opengl32.dll' name 'glVertexAttribI3ivEXT';
    
    static procedure VertexAttribI4ivEXT(index: UInt32; v: ^Int32);
    external 'opengl32.dll' name 'glVertexAttribI4ivEXT';
    
    static procedure VertexAttribI1uivEXT(index: UInt32; v: ^UInt32);
    external 'opengl32.dll' name 'glVertexAttribI1uivEXT';
    
    static procedure VertexAttribI2uivEXT(index: UInt32; v: ^UInt32);
    external 'opengl32.dll' name 'glVertexAttribI2uivEXT';
    
    static procedure VertexAttribI3uivEXT(index: UInt32; v: ^UInt32);
    external 'opengl32.dll' name 'glVertexAttribI3uivEXT';
    
    static procedure VertexAttribI4uivEXT(index: UInt32; v: ^UInt32);
    external 'opengl32.dll' name 'glVertexAttribI4uivEXT';
    
    static procedure VertexAttribI4bvEXT(index: UInt32; v: ^SByte);
    external 'opengl32.dll' name 'glVertexAttribI4bvEXT';
    
    static procedure VertexAttribI4svEXT(index: UInt32; v: ^Int16);
    external 'opengl32.dll' name 'glVertexAttribI4svEXT';
    
    static procedure VertexAttribI4ubvEXT(index: UInt32; v: ^Byte);
    external 'opengl32.dll' name 'glVertexAttribI4ubvEXT';
    
    static procedure VertexAttribI4usvEXT(index: UInt32; v: ^UInt16);
    external 'opengl32.dll' name 'glVertexAttribI4usvEXT';
    
    static procedure VertexAttribIPointerEXT(index: UInt32; size: Int32; &type: ErrorCode; stride: Int32; _pointer: pointer);
    external 'opengl32.dll' name 'glVertexAttribIPointerEXT';
    
    static procedure GetVertexAttribIivEXT(index: UInt32; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetVertexAttribIivEXT';
    
    static procedure GetVertexAttribIuivEXT(index: UInt32; pname: ErrorCode; &params: ^UInt32);
    external 'opengl32.dll' name 'glGetVertexAttribIuivEXT';
    
    {$endregion EXT}
    
  end;
  
  /// Расширения, которые встречаются только у видеокарт Intel
  gl_Intel = static class
    
    {$region INTEL}
    
    static procedure ApplyFramebufferAttachmentCMAAINTEL;
    external 'opengl32.dll' name 'glApplyFramebufferAttachmentCMAAINTEL';
    
    static procedure BeginPerfQueryINTEL(queryHandle: UInt32);
    external 'opengl32.dll' name 'glBeginPerfQueryINTEL';
    
    static procedure CreatePerfQueryINTEL(queryId: UInt32; queryHandle: ^UInt32);
    external 'opengl32.dll' name 'glCreatePerfQueryINTEL';
    
    static procedure DeletePerfQueryINTEL(queryHandle: UInt32);
    external 'opengl32.dll' name 'glDeletePerfQueryINTEL';
    
    static procedure EndPerfQueryINTEL(queryHandle: UInt32);
    external 'opengl32.dll' name 'glEndPerfQueryINTEL';
    
    static procedure GetFirstPerfQueryIdINTEL(queryId: ^UInt32);
    external 'opengl32.dll' name 'glGetFirstPerfQueryIdINTEL';
    
    static procedure GetNextPerfQueryIdINTEL(queryId: UInt32; nextQueryId: ^UInt32);
    external 'opengl32.dll' name 'glGetNextPerfQueryIdINTEL';
    
    static procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: ^SByte; counterDescLength: UInt32; counterDesc: ^SByte; counterOffset: ^UInt32; counterDataSize: ^UInt32; counterTypeEnum: ^UInt32; counterDataTypeEnum: ^UInt32; rawCounterMaxValue: ^UInt64);
    external 'opengl32.dll' name 'glGetPerfCounterInfoINTEL';
    
    static procedure GetPerfQueryDataINTEL(queryHandle: UInt32; flags: UInt32; dataSize: Int32; data: pointer; bytesWritten: ^UInt32);
    external 'opengl32.dll' name 'glGetPerfQueryDataINTEL';
    
    static procedure GetPerfQueryIdByNameINTEL(queryName: ^SByte; queryId: ^UInt32);
    external 'opengl32.dll' name 'glGetPerfQueryIdByNameINTEL';
    
    static procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: ^SByte; dataSize: ^UInt32; noCounters: ^UInt32; noInstances: ^UInt32; capsMask: ^UInt32);
    external 'opengl32.dll' name 'glGetPerfQueryInfoINTEL';
    
    static procedure SyncTextureINTEL(texture: UInt32);
    external 'opengl32.dll' name 'glSyncTextureINTEL';
    
    static procedure UnmapTexture2DINTEL(texture: UInt32; level: Int32);
    external 'opengl32.dll' name 'glUnmapTexture2DINTEL';
    
    static function MapTexture2DINTEL(texture: UInt32; level: Int32; access: UInt32; stride: ^Int32; layout: ^ErrorCode): pointer;
    external 'opengl32.dll' name 'glMapTexture2DINTEL';
    
    static procedure VertexPointervINTEL(size: Int32; &type: ErrorCode; _pointer: ^pointer);
    external 'opengl32.dll' name 'glVertexPointervINTEL';
    
    static procedure NormalPointervINTEL(&type: ErrorCode; _pointer: ^pointer);
    external 'opengl32.dll' name 'glNormalPointervINTEL';
    
    static procedure ColorPointervINTEL(size: Int32; &type: ErrorCode; _pointer: ^pointer);
    external 'opengl32.dll' name 'glColorPointervINTEL';
    
    static procedure TexCoordPointervINTEL(size: Int32; &type: ErrorCode; _pointer: ^pointer);
    external 'opengl32.dll' name 'glTexCoordPointervINTEL';
    
    {$endregion INTEL}
    
  end;
  
  /// Расширения, которые встречаются только у видеокарт NVidia
  gl_NVidia = static class
    
    {$region NVIDIA}
    
    static procedure MultiDrawArraysIndirectBindlessNV(mode: UInt32; indirect: pointer; drawCount: Int32; stride: Int32; vertexBufferCount: Int32);
    external 'opengl32.dll' name 'glMultiDrawArraysIndirectBindlessNV';
    
    static procedure MultiDrawElementsIndirectBindlessNV(mode: UInt32; &type: UInt32; indirect: pointer; drawCount: Int32; stride: Int32; vertexBufferCount: Int32);
    external 'opengl32.dll' name 'glMultiDrawElementsIndirectBindlessNV';
    
    static procedure MultiDrawArraysIndirectBindlessCountNV(mode: UInt32; indirect: pointer; drawCount: Int32; maxDrawCount: Int32; stride: Int32; vertexBufferCount: Int32);
    external 'opengl32.dll' name 'glMultiDrawArraysIndirectBindlessCountNV';
    
    static procedure MultiDrawElementsIndirectBindlessCountNV(mode: UInt32; &type: UInt32; indirect: pointer; drawCount: Int32; maxDrawCount: Int32; stride: Int32; vertexBufferCount: Int32);
    external 'opengl32.dll' name 'glMultiDrawElementsIndirectBindlessCountNV';
    
    static function GetTextureHandleNV(texture: UInt32): UInt64;
    external 'opengl32.dll' name 'glGetTextureHandleNV';
    
    static function GetTextureSamplerHandleNV(texture: UInt32; sampler: UInt32): UInt64;
    external 'opengl32.dll' name 'glGetTextureSamplerHandleNV';
    
    static procedure MakeTextureHandleResidentNV(handle: UInt64);
    external 'opengl32.dll' name 'glMakeTextureHandleResidentNV';
    
    static procedure MakeTextureHandleNonResidentNV(handle: UInt64);
    external 'opengl32.dll' name 'glMakeTextureHandleNonResidentNV';
    
    static function GetImageHandleNV(texture: UInt32; level: Int32; layered: boolean; layer: Int32; format: UInt32): UInt64;
    external 'opengl32.dll' name 'glGetImageHandleNV';
    
    static procedure MakeImageHandleResidentNV(handle: UInt64; access: UInt32);
    external 'opengl32.dll' name 'glMakeImageHandleResidentNV';
    
    static procedure MakeImageHandleNonResidentNV(handle: UInt64);
    external 'opengl32.dll' name 'glMakeImageHandleNonResidentNV';
    
    static procedure UniformHandleui64NV(location: Int32; value: UInt64);
    external 'opengl32.dll' name 'glUniformHandleui64NV';
    
    static procedure UniformHandleui64vNV(location: Int32; count: Int32; value: ^UInt64);
    external 'opengl32.dll' name 'glUniformHandleui64vNV';
    
    static procedure ProgramUniformHandleui64NV(&program: UInt32; location: Int32; value: UInt64);
    external 'opengl32.dll' name 'glProgramUniformHandleui64NV';
    
    static procedure ProgramUniformHandleui64vNV(&program: UInt32; location: Int32; count: Int32; values: ^UInt64);
    external 'opengl32.dll' name 'glProgramUniformHandleui64vNV';
    
    static function IsTextureHandleResidentNV(handle: UInt64): boolean;
    external 'opengl32.dll' name 'glIsTextureHandleResidentNV';
    
    static function IsImageHandleResidentNV(handle: UInt64): boolean;
    external 'opengl32.dll' name 'glIsImageHandleResidentNV';
    
    static procedure BlendParameteriNV(pname: UInt32; value: Int32);
    external 'opengl32.dll' name 'glBlendParameteriNV';
    
    static procedure BlendBarrierNV;
    external 'opengl32.dll' name 'glBlendBarrierNV';
    
    static procedure ViewportPositionWScaleNV(index: UInt32; xcoeff: single; ycoeff: single);
    external 'opengl32.dll' name 'glViewportPositionWScaleNV';
    
    static procedure CreateStatesNV(n: Int32; states: ^UInt32);
    external 'opengl32.dll' name 'glCreateStatesNV';
    
    static procedure DeleteStatesNV(n: Int32; states: ^UInt32);
    external 'opengl32.dll' name 'glDeleteStatesNV';
    
    static function IsStateNV(state: UInt32): boolean;
    external 'opengl32.dll' name 'glIsStateNV';
    
    static procedure StateCaptureNV(state: UInt32; mode: UInt32);
    external 'opengl32.dll' name 'glStateCaptureNV';
    
    static function GetCommandHeaderNV(tokenID: UInt32; size: UInt32): UInt32;
    external 'opengl32.dll' name 'glGetCommandHeaderNV';
    
    static function GetStageIndexNV(shadertype: UInt32): UInt16;
    external 'opengl32.dll' name 'glGetStageIndexNV';
    
    static procedure DrawCommandsNV(primitiveMode: UInt32; buffer: UInt32; indirects: ^IntPtr; sizes: ^Int32; count: UInt32);
    external 'opengl32.dll' name 'glDrawCommandsNV';
    
    static procedure DrawCommandsAddressNV(primitiveMode: UInt32; indirects: ^UInt64; sizes: ^Int32; count: UInt32);
    external 'opengl32.dll' name 'glDrawCommandsAddressNV';
    
    static procedure DrawCommandsStatesNV(buffer: UInt32; indirects: ^IntPtr; sizes: ^Int32; states: ^UInt32; fbos: ^UInt32; count: UInt32);
    external 'opengl32.dll' name 'glDrawCommandsStatesNV';
    
    static procedure DrawCommandsStatesAddressNV(indirects: ^UInt64; sizes: ^Int32; states: ^UInt32; fbos: ^UInt32; count: UInt32);
    external 'opengl32.dll' name 'glDrawCommandsStatesAddressNV';
    
    static procedure CreateCommandListsNV(n: Int32; lists: ^UInt32);
    external 'opengl32.dll' name 'glCreateCommandListsNV';
    
    static procedure DeleteCommandListsNV(n: Int32; lists: ^UInt32);
    external 'opengl32.dll' name 'glDeleteCommandListsNV';
    
    static function IsCommandListNV(list: UInt32): boolean;
    external 'opengl32.dll' name 'glIsCommandListNV';
    
    static procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: ^IntPtr; sizes: ^Int32; states: ^UInt32; fbos: ^UInt32; count: UInt32);
    external 'opengl32.dll' name 'glListDrawCommandsStatesClientNV';
    
    static procedure CommandListSegmentsNV(list: UInt32; segments: UInt32);
    external 'opengl32.dll' name 'glCommandListSegmentsNV';
    
    static procedure CompileCommandListNV(list: UInt32);
    external 'opengl32.dll' name 'glCompileCommandListNV';
    
    static procedure CallCommandListNV(list: UInt32);
    external 'opengl32.dll' name 'glCallCommandListNV';
    
    static procedure BeginConditionalRenderNV(id: UInt32; mode: UInt32);
    external 'opengl32.dll' name 'glBeginConditionalRenderNV';
    
    static procedure EndConditionalRenderNV;
    external 'opengl32.dll' name 'glEndConditionalRenderNV';
    
    static procedure SubpixelPrecisionBiasNV(xbits: UInt32; ybits: UInt32);
    external 'opengl32.dll' name 'glSubpixelPrecisionBiasNV';
    
    static procedure ConservativeRasterParameterfNV(pname: UInt32; value: single);
    external 'opengl32.dll' name 'glConservativeRasterParameterfNV';
    
    static procedure ConservativeRasterParameteriNV(pname: UInt32; param: Int32);
    external 'opengl32.dll' name 'glConservativeRasterParameteriNV';
    
    static procedure DrawVkImageNV(vkImage: UInt64; sampler: UInt32; x0: single; y0: single; x1: single; y1: single; z: single; s0: single; t0: single; s1: single; t1: single);
    external 'opengl32.dll' name 'glDrawVkImageNV';
    
    static function GetVkProcAddrNV(name: ^SByte): GLVULKANPROCNV;
    external 'opengl32.dll' name 'glGetVkProcAddrNV';
    
    static procedure WaitVkSemaphoreNV(vkSemaphore: UInt64);
    external 'opengl32.dll' name 'glWaitVkSemaphoreNV';
    
    static procedure SignalVkSemaphoreNV(vkSemaphore: UInt64);
    external 'opengl32.dll' name 'glSignalVkSemaphoreNV';
    
    static procedure SignalVkFenceNV(vkFence: UInt64);
    external 'opengl32.dll' name 'glSignalVkFenceNV';
    
    static procedure FragmentCoverageColorNV(color: UInt32);
    external 'opengl32.dll' name 'glFragmentCoverageColorNV';
    
    static procedure CoverageModulationTableNV(n: Int32; v: ^single);
    external 'opengl32.dll' name 'glCoverageModulationTableNV';
    
    static procedure GetCoverageModulationTableNV(bufsize: Int32; v: ^single);
    external 'opengl32.dll' name 'glGetCoverageModulationTableNV';
    
    static procedure CoverageModulationNV(components: UInt32);
    external 'opengl32.dll' name 'glCoverageModulationNV';
    
    static procedure RenderbufferStorageMultisampleCoverageNV(target: UInt32; coverageSamples: Int32; colorSamples: Int32; internalformat: UInt32; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glRenderbufferStorageMultisampleCoverageNV';
    
    static procedure Uniform1i64NV(location: Int32; x: Int64);
    external 'opengl32.dll' name 'glUniform1i64NV';
    
    static procedure Uniform2i64NV(location: Int32; x: Int64; y: Int64);
    external 'opengl32.dll' name 'glUniform2i64NV';
    
    static procedure Uniform3i64NV(location: Int32; x: Int64; y: Int64; z: Int64);
    external 'opengl32.dll' name 'glUniform3i64NV';
    
    static procedure Uniform4i64NV(location: Int32; x: Int64; y: Int64; z: Int64; w: Int64);
    external 'opengl32.dll' name 'glUniform4i64NV';
    
    static procedure Uniform1i64vNV(location: Int32; count: Int32; value: ^Int64);
    external 'opengl32.dll' name 'glUniform1i64vNV';
    
    static procedure Uniform2i64vNV(location: Int32; count: Int32; value: ^Int64);
    external 'opengl32.dll' name 'glUniform2i64vNV';
    
    static procedure Uniform3i64vNV(location: Int32; count: Int32; value: ^Int64);
    external 'opengl32.dll' name 'glUniform3i64vNV';
    
    static procedure Uniform4i64vNV(location: Int32; count: Int32; value: ^Int64);
    external 'opengl32.dll' name 'glUniform4i64vNV';
    
    static procedure Uniform1ui64NV(location: Int32; x: UInt64);
    external 'opengl32.dll' name 'glUniform1ui64NV';
    
    static procedure Uniform2ui64NV(location: Int32; x: UInt64; y: UInt64);
    external 'opengl32.dll' name 'glUniform2ui64NV';
    
    static procedure Uniform3ui64NV(location: Int32; x: UInt64; y: UInt64; z: UInt64);
    external 'opengl32.dll' name 'glUniform3ui64NV';
    
    static procedure Uniform4ui64NV(location: Int32; x: UInt64; y: UInt64; z: UInt64; w: UInt64);
    external 'opengl32.dll' name 'glUniform4ui64NV';
    
    static procedure Uniform1ui64vNV(location: Int32; count: Int32; value: ^UInt64);
    external 'opengl32.dll' name 'glUniform1ui64vNV';
    
    static procedure Uniform2ui64vNV(location: Int32; count: Int32; value: ^UInt64);
    external 'opengl32.dll' name 'glUniform2ui64vNV';
    
    static procedure Uniform3ui64vNV(location: Int32; count: Int32; value: ^UInt64);
    external 'opengl32.dll' name 'glUniform3ui64vNV';
    
    static procedure Uniform4ui64vNV(location: Int32; count: Int32; value: ^UInt64);
    external 'opengl32.dll' name 'glUniform4ui64vNV';
    
    static procedure GetUniformi64vNV(&program: UInt32; location: Int32; &params: ^Int64);
    external 'opengl32.dll' name 'glGetUniformi64vNV';
    
    static procedure ProgramUniform1i64NV(&program: UInt32; location: Int32; x: Int64);
    external 'opengl32.dll' name 'glProgramUniform1i64NV';
    
    static procedure ProgramUniform2i64NV(&program: UInt32; location: Int32; x: Int64; y: Int64);
    external 'opengl32.dll' name 'glProgramUniform2i64NV';
    
    static procedure ProgramUniform3i64NV(&program: UInt32; location: Int32; x: Int64; y: Int64; z: Int64);
    external 'opengl32.dll' name 'glProgramUniform3i64NV';
    
    static procedure ProgramUniform4i64NV(&program: UInt32; location: Int32; x: Int64; y: Int64; z: Int64; w: Int64);
    external 'opengl32.dll' name 'glProgramUniform4i64NV';
    
    static procedure ProgramUniform1i64vNV(&program: UInt32; location: Int32; count: Int32; value: ^Int64);
    external 'opengl32.dll' name 'glProgramUniform1i64vNV';
    
    static procedure ProgramUniform2i64vNV(&program: UInt32; location: Int32; count: Int32; value: ^Int64);
    external 'opengl32.dll' name 'glProgramUniform2i64vNV';
    
    static procedure ProgramUniform3i64vNV(&program: UInt32; location: Int32; count: Int32; value: ^Int64);
    external 'opengl32.dll' name 'glProgramUniform3i64vNV';
    
    static procedure ProgramUniform4i64vNV(&program: UInt32; location: Int32; count: Int32; value: ^Int64);
    external 'opengl32.dll' name 'glProgramUniform4i64vNV';
    
    static procedure ProgramUniform1ui64NV(&program: UInt32; location: Int32; x: UInt64);
    external 'opengl32.dll' name 'glProgramUniform1ui64NV';
    
    static procedure ProgramUniform2ui64NV(&program: UInt32; location: Int32; x: UInt64; y: UInt64);
    external 'opengl32.dll' name 'glProgramUniform2ui64NV';
    
    static procedure ProgramUniform3ui64NV(&program: UInt32; location: Int32; x: UInt64; y: UInt64; z: UInt64);
    external 'opengl32.dll' name 'glProgramUniform3ui64NV';
    
    static procedure ProgramUniform4ui64NV(&program: UInt32; location: Int32; x: UInt64; y: UInt64; z: UInt64; w: UInt64);
    external 'opengl32.dll' name 'glProgramUniform4ui64NV';
    
    static procedure ProgramUniform1ui64vNV(&program: UInt32; location: Int32; count: Int32; value: ^UInt64);
    external 'opengl32.dll' name 'glProgramUniform1ui64vNV';
    
    static procedure ProgramUniform2ui64vNV(&program: UInt32; location: Int32; count: Int32; value: ^UInt64);
    external 'opengl32.dll' name 'glProgramUniform2ui64vNV';
    
    static procedure ProgramUniform3ui64vNV(&program: UInt32; location: Int32; count: Int32; value: ^UInt64);
    external 'opengl32.dll' name 'glProgramUniform3ui64vNV';
    
    static procedure ProgramUniform4ui64vNV(&program: UInt32; location: Int32; count: Int32; value: ^UInt64);
    external 'opengl32.dll' name 'glProgramUniform4ui64vNV';
    
    static procedure GetInternalformatSampleivNV(target: UInt32; internalformat: UInt32; samples: Int32; pname: UInt32; bufSize: Int32; &params: ^Int32);
    external 'opengl32.dll' name 'glGetInternalformatSampleivNV';
    
    static procedure GetMemoryObjectDetachedResourcesuivNV(memory: UInt32; pname: UInt32; first: Int32; count: Int32; &params: ^UInt32);
    external 'opengl32.dll' name 'glGetMemoryObjectDetachedResourcesuivNV';
    
    static procedure ResetMemoryObjectParameterNV(memory: UInt32; pname: UInt32);
    external 'opengl32.dll' name 'glResetMemoryObjectParameterNV';
    
    static procedure TexAttachMemoryNV(target: UInt32; memory: UInt32; offset: UInt64);
    external 'opengl32.dll' name 'glTexAttachMemoryNV';
    
    static procedure BufferAttachMemoryNV(target: UInt32; memory: UInt32; offset: UInt64);
    external 'opengl32.dll' name 'glBufferAttachMemoryNV';
    
    static procedure TextureAttachMemoryNV(texture: UInt32; memory: UInt32; offset: UInt64);
    external 'opengl32.dll' name 'glTextureAttachMemoryNV';
    
    static procedure NamedBufferAttachMemoryNV(buffer: UInt32; memory: UInt32; offset: UInt64);
    external 'opengl32.dll' name 'glNamedBufferAttachMemoryNV';
    
    static procedure DrawMeshTasksNV(first: UInt32; count: UInt32);
    external 'opengl32.dll' name 'glDrawMeshTasksNV';
    
    static procedure DrawMeshTasksIndirectNV(indirect: IntPtr);
    external 'opengl32.dll' name 'glDrawMeshTasksIndirectNV';
    
    static procedure MultiDrawMeshTasksIndirectNV(indirect: IntPtr; drawcount: Int32; stride: Int32);
    external 'opengl32.dll' name 'glMultiDrawMeshTasksIndirectNV';
    
    static procedure MultiDrawMeshTasksIndirectCountNV(indirect: IntPtr; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32);
    external 'opengl32.dll' name 'glMultiDrawMeshTasksIndirectCountNV';
    
    static function GenPathsNV(range: Int32): UInt32;
    external 'opengl32.dll' name 'glGenPathsNV';
    
    static procedure DeletePathsNV(path: UInt32; range: Int32);
    external 'opengl32.dll' name 'glDeletePathsNV';
    
    static function IsPathNV(path: UInt32): boolean;
    external 'opengl32.dll' name 'glIsPathNV';
    
    static procedure PathCommandsNV(path: UInt32; numCommands: Int32; commands: ^Byte; numCoords: Int32; coordType: UInt32; coords: pointer);
    external 'opengl32.dll' name 'glPathCommandsNV';
    
    static procedure PathCoordsNV(path: UInt32; numCoords: Int32; coordType: UInt32; coords: pointer);
    external 'opengl32.dll' name 'glPathCoordsNV';
    
    static procedure PathSubCommandsNV(path: UInt32; commandStart: Int32; commandsToDelete: Int32; numCommands: Int32; commands: ^Byte; numCoords: Int32; coordType: UInt32; coords: pointer);
    external 'opengl32.dll' name 'glPathSubCommandsNV';
    
    static procedure PathSubCoordsNV(path: UInt32; coordStart: Int32; numCoords: Int32; coordType: UInt32; coords: pointer);
    external 'opengl32.dll' name 'glPathSubCoordsNV';
    
    static procedure PathStringNV(path: UInt32; format: UInt32; length: Int32; pathString: pointer);
    external 'opengl32.dll' name 'glPathStringNV';
    
    static procedure PathGlyphsNV(firstPathName: UInt32; fontTarget: UInt32; fontName: pointer; fontStyle: UInt32; numGlyphs: Int32; &type: UInt32; charcodes: pointer; handleMissingGlyphs: UInt32; pathParameterTemplate: UInt32; emScale: single);
    external 'opengl32.dll' name 'glPathGlyphsNV';
    
    static procedure PathGlyphRangeNV(firstPathName: UInt32; fontTarget: UInt32; fontName: pointer; fontStyle: UInt32; firstGlyph: UInt32; numGlyphs: Int32; handleMissingGlyphs: UInt32; pathParameterTemplate: UInt32; emScale: single);
    external 'opengl32.dll' name 'glPathGlyphRangeNV';
    
    static procedure WeightPathsNV(resultPath: UInt32; numPaths: Int32; paths: ^UInt32; weights: ^single);
    external 'opengl32.dll' name 'glWeightPathsNV';
    
    static procedure CopyPathNV(resultPath: UInt32; srcPath: UInt32);
    external 'opengl32.dll' name 'glCopyPathNV';
    
    static procedure InterpolatePathsNV(resultPath: UInt32; pathA: UInt32; pathB: UInt32; weight: single);
    external 'opengl32.dll' name 'glInterpolatePathsNV';
    
    static procedure TransformPathNV(resultPath: UInt32; srcPath: UInt32; transformType: UInt32; transformValues: ^single);
    external 'opengl32.dll' name 'glTransformPathNV';
    
    static procedure PathParameterivNV(path: UInt32; pname: UInt32; value: ^Int32);
    external 'opengl32.dll' name 'glPathParameterivNV';
    
    static procedure PathParameteriNV(path: UInt32; pname: UInt32; value: Int32);
    external 'opengl32.dll' name 'glPathParameteriNV';
    
    static procedure PathParameterfvNV(path: UInt32; pname: UInt32; value: ^single);
    external 'opengl32.dll' name 'glPathParameterfvNV';
    
    static procedure PathParameterfNV(path: UInt32; pname: UInt32; value: single);
    external 'opengl32.dll' name 'glPathParameterfNV';
    
    static procedure PathDashArrayNV(path: UInt32; dashCount: Int32; dashArray: ^single);
    external 'opengl32.dll' name 'glPathDashArrayNV';
    
    static procedure PathStencilFuncNV(func: UInt32; ref: Int32; mask: UInt32);
    external 'opengl32.dll' name 'glPathStencilFuncNV';
    
    static procedure PathStencilDepthOffsetNV(factor: single; units: single);
    external 'opengl32.dll' name 'glPathStencilDepthOffsetNV';
    
    static procedure StencilFillPathNV(path: UInt32; fillMode: UInt32; mask: UInt32);
    external 'opengl32.dll' name 'glStencilFillPathNV';
    
    static procedure StencilStrokePathNV(path: UInt32; reference: Int32; mask: UInt32);
    external 'opengl32.dll' name 'glStencilStrokePathNV';
    
    static procedure StencilFillPathInstancedNV(numPaths: Int32; pathNameType: UInt32; paths: pointer; pathBase: UInt32; fillMode: UInt32; mask: UInt32; transformType: UInt32; transformValues: ^single);
    external 'opengl32.dll' name 'glStencilFillPathInstancedNV';
    
    static procedure StencilStrokePathInstancedNV(numPaths: Int32; pathNameType: UInt32; paths: pointer; pathBase: UInt32; reference: Int32; mask: UInt32; transformType: UInt32; transformValues: ^single);
    external 'opengl32.dll' name 'glStencilStrokePathInstancedNV';
    
    static procedure PathCoverDepthFuncNV(func: UInt32);
    external 'opengl32.dll' name 'glPathCoverDepthFuncNV';
    
    static procedure CoverFillPathNV(path: UInt32; coverMode: UInt32);
    external 'opengl32.dll' name 'glCoverFillPathNV';
    
    static procedure CoverStrokePathNV(path: UInt32; coverMode: UInt32);
    external 'opengl32.dll' name 'glCoverStrokePathNV';
    
    static procedure CoverFillPathInstancedNV(numPaths: Int32; pathNameType: UInt32; paths: pointer; pathBase: UInt32; coverMode: UInt32; transformType: UInt32; transformValues: ^single);
    external 'opengl32.dll' name 'glCoverFillPathInstancedNV';
    
    static procedure CoverStrokePathInstancedNV(numPaths: Int32; pathNameType: UInt32; paths: pointer; pathBase: UInt32; coverMode: UInt32; transformType: UInt32; transformValues: ^single);
    external 'opengl32.dll' name 'glCoverStrokePathInstancedNV';
    
    static procedure GetPathParameterivNV(path: UInt32; pname: UInt32; value: ^Int32);
    external 'opengl32.dll' name 'glGetPathParameterivNV';
    
    static procedure GetPathParameterfvNV(path: UInt32; pname: UInt32; value: ^single);
    external 'opengl32.dll' name 'glGetPathParameterfvNV';
    
    static procedure GetPathCommandsNV(path: UInt32; commands: ^Byte);
    external 'opengl32.dll' name 'glGetPathCommandsNV';
    
    static procedure GetPathCoordsNV(path: UInt32; coords: ^single);
    external 'opengl32.dll' name 'glGetPathCoordsNV';
    
    static procedure GetPathDashArrayNV(path: UInt32; dashArray: ^single);
    external 'opengl32.dll' name 'glGetPathDashArrayNV';
    
    static procedure GetPathMetricsNV(metricQueryMask: UInt32; numPaths: Int32; pathNameType: UInt32; paths: pointer; pathBase: UInt32; stride: Int32; metrics: ^single);
    external 'opengl32.dll' name 'glGetPathMetricsNV';
    
    static procedure GetPathMetricRangeNV(metricQueryMask: UInt32; firstPathName: UInt32; numPaths: Int32; stride: Int32; metrics: ^single);
    external 'opengl32.dll' name 'glGetPathMetricRangeNV';
    
    static procedure GetPathSpacingNV(pathListMode: UInt32; numPaths: Int32; pathNameType: UInt32; paths: pointer; pathBase: UInt32; advanceScale: single; kerningScale: single; transformType: UInt32; returnedSpacing: ^single);
    external 'opengl32.dll' name 'glGetPathSpacingNV';
    
    static function IsPointInFillPathNV(path: UInt32; mask: UInt32; x: single; y: single): boolean;
    external 'opengl32.dll' name 'glIsPointInFillPathNV';
    
    static function IsPointInStrokePathNV(path: UInt32; x: single; y: single): boolean;
    external 'opengl32.dll' name 'glIsPointInStrokePathNV';
    
    static function GetPathLengthNV(path: UInt32; startSegment: Int32; numSegments: Int32): single;
    external 'opengl32.dll' name 'glGetPathLengthNV';
    
    static function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: ^single; y: ^single; tangentX: ^single; tangentY: ^single): boolean;
    external 'opengl32.dll' name 'glPointAlongPathNV';
    
    static procedure MatrixLoad3x2fNV(matrixMode: UInt32; m: ^single);
    external 'opengl32.dll' name 'glMatrixLoad3x2fNV';
    
    static procedure MatrixLoad3x3fNV(matrixMode: UInt32; m: ^single);
    external 'opengl32.dll' name 'glMatrixLoad3x3fNV';
    
    static procedure MatrixLoadTranspose3x3fNV(matrixMode: UInt32; m: ^single);
    external 'opengl32.dll' name 'glMatrixLoadTranspose3x3fNV';
    
    static procedure MatrixMult3x2fNV(matrixMode: UInt32; m: ^single);
    external 'opengl32.dll' name 'glMatrixMult3x2fNV';
    
    static procedure MatrixMult3x3fNV(matrixMode: UInt32; m: ^single);
    external 'opengl32.dll' name 'glMatrixMult3x3fNV';
    
    static procedure MatrixMultTranspose3x3fNV(matrixMode: UInt32; m: ^single);
    external 'opengl32.dll' name 'glMatrixMultTranspose3x3fNV';
    
    static procedure StencilThenCoverFillPathNV(path: UInt32; fillMode: UInt32; mask: UInt32; coverMode: UInt32);
    external 'opengl32.dll' name 'glStencilThenCoverFillPathNV';
    
    static procedure StencilThenCoverStrokePathNV(path: UInt32; reference: Int32; mask: UInt32; coverMode: UInt32);
    external 'opengl32.dll' name 'glStencilThenCoverStrokePathNV';
    
    static procedure StencilThenCoverFillPathInstancedNV(numPaths: Int32; pathNameType: UInt32; paths: pointer; pathBase: UInt32; fillMode: UInt32; mask: UInt32; coverMode: UInt32; transformType: UInt32; transformValues: ^single);
    external 'opengl32.dll' name 'glStencilThenCoverFillPathInstancedNV';
    
    static procedure StencilThenCoverStrokePathInstancedNV(numPaths: Int32; pathNameType: UInt32; paths: pointer; pathBase: UInt32; reference: Int32; mask: UInt32; coverMode: UInt32; transformType: UInt32; transformValues: ^single);
    external 'opengl32.dll' name 'glStencilThenCoverStrokePathInstancedNV';
    
    static function PathGlyphIndexRangeNV(fontTarget: UInt32; fontName: pointer; fontStyle: UInt32; pathParameterTemplate: UInt32; emScale: single; baseAndCount: ^Vec2ui): UInt32;
    external 'opengl32.dll' name 'glPathGlyphIndexRangeNV';
    
    static function PathGlyphIndexArrayNV(firstPathName: UInt32; fontTarget: UInt32; fontName: pointer; fontStyle: UInt32; firstGlyphIndex: UInt32; numGlyphs: Int32; pathParameterTemplate: UInt32; emScale: single): UInt32;
    external 'opengl32.dll' name 'glPathGlyphIndexArrayNV';
    
    static function PathMemoryGlyphIndexArrayNV(firstPathName: UInt32; fontTarget: UInt32; fontSize: UIntPtr; fontData: pointer; faceIndex: Int32; firstGlyphIndex: UInt32; numGlyphs: Int32; pathParameterTemplate: UInt32; emScale: single): UInt32;
    external 'opengl32.dll' name 'glPathMemoryGlyphIndexArrayNV';
    
    static procedure ProgramPathFragmentInputGenNV(&program: UInt32; location: Int32; genMode: UInt32; components: Int32; coeffs: ^single);
    external 'opengl32.dll' name 'glProgramPathFragmentInputGenNV';
    
    static procedure GetProgramResourcefvNV(&program: UInt32; programInterface: UInt32; index: UInt32; propCount: Int32; props: ^UInt32; bufSize: Int32; length: ^Int32; &params: ^single);
    external 'opengl32.dll' name 'glGetProgramResourcefvNV';
    
    static procedure FramebufferSampleLocationsfvNV(target: UInt32; start: UInt32; count: Int32; v: ^single);
    external 'opengl32.dll' name 'glFramebufferSampleLocationsfvNV';
    
    static procedure NamedFramebufferSampleLocationsfvNV(framebuffer: UInt32; start: UInt32; count: Int32; v: ^single);
    external 'opengl32.dll' name 'glNamedFramebufferSampleLocationsfvNV';
    
    static procedure ResolveDepthValuesNV;
    external 'opengl32.dll' name 'glResolveDepthValuesNV';
    
    static procedure ScissorExclusiveNV(x: Int32; y: Int32; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glScissorExclusiveNV';
    
    static procedure ScissorExclusiveArrayvNV(first: UInt32; count: Int32; v: ^Int32);
    external 'opengl32.dll' name 'glScissorExclusiveArrayvNV';
    
    static procedure MakeBufferResidentNV(target: UInt32; access: UInt32);
    external 'opengl32.dll' name 'glMakeBufferResidentNV';
    
    static procedure MakeBufferNonResidentNV(target: UInt32);
    external 'opengl32.dll' name 'glMakeBufferNonResidentNV';
    
    static function IsBufferResidentNV(target: UInt32): boolean;
    external 'opengl32.dll' name 'glIsBufferResidentNV';
    
    static procedure MakeNamedBufferResidentNV(buffer: UInt32; access: UInt32);
    external 'opengl32.dll' name 'glMakeNamedBufferResidentNV';
    
    static procedure MakeNamedBufferNonResidentNV(buffer: UInt32);
    external 'opengl32.dll' name 'glMakeNamedBufferNonResidentNV';
    
    static function IsNamedBufferResidentNV(buffer: UInt32): boolean;
    external 'opengl32.dll' name 'glIsNamedBufferResidentNV';
    
    static procedure GetBufferParameterui64vNV(target: UInt32; pname: UInt32; &params: ^UInt64);
    external 'opengl32.dll' name 'glGetBufferParameterui64vNV';
    
    static procedure GetNamedBufferParameterui64vNV(buffer: UInt32; pname: UInt32; &params: ^UInt64);
    external 'opengl32.dll' name 'glGetNamedBufferParameterui64vNV';
    
    static procedure GetIntegerui64vNV(value: UInt32; result: ^UInt64);
    external 'opengl32.dll' name 'glGetIntegerui64vNV';
    
    static procedure Uniformui64NV(location: Int32; value: UInt64);
    external 'opengl32.dll' name 'glUniformui64NV';
    
    static procedure Uniformui64vNV(location: Int32; count: Int32; value: ^UInt64);
    external 'opengl32.dll' name 'glUniformui64vNV';
    
    static procedure GetUniformui64vNV(&program: UInt32; location: Int32; &params: ^UInt64);
    external 'opengl32.dll' name 'glGetUniformui64vNV';
    
    static procedure ProgramUniformui64NV(&program: UInt32; location: Int32; value: UInt64);
    external 'opengl32.dll' name 'glProgramUniformui64NV';
    
    static procedure ProgramUniformui64vNV(&program: UInt32; location: Int32; count: Int32; value: ^UInt64);
    external 'opengl32.dll' name 'glProgramUniformui64vNV';
    
    static procedure BindShadingRateImageNV(texture: UInt32);
    external 'opengl32.dll' name 'glBindShadingRateImageNV';
    
    static procedure GetShadingRateImagePaletteNV(viewport: UInt32; entry: UInt32; rate: ^UInt32);
    external 'opengl32.dll' name 'glGetShadingRateImagePaletteNV';
    
    static procedure GetShadingRateSampleLocationivNV(rate: UInt32; samples: UInt32; index: UInt32; location: ^Int32);
    external 'opengl32.dll' name 'glGetShadingRateSampleLocationivNV';
    
    static procedure ShadingRateImageBarrierNV(synchronize: boolean);
    external 'opengl32.dll' name 'glShadingRateImageBarrierNV';
    
    static procedure ShadingRateImagePaletteNV(viewport: UInt32; first: UInt32; count: Int32; rates: ^UInt32);
    external 'opengl32.dll' name 'glShadingRateImagePaletteNV';
    
    static procedure ShadingRateSampleOrderNV(order: UInt32);
    external 'opengl32.dll' name 'glShadingRateSampleOrderNV';
    
    static procedure ShadingRateSampleOrderCustomNV(rate: UInt32; samples: UInt32; locations: ^Int32);
    external 'opengl32.dll' name 'glShadingRateSampleOrderCustomNV';
    
    static procedure TextureBarrierNV;
    external 'opengl32.dll' name 'glTextureBarrierNV';
    
    static procedure GetVertexAttribLi64vNV(index: UInt32; pname: UInt32; &params: ^Int64);
    external 'opengl32.dll' name 'glGetVertexAttribLi64vNV';
    
    static procedure GetVertexAttribLui64vNV(index: UInt32; pname: UInt32; &params: ^UInt64);
    external 'opengl32.dll' name 'glGetVertexAttribLui64vNV';
    
    static procedure BufferAddressRangeNV(pname: UInt32; index: UInt32; address: UInt64; length: UIntPtr);
    external 'opengl32.dll' name 'glBufferAddressRangeNV';
    
    static procedure VertexFormatNV(size: Int32; &type: UInt32; stride: Int32);
    external 'opengl32.dll' name 'glVertexFormatNV';
    
    static procedure NormalFormatNV(&type: UInt32; stride: Int32);
    external 'opengl32.dll' name 'glNormalFormatNV';
    
    static procedure ColorFormatNV(size: Int32; &type: UInt32; stride: Int32);
    external 'opengl32.dll' name 'glColorFormatNV';
    
    static procedure IndexFormatNV(&type: UInt32; stride: Int32);
    external 'opengl32.dll' name 'glIndexFormatNV';
    
    static procedure TexCoordFormatNV(size: Int32; &type: UInt32; stride: Int32);
    external 'opengl32.dll' name 'glTexCoordFormatNV';
    
    static procedure EdgeFlagFormatNV(stride: Int32);
    external 'opengl32.dll' name 'glEdgeFlagFormatNV';
    
    static procedure SecondaryColorFormatNV(size: Int32; &type: UInt32; stride: Int32);
    external 'opengl32.dll' name 'glSecondaryColorFormatNV';
    
    static procedure FogCoordFormatNV(&type: UInt32; stride: Int32);
    external 'opengl32.dll' name 'glFogCoordFormatNV';
    
    static procedure GetIntegerui64i_vNV(value: UInt32; index: UInt32; result: ^UInt64);
    external 'opengl32.dll' name 'glGetIntegerui64i_vNV';
    
    static procedure ViewportSwizzleNV(index: UInt32; swizzlex: UInt32; swizzley: UInt32; swizzlez: UInt32; swizzlew: UInt32);
    external 'opengl32.dll' name 'glViewportSwizzleNV';
    
    static procedure VertexAttribFormatNV(index: UInt32; size: Int32; &type: UInt32; normalized: boolean; stride: Int32);
    external 'opengl32.dll' name 'glVertexAttribFormatNV';
    
    static procedure VertexAttribIFormatNV(index: UInt32; size: Int32; &type: UInt32; stride: Int32);
    external 'opengl32.dll' name 'glVertexAttribIFormatNV';
    
    static procedure VertexAttribLFormatNV(index: UInt32; size: Int32; &type: UInt32; stride: Int32);
    external 'opengl32.dll' name 'glVertexAttribLFormatNV';
    
    static procedure VertexAttribL1i64NV(index: UInt32; x: Int64);
    external 'opengl32.dll' name 'glVertexAttribL1i64NV';
    
    static procedure VertexAttribL2i64NV(index: UInt32; x: Int64; y: Int64);
    external 'opengl32.dll' name 'glVertexAttribL2i64NV';
    
    static procedure VertexAttribL3i64NV(index: UInt32; x: Int64; y: Int64; z: Int64);
    external 'opengl32.dll' name 'glVertexAttribL3i64NV';
    
    static procedure VertexAttribL4i64NV(index: UInt32; x: Int64; y: Int64; z: Int64; w: Int64);
    external 'opengl32.dll' name 'glVertexAttribL4i64NV';
    
    static procedure VertexAttribL1i64vNV(index: UInt32; v: ^Int64);
    external 'opengl32.dll' name 'glVertexAttribL1i64vNV';
    
    static procedure VertexAttribL2i64vNV(index: UInt32; v: ^Int64);
    external 'opengl32.dll' name 'glVertexAttribL2i64vNV';
    
    static procedure VertexAttribL3i64vNV(index: UInt32; v: ^Int64);
    external 'opengl32.dll' name 'glVertexAttribL3i64vNV';
    
    static procedure VertexAttribL4i64vNV(index: UInt32; v: ^Int64);
    external 'opengl32.dll' name 'glVertexAttribL4i64vNV';
    
    static procedure VertexAttribL1ui64NV(index: UInt32; x: UInt64);
    external 'opengl32.dll' name 'glVertexAttribL1ui64NV';
    
    static procedure VertexAttribL2ui64NV(index: UInt32; x: UInt64; y: UInt64);
    external 'opengl32.dll' name 'glVertexAttribL2ui64NV';
    
    static procedure VertexAttribL3ui64NV(index: UInt32; x: UInt64; y: UInt64; z: UInt64);
    external 'opengl32.dll' name 'glVertexAttribL3ui64NV';
    
    static procedure VertexAttribL4ui64NV(index: UInt32; x: UInt64; y: UInt64; z: UInt64; w: UInt64);
    external 'opengl32.dll' name 'glVertexAttribL4ui64NV';
    
    static procedure VertexAttribL1ui64vNV(index: UInt32; v: ^UInt64);
    external 'opengl32.dll' name 'glVertexAttribL1ui64vNV';
    
    static procedure VertexAttribL2ui64vNV(index: UInt32; v: ^UInt64);
    external 'opengl32.dll' name 'glVertexAttribL2ui64vNV';
    
    static procedure VertexAttribL3ui64vNV(index: UInt32; v: ^UInt64);
    external 'opengl32.dll' name 'glVertexAttribL3ui64vNV';
    
    static procedure VertexAttribL4ui64vNV(index: UInt32; v: ^UInt64);
    external 'opengl32.dll' name 'glVertexAttribL4ui64vNV';
    
    static procedure BeginConditionalRenderNVX(id: UInt32);
    external 'opengl32.dll' name 'glBeginConditionalRenderNVX';
    
    static procedure EndConditionalRenderNVX;
    external 'opengl32.dll' name 'glEndConditionalRenderNVX';
    
    static procedure LGPUNamedBufferSubDataNVX(gpuMask: UInt32; buffer: UInt32; offset: IntPtr; size: UIntPtr; data: pointer);
    external 'opengl32.dll' name 'glLGPUNamedBufferSubDataNVX';
    
    static procedure LGPUCopyImageSubDataNVX(sourceGpu: UInt32; destinationGpuMask: UInt32; srcName: UInt32; srcTarget: ErrorCode; srcLevel: Int32; srcX: Int32; srxY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: ErrorCode; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; width: Int32; height: Int32; depth: Int32);
    external 'opengl32.dll' name 'glLGPUCopyImageSubDataNVX';
    
    static procedure LGPUInterlockNVX;
    external 'opengl32.dll' name 'glLGPUInterlockNVX';
    
    static procedure AlphaToCoverageDitherControlNV(mode: ErrorCode);
    external 'opengl32.dll' name 'glAlphaToCoverageDitherControlNV';
    
    static procedure CopyImageSubDataNV(srcName: UInt32; srcTarget: ErrorCode; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: ErrorCode; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; width: Int32; height: Int32; depth: Int32);
    external 'opengl32.dll' name 'glCopyImageSubDataNV';
    
    static procedure DepthRangedNV(zNear: double; zFar: double);
    external 'opengl32.dll' name 'glDepthRangedNV';
    
    static procedure ClearDepthdNV(depth: double);
    external 'opengl32.dll' name 'glClearDepthdNV';
    
    static procedure DepthBoundsdNV(zmin: double; zmax: double);
    external 'opengl32.dll' name 'glDepthBoundsdNV';
    
    static procedure DrawTextureNV(texture: UInt32; sampler: UInt32; x0: single; y0: single; x1: single; y1: single; z: single; s0: single; t0: single; s1: single; t1: single);
    external 'opengl32.dll' name 'glDrawTextureNV';
    
    static procedure MapControlPointsNV(target: ErrorCode; index: UInt32; &type: ErrorCode; ustride: Int32; vstride: Int32; uorder: Int32; vorder: Int32; &packed: Byte; points: pointer);
    external 'opengl32.dll' name 'glMapControlPointsNV';
    
    static procedure MapParameterivNV(target: ErrorCode; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glMapParameterivNV';
    
    static procedure MapParameterfvNV(target: ErrorCode; pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glMapParameterfvNV';
    
    static procedure GetMapControlPointsNV(target: ErrorCode; index: UInt32; &type: ErrorCode; ustride: Int32; vstride: Int32; &packed: Byte; points: pointer);
    external 'opengl32.dll' name 'glGetMapControlPointsNV';
    
    static procedure GetMapParameterivNV(target: ErrorCode; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetMapParameterivNV';
    
    static procedure GetMapParameterfvNV(target: ErrorCode; pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glGetMapParameterfvNV';
    
    static procedure GetMapAttribParameterivNV(target: ErrorCode; index: UInt32; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetMapAttribParameterivNV';
    
    static procedure GetMapAttribParameterfvNV(target: ErrorCode; index: UInt32; pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glGetMapAttribParameterfvNV';
    
    static procedure EvalMapsNV(target: ErrorCode; mode: ErrorCode);
    external 'opengl32.dll' name 'glEvalMapsNV';
    
    static procedure GetMultisamplefvNV(pname: ErrorCode; index: UInt32; val: ^single);
    external 'opengl32.dll' name 'glGetMultisamplefvNV';
    
    static procedure SampleMaskIndexedNV(index: UInt32; mask: UInt32);
    external 'opengl32.dll' name 'glSampleMaskIndexedNV';
    
    static procedure TexRenderbufferNV(target: ErrorCode; renderbuffer: UInt32);
    external 'opengl32.dll' name 'glTexRenderbufferNV';
    
    static procedure DeleteFencesNV(n: Int32; fences: ^UInt32);
    external 'opengl32.dll' name 'glDeleteFencesNV';
    
    static procedure GenFencesNV(n: Int32; fences: ^UInt32);
    external 'opengl32.dll' name 'glGenFencesNV';
    
    static function IsFenceNV(fence: UInt32): Byte;
    external 'opengl32.dll' name 'glIsFenceNV';
    
    static function TestFenceNV(fence: UInt32): Byte;
    external 'opengl32.dll' name 'glTestFenceNV';
    
    static procedure GetFenceivNV(fence: UInt32; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetFenceivNV';
    
    static procedure FinishFenceNV(fence: UInt32);
    external 'opengl32.dll' name 'glFinishFenceNV';
    
    static procedure SetFenceNV(fence: UInt32; condition: ErrorCode);
    external 'opengl32.dll' name 'glSetFenceNV';
    
    static procedure ProgramNamedParameter4fNV(id: UInt32; len: Int32; name: ^Byte; x: single; y: single; z: single; w: single);
    external 'opengl32.dll' name 'glProgramNamedParameter4fNV';
    
    static procedure ProgramNamedParameter4fvNV(id: UInt32; len: Int32; name: ^Byte; v: ^single);
    external 'opengl32.dll' name 'glProgramNamedParameter4fvNV';
    
    static procedure ProgramNamedParameter4dNV(id: UInt32; len: Int32; name: ^Byte; x: double; y: double; z: double; w: double);
    external 'opengl32.dll' name 'glProgramNamedParameter4dNV';
    
    static procedure ProgramNamedParameter4dvNV(id: UInt32; len: Int32; name: ^Byte; v: ^double);
    external 'opengl32.dll' name 'glProgramNamedParameter4dvNV';
    
    static procedure GetProgramNamedParameterfvNV(id: UInt32; len: Int32; name: ^Byte; &params: ^single);
    external 'opengl32.dll' name 'glGetProgramNamedParameterfvNV';
    
    static procedure GetProgramNamedParameterdvNV(id: UInt32; len: Int32; name: ^Byte; &params: ^double);
    external 'opengl32.dll' name 'glGetProgramNamedParameterdvNV';
    
    static procedure ProgramVertexLimitNV(target: ErrorCode; limit: Int32);
    external 'opengl32.dll' name 'glProgramVertexLimitNV';
    
    static procedure RenderGpuMaskNV(mask: UInt32);
    external 'opengl32.dll' name 'glRenderGpuMaskNV';
    
    static procedure MulticastBufferSubDataNV(gpuMask: UInt32; buffer: UInt32; offset: IntPtr; size: UIntPtr; data: pointer);
    external 'opengl32.dll' name 'glMulticastBufferSubDataNV';
    
    static procedure MulticastCopyBufferSubDataNV(readGpu: UInt32; writeGpuMask: UInt32; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr);
    external 'opengl32.dll' name 'glMulticastCopyBufferSubDataNV';
    
    static procedure MulticastCopyImageSubDataNV(srcGpu: UInt32; dstGpuMask: UInt32; srcName: UInt32; srcTarget: ErrorCode; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: ErrorCode; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32);
    external 'opengl32.dll' name 'glMulticastCopyImageSubDataNV';
    
    static procedure MulticastBlitFramebufferNV(srcGpu: UInt32; dstGpu: UInt32; srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: UInt32; filter: ErrorCode);
    external 'opengl32.dll' name 'glMulticastBlitFramebufferNV';
    
    static procedure MulticastFramebufferSampleLocationsfvNV(gpu: UInt32; framebuffer: UInt32; start: UInt32; count: Int32; v: ^single);
    external 'opengl32.dll' name 'glMulticastFramebufferSampleLocationsfvNV';
    
    static procedure MulticastBarrierNV;
    external 'opengl32.dll' name 'glMulticastBarrierNV';
    
    static procedure MulticastWaitSyncNV(signalGpu: UInt32; waitGpuMask: UInt32);
    external 'opengl32.dll' name 'glMulticastWaitSyncNV';
    
    static procedure MulticastGetQueryObjectivNV(gpu: UInt32; id: UInt32; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glMulticastGetQueryObjectivNV';
    
    static procedure MulticastGetQueryObjectuivNV(gpu: UInt32; id: UInt32; pname: ErrorCode; &params: ^UInt32);
    external 'opengl32.dll' name 'glMulticastGetQueryObjectuivNV';
    
    static procedure MulticastGetQueryObjecti64vNV(gpu: UInt32; id: UInt32; pname: ErrorCode; &params: ^Int64);
    external 'opengl32.dll' name 'glMulticastGetQueryObjecti64vNV';
    
    static procedure MulticastGetQueryObjectui64vNV(gpu: UInt32; id: UInt32; pname: ErrorCode; &params: ^UInt64);
    external 'opengl32.dll' name 'glMulticastGetQueryObjectui64vNV';
    
    static procedure ProgramLocalParameterI4iNV(target: ErrorCode; index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32);
    external 'opengl32.dll' name 'glProgramLocalParameterI4iNV';
    
    static procedure ProgramLocalParameterI4ivNV(target: ErrorCode; index: UInt32; &params: ^Int32);
    external 'opengl32.dll' name 'glProgramLocalParameterI4ivNV';
    
    static procedure ProgramLocalParametersI4ivNV(target: ErrorCode; index: UInt32; count: Int32; &params: ^Int32);
    external 'opengl32.dll' name 'glProgramLocalParametersI4ivNV';
    
    static procedure ProgramLocalParameterI4uiNV(target: ErrorCode; index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32);
    external 'opengl32.dll' name 'glProgramLocalParameterI4uiNV';
    
    static procedure ProgramLocalParameterI4uivNV(target: ErrorCode; index: UInt32; &params: ^UInt32);
    external 'opengl32.dll' name 'glProgramLocalParameterI4uivNV';
    
    static procedure ProgramLocalParametersI4uivNV(target: ErrorCode; index: UInt32; count: Int32; &params: ^UInt32);
    external 'opengl32.dll' name 'glProgramLocalParametersI4uivNV';
    
    static procedure ProgramEnvParameterI4iNV(target: ErrorCode; index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32);
    external 'opengl32.dll' name 'glProgramEnvParameterI4iNV';
    
    static procedure ProgramEnvParameterI4ivNV(target: ErrorCode; index: UInt32; &params: ^Int32);
    external 'opengl32.dll' name 'glProgramEnvParameterI4ivNV';
    
    static procedure ProgramEnvParametersI4ivNV(target: ErrorCode; index: UInt32; count: Int32; &params: ^Int32);
    external 'opengl32.dll' name 'glProgramEnvParametersI4ivNV';
    
    static procedure ProgramEnvParameterI4uiNV(target: ErrorCode; index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32);
    external 'opengl32.dll' name 'glProgramEnvParameterI4uiNV';
    
    static procedure ProgramEnvParameterI4uivNV(target: ErrorCode; index: UInt32; &params: ^UInt32);
    external 'opengl32.dll' name 'glProgramEnvParameterI4uivNV';
    
    static procedure ProgramEnvParametersI4uivNV(target: ErrorCode; index: UInt32; count: Int32; &params: ^UInt32);
    external 'opengl32.dll' name 'glProgramEnvParametersI4uivNV';
    
    static procedure GetProgramLocalParameterIivNV(target: ErrorCode; index: UInt32; &params: ^Int32);
    external 'opengl32.dll' name 'glGetProgramLocalParameterIivNV';
    
    static procedure GetProgramLocalParameterIuivNV(target: ErrorCode; index: UInt32; &params: ^UInt32);
    external 'opengl32.dll' name 'glGetProgramLocalParameterIuivNV';
    
    static procedure GetProgramEnvParameterIivNV(target: ErrorCode; index: UInt32; &params: ^Int32);
    external 'opengl32.dll' name 'glGetProgramEnvParameterIivNV';
    
    static procedure GetProgramEnvParameterIuivNV(target: ErrorCode; index: UInt32; &params: ^UInt32);
    external 'opengl32.dll' name 'glGetProgramEnvParameterIuivNV';
    
    static procedure ProgramSubroutineParametersuivNV(target: ErrorCode; count: Int32; &params: ^UInt32);
    external 'opengl32.dll' name 'glProgramSubroutineParametersuivNV';
    
    static procedure GetProgramSubroutineParameteruivNV(target: ErrorCode; index: UInt32; param: ^UInt32);
    external 'opengl32.dll' name 'glGetProgramSubroutineParameteruivNV';
    
    static procedure Vertex2hNV(x: half; y: half);
    external 'opengl32.dll' name 'glVertex2hNV';
    
    static procedure Vertex2hvNV(v: ^half);
    external 'opengl32.dll' name 'glVertex2hvNV';
    
    static procedure Vertex3hNV(x: half; y: half; z: half);
    external 'opengl32.dll' name 'glVertex3hNV';
    
    static procedure Vertex3hvNV(v: ^half);
    external 'opengl32.dll' name 'glVertex3hvNV';
    
    static procedure Vertex4hNV(x: half; y: half; z: half; w: half);
    external 'opengl32.dll' name 'glVertex4hNV';
    
    static procedure Vertex4hvNV(v: ^half);
    external 'opengl32.dll' name 'glVertex4hvNV';
    
    static procedure Normal3hNV(nx: half; ny: half; nz: half);
    external 'opengl32.dll' name 'glNormal3hNV';
    
    static procedure Normal3hvNV(v: ^half);
    external 'opengl32.dll' name 'glNormal3hvNV';
    
    static procedure Color3hNV(red: half; green: half; blue: half);
    external 'opengl32.dll' name 'glColor3hNV';
    
    static procedure Color3hvNV(v: ^half);
    external 'opengl32.dll' name 'glColor3hvNV';
    
    static procedure Color4hNV(red: half; green: half; blue: half; alpha: half);
    external 'opengl32.dll' name 'glColor4hNV';
    
    static procedure Color4hvNV(v: ^half);
    external 'opengl32.dll' name 'glColor4hvNV';
    
    static procedure TexCoord1hNV(s: half);
    external 'opengl32.dll' name 'glTexCoord1hNV';
    
    static procedure TexCoord1hvNV(v: ^half);
    external 'opengl32.dll' name 'glTexCoord1hvNV';
    
    static procedure TexCoord2hNV(s: half; t: half);
    external 'opengl32.dll' name 'glTexCoord2hNV';
    
    static procedure TexCoord2hvNV(v: ^half);
    external 'opengl32.dll' name 'glTexCoord2hvNV';
    
    static procedure TexCoord3hNV(s: half; t: half; r: half);
    external 'opengl32.dll' name 'glTexCoord3hNV';
    
    static procedure TexCoord3hvNV(v: ^half);
    external 'opengl32.dll' name 'glTexCoord3hvNV';
    
    static procedure TexCoord4hNV(s: half; t: half; r: half; q: half);
    external 'opengl32.dll' name 'glTexCoord4hNV';
    
    static procedure TexCoord4hvNV(v: ^half);
    external 'opengl32.dll' name 'glTexCoord4hvNV';
    
    static procedure MultiTexCoord1hNV(target: ErrorCode; s: half);
    external 'opengl32.dll' name 'glMultiTexCoord1hNV';
    
    static procedure MultiTexCoord1hvNV(target: ErrorCode; v: ^half);
    external 'opengl32.dll' name 'glMultiTexCoord1hvNV';
    
    static procedure MultiTexCoord2hNV(target: ErrorCode; s: half; t: half);
    external 'opengl32.dll' name 'glMultiTexCoord2hNV';
    
    static procedure MultiTexCoord2hvNV(target: ErrorCode; v: ^half);
    external 'opengl32.dll' name 'glMultiTexCoord2hvNV';
    
    static procedure MultiTexCoord3hNV(target: ErrorCode; s: half; t: half; r: half);
    external 'opengl32.dll' name 'glMultiTexCoord3hNV';
    
    static procedure MultiTexCoord3hvNV(target: ErrorCode; v: ^half);
    external 'opengl32.dll' name 'glMultiTexCoord3hvNV';
    
    static procedure MultiTexCoord4hNV(target: ErrorCode; s: half; t: half; r: half; q: half);
    external 'opengl32.dll' name 'glMultiTexCoord4hNV';
    
    static procedure MultiTexCoord4hvNV(target: ErrorCode; v: ^half);
    external 'opengl32.dll' name 'glMultiTexCoord4hvNV';
    
    static procedure FogCoordhNV(fog: half);
    external 'opengl32.dll' name 'glFogCoordhNV';
    
    static procedure FogCoordhvNV(fog: ^half);
    external 'opengl32.dll' name 'glFogCoordhvNV';
    
    static procedure SecondaryColor3hNV(red: half; green: half; blue: half);
    external 'opengl32.dll' name 'glSecondaryColor3hNV';
    
    static procedure SecondaryColor3hvNV(v: ^half);
    external 'opengl32.dll' name 'glSecondaryColor3hvNV';
    
    static procedure VertexWeighthNV(weight: half);
    external 'opengl32.dll' name 'glVertexWeighthNV';
    
    static procedure VertexWeighthvNV(weight: ^half);
    external 'opengl32.dll' name 'glVertexWeighthvNV';
    
    static procedure VertexAttrib1hNV(index: UInt32; x: half);
    external 'opengl32.dll' name 'glVertexAttrib1hNV';
    
    static procedure VertexAttrib1hvNV(index: UInt32; v: ^half);
    external 'opengl32.dll' name 'glVertexAttrib1hvNV';
    
    static procedure VertexAttrib2hNV(index: UInt32; x: half; y: half);
    external 'opengl32.dll' name 'glVertexAttrib2hNV';
    
    static procedure VertexAttrib2hvNV(index: UInt32; v: ^half);
    external 'opengl32.dll' name 'glVertexAttrib2hvNV';
    
    static procedure VertexAttrib3hNV(index: UInt32; x: half; y: half; z: half);
    external 'opengl32.dll' name 'glVertexAttrib3hNV';
    
    static procedure VertexAttrib3hvNV(index: UInt32; v: ^half);
    external 'opengl32.dll' name 'glVertexAttrib3hvNV';
    
    static procedure VertexAttrib4hNV(index: UInt32; x: half; y: half; z: half; w: half);
    external 'opengl32.dll' name 'glVertexAttrib4hNV';
    
    static procedure VertexAttrib4hvNV(index: UInt32; v: ^half);
    external 'opengl32.dll' name 'glVertexAttrib4hvNV';
    
    static procedure VertexAttribs1hvNV(index: UInt32; n: Int32; v: ^half);
    external 'opengl32.dll' name 'glVertexAttribs1hvNV';
    
    static procedure VertexAttribs2hvNV(index: UInt32; n: Int32; v: ^half);
    external 'opengl32.dll' name 'glVertexAttribs2hvNV';
    
    static procedure VertexAttribs3hvNV(index: UInt32; n: Int32; v: ^half);
    external 'opengl32.dll' name 'glVertexAttribs3hvNV';
    
    static procedure VertexAttribs4hvNV(index: UInt32; n: Int32; v: ^half);
    external 'opengl32.dll' name 'glVertexAttribs4hvNV';
    
    static procedure GenOcclusionQueriesNV(n: Int32; ids: ^UInt32);
    external 'opengl32.dll' name 'glGenOcclusionQueriesNV';
    
    static procedure DeleteOcclusionQueriesNV(n: Int32; ids: ^UInt32);
    external 'opengl32.dll' name 'glDeleteOcclusionQueriesNV';
    
    static function IsOcclusionQueryNV(id: UInt32): Byte;
    external 'opengl32.dll' name 'glIsOcclusionQueryNV';
    
    static procedure BeginOcclusionQueryNV(id: UInt32);
    external 'opengl32.dll' name 'glBeginOcclusionQueryNV';
    
    static procedure EndOcclusionQueryNV;
    external 'opengl32.dll' name 'glEndOcclusionQueryNV';
    
    static procedure GetOcclusionQueryivNV(id: UInt32; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetOcclusionQueryivNV';
    
    static procedure GetOcclusionQueryuivNV(id: UInt32; pname: ErrorCode; &params: ^UInt32);
    external 'opengl32.dll' name 'glGetOcclusionQueryuivNV';
    
    static procedure ProgramBufferParametersfvNV(target: ErrorCode; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; &params: ^single);
    external 'opengl32.dll' name 'glProgramBufferParametersfvNV';
    
    static procedure ProgramBufferParametersIivNV(target: ErrorCode; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; &params: ^Int32);
    external 'opengl32.dll' name 'glProgramBufferParametersIivNV';
    
    static procedure ProgramBufferParametersIuivNV(target: ErrorCode; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; &params: ^UInt32);
    external 'opengl32.dll' name 'glProgramBufferParametersIuivNV';
    
    static procedure PathColorGenNV(color: ErrorCode; genMode: ErrorCode; colorFormat: ErrorCode; coeffs: ^single);
    external 'opengl32.dll' name 'glPathColorGenNV';
    
    static procedure PathTexGenNV(texCoordSet: ErrorCode; genMode: ErrorCode; components: Int32; coeffs: ^single);
    external 'opengl32.dll' name 'glPathTexGenNV';
    
    static procedure PathFogGenNV(genMode: ErrorCode);
    external 'opengl32.dll' name 'glPathFogGenNV';
    
    static procedure GetPathColorGenivNV(color: ErrorCode; pname: ErrorCode; value: ^Int32);
    external 'opengl32.dll' name 'glGetPathColorGenivNV';
    
    static procedure GetPathColorGenfvNV(color: ErrorCode; pname: ErrorCode; value: ^single);
    external 'opengl32.dll' name 'glGetPathColorGenfvNV';
    
    static procedure GetPathTexGenivNV(texCoordSet: ErrorCode; pname: ErrorCode; value: ^Int32);
    external 'opengl32.dll' name 'glGetPathTexGenivNV';
    
    static procedure GetPathTexGenfvNV(texCoordSet: ErrorCode; pname: ErrorCode; value: ^single);
    external 'opengl32.dll' name 'glGetPathTexGenfvNV';
    
    static procedure PixelDataRangeNV(target: ErrorCode; length: Int32; _pointer: pointer);
    external 'opengl32.dll' name 'glPixelDataRangeNV';
    
    static procedure FlushPixelDataRangeNV(target: ErrorCode);
    external 'opengl32.dll' name 'glFlushPixelDataRangeNV';
    
    static procedure PointParameteriNV(pname: ErrorCode; param: Int32);
    external 'opengl32.dll' name 'glPointParameteriNV';
    
    static procedure PointParameterivNV(pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glPointParameterivNV';
    
    static procedure PresentFrameKeyedNV(video_slot: UInt32; minPresentTime: UInt64; beginPresentTimeId: UInt32; presentDurationId: UInt32; &type: ErrorCode; target0: ErrorCode; fill0: UInt32; key0: UInt32; target1: ErrorCode; fill1: UInt32; key1: UInt32);
    external 'opengl32.dll' name 'glPresentFrameKeyedNV';
    
    static procedure PresentFrameDualFillNV(video_slot: UInt32; minPresentTime: UInt64; beginPresentTimeId: UInt32; presentDurationId: UInt32; &type: ErrorCode; target0: ErrorCode; fill0: UInt32; target1: ErrorCode; fill1: UInt32; target2: ErrorCode; fill2: UInt32; target3: ErrorCode; fill3: UInt32);
    external 'opengl32.dll' name 'glPresentFrameDualFillNV';
    
    static procedure GetVideoivNV(video_slot: UInt32; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetVideoivNV';
    
    static procedure GetVideouivNV(video_slot: UInt32; pname: ErrorCode; &params: ^UInt32);
    external 'opengl32.dll' name 'glGetVideouivNV';
    
    static procedure GetVideoi64vNV(video_slot: UInt32; pname: ErrorCode; &params: ^Int64);
    external 'opengl32.dll' name 'glGetVideoi64vNV';
    
    static procedure GetVideoui64vNV(video_slot: UInt32; pname: ErrorCode; &params: ^UInt64);
    external 'opengl32.dll' name 'glGetVideoui64vNV';
    
    static procedure PrimitiveRestartNV;
    external 'opengl32.dll' name 'glPrimitiveRestartNV';
    
    static procedure PrimitiveRestartIndexNV(index: UInt32);
    external 'opengl32.dll' name 'glPrimitiveRestartIndexNV';
    
    static function QueryResourceNV(queryType: ErrorCode; tagId: Int32; bufSize: UInt32; buffer: ^Int32): Int32;
    external 'opengl32.dll' name 'glQueryResourceNV';
    
    static procedure GenQueryResourceTagNV(n: Int32; tagIds: ^Int32);
    external 'opengl32.dll' name 'glGenQueryResourceTagNV';
    
    static procedure DeleteQueryResourceTagNV(n: Int32; tagIds: ^Int32);
    external 'opengl32.dll' name 'glDeleteQueryResourceTagNV';
    
    static procedure QueryResourceTagNV(tagId: Int32; tagString: ^Byte);
    external 'opengl32.dll' name 'glQueryResourceTagNV';
    
    static procedure CombinerParameterfvNV(pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glCombinerParameterfvNV';
    
    static procedure CombinerParameterfNV(pname: ErrorCode; param: single);
    external 'opengl32.dll' name 'glCombinerParameterfNV';
    
    static procedure CombinerParameterivNV(pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glCombinerParameterivNV';
    
    static procedure CombinerParameteriNV(pname: ErrorCode; param: Int32);
    external 'opengl32.dll' name 'glCombinerParameteriNV';
    
    static procedure CombinerInputNV(stage: ErrorCode; portion: ErrorCode; variable: ErrorCode; input: ErrorCode; mapping: ErrorCode; componentUsage: ErrorCode);
    external 'opengl32.dll' name 'glCombinerInputNV';
    
    static procedure CombinerOutputNV(stage: ErrorCode; portion: ErrorCode; abOutput: ErrorCode; cdOutput: ErrorCode; sumOutput: ErrorCode; scale: ErrorCode; bias: ErrorCode; abDotProduct: Byte; cdDotProduct: Byte; muxSum: Byte);
    external 'opengl32.dll' name 'glCombinerOutputNV';
    
    static procedure FinalCombinerInputNV(variable: ErrorCode; input: ErrorCode; mapping: ErrorCode; componentUsage: ErrorCode);
    external 'opengl32.dll' name 'glFinalCombinerInputNV';
    
    static procedure GetCombinerInputParameterfvNV(stage: ErrorCode; portion: ErrorCode; variable: ErrorCode; pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glGetCombinerInputParameterfvNV';
    
    static procedure GetCombinerInputParameterivNV(stage: ErrorCode; portion: ErrorCode; variable: ErrorCode; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetCombinerInputParameterivNV';
    
    static procedure GetCombinerOutputParameterfvNV(stage: ErrorCode; portion: ErrorCode; pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glGetCombinerOutputParameterfvNV';
    
    static procedure GetCombinerOutputParameterivNV(stage: ErrorCode; portion: ErrorCode; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetCombinerOutputParameterivNV';
    
    static procedure GetFinalCombinerInputParameterfvNV(variable: ErrorCode; pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glGetFinalCombinerInputParameterfvNV';
    
    static procedure GetFinalCombinerInputParameterivNV(variable: ErrorCode; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetFinalCombinerInputParameterivNV';
    
    static procedure CombinerStageParameterfvNV(stage: ErrorCode; pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glCombinerStageParameterfvNV';
    
    static procedure GetCombinerStageParameterfvNV(stage: ErrorCode; pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glGetCombinerStageParameterfvNV';
    
    static procedure TexImage2DMultisampleCoverageNV(target: ErrorCode; coverageSamples: Int32; colorSamples: Int32; internalFormat: Int32; width: Int32; height: Int32; fixedSampleLocations: Byte);
    external 'opengl32.dll' name 'glTexImage2DMultisampleCoverageNV';
    
    static procedure TexImage3DMultisampleCoverageNV(target: ErrorCode; coverageSamples: Int32; colorSamples: Int32; internalFormat: Int32; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: Byte);
    external 'opengl32.dll' name 'glTexImage3DMultisampleCoverageNV';
    
    static procedure TextureImage2DMultisampleNV(texture: UInt32; target: ErrorCode; samples: Int32; internalFormat: Int32; width: Int32; height: Int32; fixedSampleLocations: Byte);
    external 'opengl32.dll' name 'glTextureImage2DMultisampleNV';
    
    static procedure TextureImage3DMultisampleNV(texture: UInt32; target: ErrorCode; samples: Int32; internalFormat: Int32; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: Byte);
    external 'opengl32.dll' name 'glTextureImage3DMultisampleNV';
    
    static procedure TextureImage2DMultisampleCoverageNV(texture: UInt32; target: ErrorCode; coverageSamples: Int32; colorSamples: Int32; internalFormat: Int32; width: Int32; height: Int32; fixedSampleLocations: Byte);
    external 'opengl32.dll' name 'glTextureImage2DMultisampleCoverageNV';
    
    static procedure TextureImage3DMultisampleCoverageNV(texture: UInt32; target: ErrorCode; coverageSamples: Int32; colorSamples: Int32; internalFormat: Int32; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: Byte);
    external 'opengl32.dll' name 'glTextureImage3DMultisampleCoverageNV';
    
    static procedure BeginTransformFeedbackNV(primitiveMode: ErrorCode);
    external 'opengl32.dll' name 'glBeginTransformFeedbackNV';
    
    static procedure EndTransformFeedbackNV;
    external 'opengl32.dll' name 'glEndTransformFeedbackNV';
    
    static procedure TransformFeedbackAttribsNV(count: Int32; attribs: ^Int32; bufferMode: ErrorCode);
    external 'opengl32.dll' name 'glTransformFeedbackAttribsNV';
    
    static procedure BindBufferRangeNV(target: ErrorCode; index: UInt32; buffer: UInt32; offset: IntPtr; size: UIntPtr);
    external 'opengl32.dll' name 'glBindBufferRangeNV';
    
    static procedure BindBufferOffsetNV(target: ErrorCode; index: UInt32; buffer: UInt32; offset: IntPtr);
    external 'opengl32.dll' name 'glBindBufferOffsetNV';
    
    static procedure BindBufferBaseNV(target: ErrorCode; index: UInt32; buffer: UInt32);
    external 'opengl32.dll' name 'glBindBufferBaseNV';
    
    static procedure TransformFeedbackVaryingsNV(&program: UInt32; count: Int32; locations: ^Int32; bufferMode: ErrorCode);
    external 'opengl32.dll' name 'glTransformFeedbackVaryingsNV';
    
    static procedure ActiveVaryingNV(&program: UInt32; name: ^Byte);
    external 'opengl32.dll' name 'glActiveVaryingNV';
    
    static function GetVaryingLocationNV(&program: UInt32; name: ^Byte): Int32;
    external 'opengl32.dll' name 'glGetVaryingLocationNV';
    
    static procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: ^Int32; size: ^Int32; &type: ^ErrorCode; name: ^Byte);
    external 'opengl32.dll' name 'glGetActiveVaryingNV';
    
    static procedure GetTransformFeedbackVaryingNV(&program: UInt32; index: UInt32; location: ^Int32);
    external 'opengl32.dll' name 'glGetTransformFeedbackVaryingNV';
    
    static procedure TransformFeedbackStreamAttribsNV(count: Int32; attribs: ^Int32; nbuffers: Int32; bufstreams: ^Int32; bufferMode: ErrorCode);
    external 'opengl32.dll' name 'glTransformFeedbackStreamAttribsNV';
    
    static procedure BindTransformFeedbackNV(target: ErrorCode; id: UInt32);
    external 'opengl32.dll' name 'glBindTransformFeedbackNV';
    
    static procedure DeleteTransformFeedbacksNV(n: Int32; ids: ^UInt32);
    external 'opengl32.dll' name 'glDeleteTransformFeedbacksNV';
    
    static procedure GenTransformFeedbacksNV(n: Int32; ids: ^UInt32);
    external 'opengl32.dll' name 'glGenTransformFeedbacksNV';
    
    static function IsTransformFeedbackNV(id: UInt32): Byte;
    external 'opengl32.dll' name 'glIsTransformFeedbackNV';
    
    static procedure PauseTransformFeedbackNV;
    external 'opengl32.dll' name 'glPauseTransformFeedbackNV';
    
    static procedure ResumeTransformFeedbackNV;
    external 'opengl32.dll' name 'glResumeTransformFeedbackNV';
    
    static procedure DrawTransformFeedbackNV(mode: ErrorCode; id: UInt32);
    external 'opengl32.dll' name 'glDrawTransformFeedbackNV';
    
    static procedure VDPAUInitNV(vdpDevice: pointer; getProcAddress: pointer);
    external 'opengl32.dll' name 'glVDPAUInitNV';
    
    static procedure VDPAUFiniNV;
    external 'opengl32.dll' name 'glVDPAUFiniNV';
    
    static function VDPAURegisterVideoSurfaceNV(vdpSurface: pointer; target: ErrorCode; numTextureNames: Int32; textureNames: ^UInt32): GLvdpauSurfaceNV;
    external 'opengl32.dll' name 'glVDPAURegisterVideoSurfaceNV';
    
    static function VDPAURegisterOutputSurfaceNV(vdpSurface: pointer; target: ErrorCode; numTextureNames: Int32; textureNames: ^UInt32): GLvdpauSurfaceNV;
    external 'opengl32.dll' name 'glVDPAURegisterOutputSurfaceNV';
    
    static function VDPAUIsSurfaceNV(surface: GLvdpauSurfaceNV): Byte;
    external 'opengl32.dll' name 'glVDPAUIsSurfaceNV';
    
    static procedure VDPAUUnregisterSurfaceNV(surface: GLvdpauSurfaceNV);
    external 'opengl32.dll' name 'glVDPAUUnregisterSurfaceNV';
    
    static procedure VDPAUGetSurfaceivNV(surface: GLvdpauSurfaceNV; pname: ErrorCode; bufSize: Int32; length: ^Int32; values: ^Int32);
    external 'opengl32.dll' name 'glVDPAUGetSurfaceivNV';
    
    static procedure VDPAUSurfaceAccessNV(surface: GLvdpauSurfaceNV; access: ErrorCode);
    external 'opengl32.dll' name 'glVDPAUSurfaceAccessNV';
    
    static procedure VDPAUMapSurfacesNV(numSurfaces: Int32; surfaces: ^GLvdpauSurfaceNV);
    external 'opengl32.dll' name 'glVDPAUMapSurfacesNV';
    
    static procedure VDPAUUnmapSurfacesNV(numSurface: Int32; surfaces: ^GLvdpauSurfaceNV);
    external 'opengl32.dll' name 'glVDPAUUnmapSurfacesNV';
    
    static function VDPAURegisterVideoSurfaceWithPictureStructureNV(vdpSurface: pointer; target: ErrorCode; numTextureNames: Int32; textureNames: ^UInt32; isFrameStructure: Byte): GLvdpauSurfaceNV;
    external 'opengl32.dll' name 'glVDPAURegisterVideoSurfaceWithPictureStructureNV';
    
    static procedure FlushVertexArrayRangeNV;
    external 'opengl32.dll' name 'glFlushVertexArrayRangeNV';
    
    static procedure VertexArrayRangeNV(length: Int32; _pointer: pointer);
    external 'opengl32.dll' name 'glVertexArrayRangeNV';
    
    static function AreProgramsResidentNV(n: Int32; programs: ^UInt32; residences: ^Byte): Byte;
    external 'opengl32.dll' name 'glAreProgramsResidentNV';
    
    static procedure BindProgramNV(target: ErrorCode; id: UInt32);
    external 'opengl32.dll' name 'glBindProgramNV';
    
    static procedure DeleteProgramsNV(n: Int32; programs: ^UInt32);
    external 'opengl32.dll' name 'glDeleteProgramsNV';
    
    static procedure ExecuteProgramNV(target: ErrorCode; id: UInt32; &params: ^single);
    external 'opengl32.dll' name 'glExecuteProgramNV';
    
    static procedure GenProgramsNV(n: Int32; programs: ^UInt32);
    external 'opengl32.dll' name 'glGenProgramsNV';
    
    static procedure GetProgramParameterdvNV(target: ErrorCode; index: UInt32; pname: ErrorCode; &params: ^double);
    external 'opengl32.dll' name 'glGetProgramParameterdvNV';
    
    static procedure GetProgramParameterfvNV(target: ErrorCode; index: UInt32; pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glGetProgramParameterfvNV';
    
    static procedure GetProgramivNV(id: UInt32; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetProgramivNV';
    
    static procedure GetProgramStringNV(id: UInt32; pname: ErrorCode; &program: ^Byte);
    external 'opengl32.dll' name 'glGetProgramStringNV';
    
    static procedure GetTrackMatrixivNV(target: ErrorCode; address: UInt32; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetTrackMatrixivNV';
    
    static procedure GetVertexAttribdvNV(index: UInt32; pname: ErrorCode; &params: ^double);
    external 'opengl32.dll' name 'glGetVertexAttribdvNV';
    
    static procedure GetVertexAttribfvNV(index: UInt32; pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glGetVertexAttribfvNV';
    
    static procedure GetVertexAttribivNV(index: UInt32; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetVertexAttribivNV';
    
    static procedure GetVertexAttribPointervNV(index: UInt32; pname: ErrorCode; _pointer: ^pointer);
    external 'opengl32.dll' name 'glGetVertexAttribPointervNV';
    
    static function IsProgramNV(id: UInt32): Byte;
    external 'opengl32.dll' name 'glIsProgramNV';
    
    static procedure LoadProgramNV(target: ErrorCode; id: UInt32; len: Int32; &program: ^Byte);
    external 'opengl32.dll' name 'glLoadProgramNV';
    
    static procedure ProgramParameter4dNV(target: ErrorCode; index: UInt32; x: double; y: double; z: double; w: double);
    external 'opengl32.dll' name 'glProgramParameter4dNV';
    
    static procedure ProgramParameter4dvNV(target: ErrorCode; index: UInt32; v: ^double);
    external 'opengl32.dll' name 'glProgramParameter4dvNV';
    
    static procedure ProgramParameter4fNV(target: ErrorCode; index: UInt32; x: single; y: single; z: single; w: single);
    external 'opengl32.dll' name 'glProgramParameter4fNV';
    
    static procedure ProgramParameter4fvNV(target: ErrorCode; index: UInt32; v: ^single);
    external 'opengl32.dll' name 'glProgramParameter4fvNV';
    
    static procedure ProgramParameters4dvNV(target: ErrorCode; index: UInt32; count: Int32; v: ^double);
    external 'opengl32.dll' name 'glProgramParameters4dvNV';
    
    static procedure ProgramParameters4fvNV(target: ErrorCode; index: UInt32; count: Int32; v: ^single);
    external 'opengl32.dll' name 'glProgramParameters4fvNV';
    
    static procedure RequestResidentProgramsNV(n: Int32; programs: ^UInt32);
    external 'opengl32.dll' name 'glRequestResidentProgramsNV';
    
    static procedure TrackMatrixNV(target: ErrorCode; address: UInt32; matrix: ErrorCode; transform: ErrorCode);
    external 'opengl32.dll' name 'glTrackMatrixNV';
    
    static procedure VertexAttribPointerNV(index: UInt32; fsize: Int32; &type: ErrorCode; stride: Int32; _pointer: pointer);
    external 'opengl32.dll' name 'glVertexAttribPointerNV';
    
    static procedure VertexAttrib1dNV(index: UInt32; x: double);
    external 'opengl32.dll' name 'glVertexAttrib1dNV';
    
    static procedure VertexAttrib1dvNV(index: UInt32; v: ^double);
    external 'opengl32.dll' name 'glVertexAttrib1dvNV';
    
    static procedure VertexAttrib1fNV(index: UInt32; x: single);
    external 'opengl32.dll' name 'glVertexAttrib1fNV';
    
    static procedure VertexAttrib1fvNV(index: UInt32; v: ^single);
    external 'opengl32.dll' name 'glVertexAttrib1fvNV';
    
    static procedure VertexAttrib1sNV(index: UInt32; x: Int16);
    external 'opengl32.dll' name 'glVertexAttrib1sNV';
    
    static procedure VertexAttrib1svNV(index: UInt32; v: ^Int16);
    external 'opengl32.dll' name 'glVertexAttrib1svNV';
    
    static procedure VertexAttrib2dNV(index: UInt32; x: double; y: double);
    external 'opengl32.dll' name 'glVertexAttrib2dNV';
    
    static procedure VertexAttrib2dvNV(index: UInt32; v: ^double);
    external 'opengl32.dll' name 'glVertexAttrib2dvNV';
    
    static procedure VertexAttrib2fNV(index: UInt32; x: single; y: single);
    external 'opengl32.dll' name 'glVertexAttrib2fNV';
    
    static procedure VertexAttrib2fvNV(index: UInt32; v: ^single);
    external 'opengl32.dll' name 'glVertexAttrib2fvNV';
    
    static procedure VertexAttrib2sNV(index: UInt32; x: Int16; y: Int16);
    external 'opengl32.dll' name 'glVertexAttrib2sNV';
    
    static procedure VertexAttrib2svNV(index: UInt32; v: ^Int16);
    external 'opengl32.dll' name 'glVertexAttrib2svNV';
    
    static procedure VertexAttrib3dNV(index: UInt32; x: double; y: double; z: double);
    external 'opengl32.dll' name 'glVertexAttrib3dNV';
    
    static procedure VertexAttrib3dvNV(index: UInt32; v: ^double);
    external 'opengl32.dll' name 'glVertexAttrib3dvNV';
    
    static procedure VertexAttrib3fNV(index: UInt32; x: single; y: single; z: single);
    external 'opengl32.dll' name 'glVertexAttrib3fNV';
    
    static procedure VertexAttrib3fvNV(index: UInt32; v: ^single);
    external 'opengl32.dll' name 'glVertexAttrib3fvNV';
    
    static procedure VertexAttrib3sNV(index: UInt32; x: Int16; y: Int16; z: Int16);
    external 'opengl32.dll' name 'glVertexAttrib3sNV';
    
    static procedure VertexAttrib3svNV(index: UInt32; v: ^Int16);
    external 'opengl32.dll' name 'glVertexAttrib3svNV';
    
    static procedure VertexAttrib4dNV(index: UInt32; x: double; y: double; z: double; w: double);
    external 'opengl32.dll' name 'glVertexAttrib4dNV';
    
    static procedure VertexAttrib4dvNV(index: UInt32; v: ^double);
    external 'opengl32.dll' name 'glVertexAttrib4dvNV';
    
    static procedure VertexAttrib4fNV(index: UInt32; x: single; y: single; z: single; w: single);
    external 'opengl32.dll' name 'glVertexAttrib4fNV';
    
    static procedure VertexAttrib4fvNV(index: UInt32; v: ^single);
    external 'opengl32.dll' name 'glVertexAttrib4fvNV';
    
    static procedure VertexAttrib4sNV(index: UInt32; x: Int16; y: Int16; z: Int16; w: Int16);
    external 'opengl32.dll' name 'glVertexAttrib4sNV';
    
    static procedure VertexAttrib4svNV(index: UInt32; v: ^Int16);
    external 'opengl32.dll' name 'glVertexAttrib4svNV';
    
    static procedure VertexAttrib4ubNV(index: UInt32; x: Byte; y: Byte; z: Byte; w: Byte);
    external 'opengl32.dll' name 'glVertexAttrib4ubNV';
    
    static procedure VertexAttrib4ubvNV(index: UInt32; v: ^Byte);
    external 'opengl32.dll' name 'glVertexAttrib4ubvNV';
    
    static procedure VertexAttribs1dvNV(index: UInt32; count: Int32; v: ^double);
    external 'opengl32.dll' name 'glVertexAttribs1dvNV';
    
    static procedure VertexAttribs1fvNV(index: UInt32; count: Int32; v: ^single);
    external 'opengl32.dll' name 'glVertexAttribs1fvNV';
    
    static procedure VertexAttribs1svNV(index: UInt32; count: Int32; v: ^Int16);
    external 'opengl32.dll' name 'glVertexAttribs1svNV';
    
    static procedure VertexAttribs2dvNV(index: UInt32; count: Int32; v: ^double);
    external 'opengl32.dll' name 'glVertexAttribs2dvNV';
    
    static procedure VertexAttribs2fvNV(index: UInt32; count: Int32; v: ^single);
    external 'opengl32.dll' name 'glVertexAttribs2fvNV';
    
    static procedure VertexAttribs2svNV(index: UInt32; count: Int32; v: ^Int16);
    external 'opengl32.dll' name 'glVertexAttribs2svNV';
    
    static procedure VertexAttribs3dvNV(index: UInt32; count: Int32; v: ^double);
    external 'opengl32.dll' name 'glVertexAttribs3dvNV';
    
    static procedure VertexAttribs3fvNV(index: UInt32; count: Int32; v: ^single);
    external 'opengl32.dll' name 'glVertexAttribs3fvNV';
    
    static procedure VertexAttribs3svNV(index: UInt32; count: Int32; v: ^Int16);
    external 'opengl32.dll' name 'glVertexAttribs3svNV';
    
    static procedure VertexAttribs4dvNV(index: UInt32; count: Int32; v: ^double);
    external 'opengl32.dll' name 'glVertexAttribs4dvNV';
    
    static procedure VertexAttribs4fvNV(index: UInt32; count: Int32; v: ^single);
    external 'opengl32.dll' name 'glVertexAttribs4fvNV';
    
    static procedure VertexAttribs4svNV(index: UInt32; count: Int32; v: ^Int16);
    external 'opengl32.dll' name 'glVertexAttribs4svNV';
    
    static procedure VertexAttribs4ubvNV(index: UInt32; count: Int32; v: ^Byte);
    external 'opengl32.dll' name 'glVertexAttribs4ubvNV';
    
    static procedure BeginVideoCaptureNV(video_capture_slot: UInt32);
    external 'opengl32.dll' name 'glBeginVideoCaptureNV';
    
    static procedure BindVideoCaptureStreamBufferNV(video_capture_slot: UInt32; stream: UInt32; frame_region: ErrorCode; offset: IntPtr);
    external 'opengl32.dll' name 'glBindVideoCaptureStreamBufferNV';
    
    static procedure BindVideoCaptureStreamTextureNV(video_capture_slot: UInt32; stream: UInt32; frame_region: ErrorCode; target: ErrorCode; texture: UInt32);
    external 'opengl32.dll' name 'glBindVideoCaptureStreamTextureNV';
    
    static procedure EndVideoCaptureNV(video_capture_slot: UInt32);
    external 'opengl32.dll' name 'glEndVideoCaptureNV';
    
    static procedure GetVideoCaptureivNV(video_capture_slot: UInt32; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetVideoCaptureivNV';
    
    static procedure GetVideoCaptureStreamivNV(video_capture_slot: UInt32; stream: UInt32; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetVideoCaptureStreamivNV';
    
    static procedure GetVideoCaptureStreamfvNV(video_capture_slot: UInt32; stream: UInt32; pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glGetVideoCaptureStreamfvNV';
    
    static procedure GetVideoCaptureStreamdvNV(video_capture_slot: UInt32; stream: UInt32; pname: ErrorCode; &params: ^double);
    external 'opengl32.dll' name 'glGetVideoCaptureStreamdvNV';
    
    static function VideoCaptureNV(video_capture_slot: UInt32; sequence_num: ^UInt32; capture_time: ^UInt64): ErrorCode;
    external 'opengl32.dll' name 'glVideoCaptureNV';
    
    static procedure VideoCaptureStreamParameterivNV(video_capture_slot: UInt32; stream: UInt32; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glVideoCaptureStreamParameterivNV';
    
    static procedure VideoCaptureStreamParameterfvNV(video_capture_slot: UInt32; stream: UInt32; pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glVideoCaptureStreamParameterfvNV';
    
    static procedure VideoCaptureStreamParameterdvNV(video_capture_slot: UInt32; stream: UInt32; pname: ErrorCode; &params: ^double);
    external 'opengl32.dll' name 'glVideoCaptureStreamParameterdvNV';
    
    {$endregion NVIDIA}
    
    {$region PGI}
    
    static procedure HintPGI(target: ErrorCode; mode: Int32);
    external 'opengl32.dll' name 'glHintPGI';
    
    {$endregion PGI}
    
  end;
  
  /// Расширения, которые встречаются только у видеокарт Radeon
  /// то есть AMD + ATI
  gl_Radeon = static class
    
    {$region AMD}
    
    static procedure RenderbufferStorageMultisampleAdvancedAMD(target: UInt32; samples: Int32; storageSamples: Int32; internalformat: UInt32; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glRenderbufferStorageMultisampleAdvancedAMD';
    
    static procedure NamedRenderbufferStorageMultisampleAdvancedAMD(renderbuffer: UInt32; samples: Int32; storageSamples: Int32; internalformat: UInt32; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glNamedRenderbufferStorageMultisampleAdvancedAMD';
    
    static procedure GetPerfMonitorGroupsAMD(numGroups: ^Int32; groupsSize: Int32; groups: ^UInt32);
    external 'opengl32.dll' name 'glGetPerfMonitorGroupsAMD';
    
    static procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: ^Int32; maxActiveCounters: ^Int32; counterSize: Int32; counters: ^UInt32);
    external 'opengl32.dll' name 'glGetPerfMonitorCountersAMD';
    
    static procedure GetPerfMonitorGroupStringAMD(group: UInt32; bufSize: Int32; length: ^Int32; groupString: ^SByte);
    external 'opengl32.dll' name 'glGetPerfMonitorGroupStringAMD';
    
    static procedure GetPerfMonitorCounterStringAMD(group: UInt32; counter: UInt32; bufSize: Int32; length: ^Int32; counterString: ^SByte);
    external 'opengl32.dll' name 'glGetPerfMonitorCounterStringAMD';
    
    static procedure GetPerfMonitorCounterInfoAMD(group: UInt32; counter: UInt32; pname: UInt32; data: pointer);
    external 'opengl32.dll' name 'glGetPerfMonitorCounterInfoAMD';
    
    static procedure GenPerfMonitorsAMD(n: Int32; monitors: ^UInt32);
    external 'opengl32.dll' name 'glGenPerfMonitorsAMD';
    
    static procedure DeletePerfMonitorsAMD(n: Int32; monitors: ^UInt32);
    external 'opengl32.dll' name 'glDeletePerfMonitorsAMD';
    
    static procedure SelectPerfMonitorCountersAMD(monitor: UInt32; enable: boolean; group: UInt32; numCounters: Int32; counterList: ^UInt32);
    external 'opengl32.dll' name 'glSelectPerfMonitorCountersAMD';
    
    static procedure BeginPerfMonitorAMD(monitor: UInt32);
    external 'opengl32.dll' name 'glBeginPerfMonitorAMD';
    
    static procedure EndPerfMonitorAMD(monitor: UInt32);
    external 'opengl32.dll' name 'glEndPerfMonitorAMD';
    
    static procedure GetPerfMonitorCounterDataAMD(monitor: UInt32; pname: UInt32; dataSize: Int32; data: ^UInt32; bytesWritten: ^Int32);
    external 'opengl32.dll' name 'glGetPerfMonitorCounterDataAMD';
    
    static procedure DebugMessageEnableAMD(category: ErrorCode; severity: ErrorCode; count: Int32; ids: ^UInt32; enabled: Byte);
    external 'opengl32.dll' name 'glDebugMessageEnableAMD';
    
    static procedure DebugMessageInsertAMD(category: ErrorCode; severity: ErrorCode; id: UInt32; length: Int32; buf: ^Byte);
    external 'opengl32.dll' name 'glDebugMessageInsertAMD';
    
    static procedure DebugMessageCallbackAMD(callback: GLDEBUGPROCAMD; userParam: pointer);
    external 'opengl32.dll' name 'glDebugMessageCallbackAMD';
    
    static function GetDebugMessageLogAMD(count: UInt32; bufsize: Int32; categories: ^ErrorCode; severities: ^UInt32; ids: ^UInt32; lengths: ^Int32; message: ^Byte): UInt32;
    external 'opengl32.dll' name 'glGetDebugMessageLogAMD';
    
    static procedure BlendFuncIndexedAMD(buf: UInt32; src: ErrorCode; dst: ErrorCode);
    external 'opengl32.dll' name 'glBlendFuncIndexedAMD';
    
    static procedure BlendFuncSeparateIndexedAMD(buf: UInt32; srcRGB: ErrorCode; dstRGB: ErrorCode; srcAlpha: ErrorCode; dstAlpha: ErrorCode);
    external 'opengl32.dll' name 'glBlendFuncSeparateIndexedAMD';
    
    static procedure BlendEquationIndexedAMD(buf: UInt32; mode: ErrorCode);
    external 'opengl32.dll' name 'glBlendEquationIndexedAMD';
    
    static procedure BlendEquationSeparateIndexedAMD(buf: UInt32; modeRGB: ErrorCode; modeAlpha: ErrorCode);
    external 'opengl32.dll' name 'glBlendEquationSeparateIndexedAMD';
    
    static procedure FramebufferSamplePositionsfvAMD(target: ErrorCode; numsamples: UInt32; pixelindex: UInt32; values: ^single);
    external 'opengl32.dll' name 'glFramebufferSamplePositionsfvAMD';
    
    static procedure NamedFramebufferSamplePositionsfvAMD(framebuffer: UInt32; numsamples: UInt32; pixelindex: UInt32; values: ^single);
    external 'opengl32.dll' name 'glNamedFramebufferSamplePositionsfvAMD';
    
    static procedure GetFramebufferParameterfvAMD(target: ErrorCode; pname: ErrorCode; numsamples: UInt32; pixelindex: UInt32; size: Int32; values: ^single);
    external 'opengl32.dll' name 'glGetFramebufferParameterfvAMD';
    
    static procedure GetNamedFramebufferParameterfvAMD(framebuffer: UInt32; pname: ErrorCode; numsamples: UInt32; pixelindex: UInt32; size: Int32; values: ^single);
    external 'opengl32.dll' name 'glGetNamedFramebufferParameterfvAMD';
    
    static procedure VertexAttribParameteriAMD(index: UInt32; pname: ErrorCode; param: Int32);
    external 'opengl32.dll' name 'glVertexAttribParameteriAMD';
    
    static procedure MultiDrawArraysIndirectAMD(mode: ErrorCode; indirect: pointer; primcount: Int32; stride: Int32);
    external 'opengl32.dll' name 'glMultiDrawArraysIndirectAMD';
    
    static procedure MultiDrawElementsIndirectAMD(mode: ErrorCode; &type: ErrorCode; indirect: pointer; primcount: Int32; stride: Int32);
    external 'opengl32.dll' name 'glMultiDrawElementsIndirectAMD';
    
    static procedure GenNamesAMD(identifier: ErrorCode; num: UInt32; names: ^UInt32);
    external 'opengl32.dll' name 'glGenNamesAMD';
    
    static procedure DeleteNamesAMD(identifier: ErrorCode; num: UInt32; names: ^UInt32);
    external 'opengl32.dll' name 'glDeleteNamesAMD';
    
    static function IsNameAMD(identifier: ErrorCode; name: UInt32): Byte;
    external 'opengl32.dll' name 'glIsNameAMD';
    
    static procedure QueryObjectParameteruiAMD(target: ErrorCode; id: UInt32; pname: ErrorCode; param: UInt32);
    external 'opengl32.dll' name 'glQueryObjectParameteruiAMD';
    
    static procedure SetMultisamplefvAMD(pname: ErrorCode; index: UInt32; val: ^single);
    external 'opengl32.dll' name 'glSetMultisamplefvAMD';
    
    static procedure TexStorageSparseAMD(target: ErrorCode; internalFormat: ErrorCode; width: Int32; height: Int32; depth: Int32; layers: Int32; flags: UInt32);
    external 'opengl32.dll' name 'glTexStorageSparseAMD';
    
    static procedure TextureStorageSparseAMD(texture: UInt32; target: ErrorCode; internalFormat: ErrorCode; width: Int32; height: Int32; depth: Int32; layers: Int32; flags: UInt32);
    external 'opengl32.dll' name 'glTextureStorageSparseAMD';
    
    static procedure StencilOpValueAMD(face: ErrorCode; value: UInt32);
    external 'opengl32.dll' name 'glStencilOpValueAMD';
    
    static procedure TessellationFactorAMD(factor: single);
    external 'opengl32.dll' name 'glTessellationFactorAMD';
    
    static procedure TessellationModeAMD(mode: ErrorCode);
    external 'opengl32.dll' name 'glTessellationModeAMD';
    
    {$endregion AMD}
    
    {$region ATI}
    
    static procedure DrawBuffersATI(n: Int32; bufs: ^ErrorCode);
    external 'opengl32.dll' name 'glDrawBuffersATI';
    
    static procedure ElementPointerATI(&type: ErrorCode; _pointer: pointer);
    external 'opengl32.dll' name 'glElementPointerATI';
    
    static procedure DrawElementArrayATI(mode: ErrorCode; count: Int32);
    external 'opengl32.dll' name 'glDrawElementArrayATI';
    
    static procedure DrawRangeElementArrayATI(mode: ErrorCode; start: UInt32; &end: UInt32; count: Int32);
    external 'opengl32.dll' name 'glDrawRangeElementArrayATI';
    
    static procedure TexBumpParameterivATI(pname: ErrorCode; param: ^Int32);
    external 'opengl32.dll' name 'glTexBumpParameterivATI';
    
    static procedure TexBumpParameterfvATI(pname: ErrorCode; param: ^single);
    external 'opengl32.dll' name 'glTexBumpParameterfvATI';
    
    static procedure GetTexBumpParameterivATI(pname: ErrorCode; param: ^Int32);
    external 'opengl32.dll' name 'glGetTexBumpParameterivATI';
    
    static procedure GetTexBumpParameterfvATI(pname: ErrorCode; param: ^single);
    external 'opengl32.dll' name 'glGetTexBumpParameterfvATI';
    
    static function GenFragmentShadersATI(range: UInt32): UInt32;
    external 'opengl32.dll' name 'glGenFragmentShadersATI';
    
    static procedure BindFragmentShaderATI(id: UInt32);
    external 'opengl32.dll' name 'glBindFragmentShaderATI';
    
    static procedure DeleteFragmentShaderATI(id: UInt32);
    external 'opengl32.dll' name 'glDeleteFragmentShaderATI';
    
    static procedure BeginFragmentShaderATI;
    external 'opengl32.dll' name 'glBeginFragmentShaderATI';
    
    static procedure EndFragmentShaderATI;
    external 'opengl32.dll' name 'glEndFragmentShaderATI';
    
    static procedure PassTexCoordATI(dst: UInt32; coord: UInt32; swizzle: ErrorCode);
    external 'opengl32.dll' name 'glPassTexCoordATI';
    
    static procedure SampleMapATI(dst: UInt32; interp: UInt32; swizzle: ErrorCode);
    external 'opengl32.dll' name 'glSampleMapATI';
    
    static procedure ColorFragmentOp1ATI(op: ErrorCode; dst: UInt32; dstMask: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32);
    external 'opengl32.dll' name 'glColorFragmentOp1ATI';
    
    static procedure ColorFragmentOp2ATI(op: ErrorCode; dst: UInt32; dstMask: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32; arg2: UInt32; arg2Rep: UInt32; arg2Mod: UInt32);
    external 'opengl32.dll' name 'glColorFragmentOp2ATI';
    
    static procedure ColorFragmentOp3ATI(op: ErrorCode; dst: UInt32; dstMask: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32; arg2: UInt32; arg2Rep: UInt32; arg2Mod: UInt32; arg3: UInt32; arg3Rep: UInt32; arg3Mod: UInt32);
    external 'opengl32.dll' name 'glColorFragmentOp3ATI';
    
    static procedure AlphaFragmentOp1ATI(op: ErrorCode; dst: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32);
    external 'opengl32.dll' name 'glAlphaFragmentOp1ATI';
    
    static procedure AlphaFragmentOp2ATI(op: ErrorCode; dst: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32; arg2: UInt32; arg2Rep: UInt32; arg2Mod: UInt32);
    external 'opengl32.dll' name 'glAlphaFragmentOp2ATI';
    
    static procedure AlphaFragmentOp3ATI(op: ErrorCode; dst: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32; arg2: UInt32; arg2Rep: UInt32; arg2Mod: UInt32; arg3: UInt32; arg3Rep: UInt32; arg3Mod: UInt32);
    external 'opengl32.dll' name 'glAlphaFragmentOp3ATI';
    
    static procedure SetFragmentShaderConstantATI(dst: UInt32; value: ^single);
    external 'opengl32.dll' name 'glSetFragmentShaderConstantATI';
    
    static function MapObjectBufferATI(buffer: UInt32): pointer;
    external 'opengl32.dll' name 'glMapObjectBufferATI';
    
    static procedure UnmapObjectBufferATI(buffer: UInt32);
    external 'opengl32.dll' name 'glUnmapObjectBufferATI';
    
    static procedure PNTrianglesiATI(pname: ErrorCode; param: Int32);
    external 'opengl32.dll' name 'glPNTrianglesiATI';
    
    static procedure PNTrianglesfATI(pname: ErrorCode; param: single);
    external 'opengl32.dll' name 'glPNTrianglesfATI';
    
    static procedure StencilOpSeparateATI(face: ErrorCode; sfail: ErrorCode; dpfail: ErrorCode; dppass: ErrorCode);
    external 'opengl32.dll' name 'glStencilOpSeparateATI';
    
    static procedure StencilFuncSeparateATI(frontfunc: ErrorCode; backfunc: ErrorCode; ref: Int32; mask: UInt32);
    external 'opengl32.dll' name 'glStencilFuncSeparateATI';
    
    static function NewObjectBufferATI(size: Int32; _pointer: pointer; usage: ErrorCode): UInt32;
    external 'opengl32.dll' name 'glNewObjectBufferATI';
    
    static function IsObjectBufferATI(buffer: UInt32): Byte;
    external 'opengl32.dll' name 'glIsObjectBufferATI';
    
    static procedure UpdateObjectBufferATI(buffer: UInt32; offset: UInt32; size: Int32; _pointer: pointer; preserve: ErrorCode);
    external 'opengl32.dll' name 'glUpdateObjectBufferATI';
    
    static procedure GetObjectBufferfvATI(buffer: UInt32; pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glGetObjectBufferfvATI';
    
    static procedure GetObjectBufferivATI(buffer: UInt32; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetObjectBufferivATI';
    
    static procedure FreeObjectBufferATI(buffer: UInt32);
    external 'opengl32.dll' name 'glFreeObjectBufferATI';
    
    static procedure ArrayObjectATI(&array: ErrorCode; size: Int32; &type: ErrorCode; stride: Int32; buffer: UInt32; offset: UInt32);
    external 'opengl32.dll' name 'glArrayObjectATI';
    
    static procedure GetArrayObjectfvATI(&array: ErrorCode; pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glGetArrayObjectfvATI';
    
    static procedure GetArrayObjectivATI(&array: ErrorCode; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetArrayObjectivATI';
    
    static procedure VariantArrayObjectATI(id: UInt32; &type: ErrorCode; stride: Int32; buffer: UInt32; offset: UInt32);
    external 'opengl32.dll' name 'glVariantArrayObjectATI';
    
    static procedure GetVariantArrayObjectfvATI(id: UInt32; pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glGetVariantArrayObjectfvATI';
    
    static procedure GetVariantArrayObjectivATI(id: UInt32; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetVariantArrayObjectivATI';
    
    static procedure VertexAttribArrayObjectATI(index: UInt32; size: Int32; &type: ErrorCode; normalized: Byte; stride: Int32; buffer: UInt32; offset: UInt32);
    external 'opengl32.dll' name 'glVertexAttribArrayObjectATI';
    
    static procedure GetVertexAttribArrayObjectfvATI(index: UInt32; pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glGetVertexAttribArrayObjectfvATI';
    
    static procedure GetVertexAttribArrayObjectivATI(index: UInt32; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetVertexAttribArrayObjectivATI';
    
    static procedure VertexStream1sATI(stream: ErrorCode; x: Int16);
    external 'opengl32.dll' name 'glVertexStream1sATI';
    
    static procedure VertexStream1svATI(stream: ErrorCode; coords: ^Int16);
    external 'opengl32.dll' name 'glVertexStream1svATI';
    
    static procedure VertexStream1iATI(stream: ErrorCode; x: Int32);
    external 'opengl32.dll' name 'glVertexStream1iATI';
    
    static procedure VertexStream1ivATI(stream: ErrorCode; coords: ^Int32);
    external 'opengl32.dll' name 'glVertexStream1ivATI';
    
    static procedure VertexStream1fATI(stream: ErrorCode; x: single);
    external 'opengl32.dll' name 'glVertexStream1fATI';
    
    static procedure VertexStream1fvATI(stream: ErrorCode; coords: ^single);
    external 'opengl32.dll' name 'glVertexStream1fvATI';
    
    static procedure VertexStream1dATI(stream: ErrorCode; x: double);
    external 'opengl32.dll' name 'glVertexStream1dATI';
    
    static procedure VertexStream1dvATI(stream: ErrorCode; coords: ^double);
    external 'opengl32.dll' name 'glVertexStream1dvATI';
    
    static procedure VertexStream2sATI(stream: ErrorCode; x: Int16; y: Int16);
    external 'opengl32.dll' name 'glVertexStream2sATI';
    
    static procedure VertexStream2svATI(stream: ErrorCode; coords: ^Int16);
    external 'opengl32.dll' name 'glVertexStream2svATI';
    
    static procedure VertexStream2iATI(stream: ErrorCode; x: Int32; y: Int32);
    external 'opengl32.dll' name 'glVertexStream2iATI';
    
    static procedure VertexStream2ivATI(stream: ErrorCode; coords: ^Int32);
    external 'opengl32.dll' name 'glVertexStream2ivATI';
    
    static procedure VertexStream2fATI(stream: ErrorCode; x: single; y: single);
    external 'opengl32.dll' name 'glVertexStream2fATI';
    
    static procedure VertexStream2fvATI(stream: ErrorCode; coords: ^single);
    external 'opengl32.dll' name 'glVertexStream2fvATI';
    
    static procedure VertexStream2dATI(stream: ErrorCode; x: double; y: double);
    external 'opengl32.dll' name 'glVertexStream2dATI';
    
    static procedure VertexStream2dvATI(stream: ErrorCode; coords: ^double);
    external 'opengl32.dll' name 'glVertexStream2dvATI';
    
    static procedure VertexStream3sATI(stream: ErrorCode; x: Int16; y: Int16; z: Int16);
    external 'opengl32.dll' name 'glVertexStream3sATI';
    
    static procedure VertexStream3svATI(stream: ErrorCode; coords: ^Int16);
    external 'opengl32.dll' name 'glVertexStream3svATI';
    
    static procedure VertexStream3iATI(stream: ErrorCode; x: Int32; y: Int32; z: Int32);
    external 'opengl32.dll' name 'glVertexStream3iATI';
    
    static procedure VertexStream3ivATI(stream: ErrorCode; coords: ^Int32);
    external 'opengl32.dll' name 'glVertexStream3ivATI';
    
    static procedure VertexStream3fATI(stream: ErrorCode; x: single; y: single; z: single);
    external 'opengl32.dll' name 'glVertexStream3fATI';
    
    static procedure VertexStream3fvATI(stream: ErrorCode; coords: ^single);
    external 'opengl32.dll' name 'glVertexStream3fvATI';
    
    static procedure VertexStream3dATI(stream: ErrorCode; x: double; y: double; z: double);
    external 'opengl32.dll' name 'glVertexStream3dATI';
    
    static procedure VertexStream3dvATI(stream: ErrorCode; coords: ^double);
    external 'opengl32.dll' name 'glVertexStream3dvATI';
    
    static procedure VertexStream4sATI(stream: ErrorCode; x: Int16; y: Int16; z: Int16; w: Int16);
    external 'opengl32.dll' name 'glVertexStream4sATI';
    
    static procedure VertexStream4svATI(stream: ErrorCode; coords: ^Int16);
    external 'opengl32.dll' name 'glVertexStream4svATI';
    
    static procedure VertexStream4iATI(stream: ErrorCode; x: Int32; y: Int32; z: Int32; w: Int32);
    external 'opengl32.dll' name 'glVertexStream4iATI';
    
    static procedure VertexStream4ivATI(stream: ErrorCode; coords: ^Int32);
    external 'opengl32.dll' name 'glVertexStream4ivATI';
    
    static procedure VertexStream4fATI(stream: ErrorCode; x: single; y: single; z: single; w: single);
    external 'opengl32.dll' name 'glVertexStream4fATI';
    
    static procedure VertexStream4fvATI(stream: ErrorCode; coords: ^single);
    external 'opengl32.dll' name 'glVertexStream4fvATI';
    
    static procedure VertexStream4dATI(stream: ErrorCode; x: double; y: double; z: double; w: double);
    external 'opengl32.dll' name 'glVertexStream4dATI';
    
    static procedure VertexStream4dvATI(stream: ErrorCode; coords: ^double);
    external 'opengl32.dll' name 'glVertexStream4dvATI';
    
    static procedure NormalStream3bATI(stream: ErrorCode; nx: SByte; ny: SByte; nz: SByte);
    external 'opengl32.dll' name 'glNormalStream3bATI';
    
    static procedure NormalStream3bvATI(stream: ErrorCode; coords: ^SByte);
    external 'opengl32.dll' name 'glNormalStream3bvATI';
    
    static procedure NormalStream3sATI(stream: ErrorCode; nx: Int16; ny: Int16; nz: Int16);
    external 'opengl32.dll' name 'glNormalStream3sATI';
    
    static procedure NormalStream3svATI(stream: ErrorCode; coords: ^Int16);
    external 'opengl32.dll' name 'glNormalStream3svATI';
    
    static procedure NormalStream3iATI(stream: ErrorCode; nx: Int32; ny: Int32; nz: Int32);
    external 'opengl32.dll' name 'glNormalStream3iATI';
    
    static procedure NormalStream3ivATI(stream: ErrorCode; coords: ^Int32);
    external 'opengl32.dll' name 'glNormalStream3ivATI';
    
    static procedure NormalStream3fATI(stream: ErrorCode; nx: single; ny: single; nz: single);
    external 'opengl32.dll' name 'glNormalStream3fATI';
    
    static procedure NormalStream3fvATI(stream: ErrorCode; coords: ^single);
    external 'opengl32.dll' name 'glNormalStream3fvATI';
    
    static procedure NormalStream3dATI(stream: ErrorCode; nx: double; ny: double; nz: double);
    external 'opengl32.dll' name 'glNormalStream3dATI';
    
    static procedure NormalStream3dvATI(stream: ErrorCode; coords: ^double);
    external 'opengl32.dll' name 'glNormalStream3dvATI';
    
    static procedure ClientActiveVertexStreamATI(stream: ErrorCode);
    external 'opengl32.dll' name 'glClientActiveVertexStreamATI';
    
    static procedure VertexBlendEnviATI(pname: ErrorCode; param: Int32);
    external 'opengl32.dll' name 'glVertexBlendEnviATI';
    
    static procedure VertexBlendEnvfATI(pname: ErrorCode; param: single);
    external 'opengl32.dll' name 'glVertexBlendEnvfATI';
    
    {$endregion ATI}
    
  end;
  
  /// Расширения, которые встречаются только у железа от Sun Microsystems, Inc.
  /// (Это та же компания которой пренадлежит Java)
  gl_SUN = static class
    
    {$region SUN}
    
    static procedure FinishTextureSUNX;
    external 'opengl32.dll' name 'glFinishTextureSUNX';
    
    static procedure GlobalAlphaFactorbSUN(factor: SByte);
    external 'opengl32.dll' name 'glGlobalAlphaFactorbSUN';
    
    static procedure GlobalAlphaFactorsSUN(factor: Int16);
    external 'opengl32.dll' name 'glGlobalAlphaFactorsSUN';
    
    static procedure GlobalAlphaFactoriSUN(factor: Int32);
    external 'opengl32.dll' name 'glGlobalAlphaFactoriSUN';
    
    static procedure GlobalAlphaFactorfSUN(factor: single);
    external 'opengl32.dll' name 'glGlobalAlphaFactorfSUN';
    
    static procedure GlobalAlphaFactordSUN(factor: double);
    external 'opengl32.dll' name 'glGlobalAlphaFactordSUN';
    
    static procedure GlobalAlphaFactorubSUN(factor: Byte);
    external 'opengl32.dll' name 'glGlobalAlphaFactorubSUN';
    
    static procedure GlobalAlphaFactorusSUN(factor: UInt16);
    external 'opengl32.dll' name 'glGlobalAlphaFactorusSUN';
    
    static procedure GlobalAlphaFactoruiSUN(factor: UInt32);
    external 'opengl32.dll' name 'glGlobalAlphaFactoruiSUN';
    
    static procedure DrawMeshArraysSUN(mode: ErrorCode; first: Int32; count: Int32; width: Int32);
    external 'opengl32.dll' name 'glDrawMeshArraysSUN';
    
    static procedure ReplacementCodeuiSUN(code: UInt32);
    external 'opengl32.dll' name 'glReplacementCodeuiSUN';
    
    static procedure ReplacementCodeusSUN(code: UInt16);
    external 'opengl32.dll' name 'glReplacementCodeusSUN';
    
    static procedure ReplacementCodeubSUN(code: Byte);
    external 'opengl32.dll' name 'glReplacementCodeubSUN';
    
    static procedure ReplacementCodeuivSUN(code: ^UInt32);
    external 'opengl32.dll' name 'glReplacementCodeuivSUN';
    
    static procedure ReplacementCodeusvSUN(code: ^UInt16);
    external 'opengl32.dll' name 'glReplacementCodeusvSUN';
    
    static procedure ReplacementCodeubvSUN(code: ^Byte);
    external 'opengl32.dll' name 'glReplacementCodeubvSUN';
    
    static procedure ReplacementCodePointerSUN(&type: ErrorCode; stride: Int32; _pointer: ^pointer);
    external 'opengl32.dll' name 'glReplacementCodePointerSUN';
    
    static procedure Color4ubVertex2fSUN(r: Byte; g: Byte; b: Byte; a: Byte; x: single; y: single);
    external 'opengl32.dll' name 'glColor4ubVertex2fSUN';
    
    static procedure Color4ubVertex2fvSUN(c: ^Byte; v: ^single);
    external 'opengl32.dll' name 'glColor4ubVertex2fvSUN';
    
    static procedure Color4ubVertex3fSUN(r: Byte; g: Byte; b: Byte; a: Byte; x: single; y: single; z: single);
    external 'opengl32.dll' name 'glColor4ubVertex3fSUN';
    
    static procedure Color4ubVertex3fvSUN(c: ^Byte; v: ^single);
    external 'opengl32.dll' name 'glColor4ubVertex3fvSUN';
    
    static procedure Color3fVertex3fSUN(r: single; g: single; b: single; x: single; y: single; z: single);
    external 'opengl32.dll' name 'glColor3fVertex3fSUN';
    
    static procedure Color3fVertex3fvSUN(c: ^single; v: ^single);
    external 'opengl32.dll' name 'glColor3fVertex3fvSUN';
    
    static procedure Normal3fVertex3fSUN(nx: single; ny: single; nz: single; x: single; y: single; z: single);
    external 'opengl32.dll' name 'glNormal3fVertex3fSUN';
    
    static procedure Normal3fVertex3fvSUN(n: ^single; v: ^single);
    external 'opengl32.dll' name 'glNormal3fVertex3fvSUN';
    
    static procedure Color4fNormal3fVertex3fSUN(r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single);
    external 'opengl32.dll' name 'glColor4fNormal3fVertex3fSUN';
    
    static procedure Color4fNormal3fVertex3fvSUN(c: ^single; n: ^single; v: ^single);
    external 'opengl32.dll' name 'glColor4fNormal3fVertex3fvSUN';
    
    static procedure TexCoord2fVertex3fSUN(s: single; t: single; x: single; y: single; z: single);
    external 'opengl32.dll' name 'glTexCoord2fVertex3fSUN';
    
    static procedure TexCoord2fVertex3fvSUN(tc: ^single; v: ^single);
    external 'opengl32.dll' name 'glTexCoord2fVertex3fvSUN';
    
    static procedure TexCoord4fVertex4fSUN(s: single; t: single; p: single; q: single; x: single; y: single; z: single; w: single);
    external 'opengl32.dll' name 'glTexCoord4fVertex4fSUN';
    
    static procedure TexCoord4fVertex4fvSUN(tc: ^single; v: ^single);
    external 'opengl32.dll' name 'glTexCoord4fVertex4fvSUN';
    
    static procedure TexCoord2fColor4ubVertex3fSUN(s: single; t: single; r: Byte; g: Byte; b: Byte; a: Byte; x: single; y: single; z: single);
    external 'opengl32.dll' name 'glTexCoord2fColor4ubVertex3fSUN';
    
    static procedure TexCoord2fColor4ubVertex3fvSUN(tc: ^single; c: ^Byte; v: ^single);
    external 'opengl32.dll' name 'glTexCoord2fColor4ubVertex3fvSUN';
    
    static procedure TexCoord2fColor3fVertex3fSUN(s: single; t: single; r: single; g: single; b: single; x: single; y: single; z: single);
    external 'opengl32.dll' name 'glTexCoord2fColor3fVertex3fSUN';
    
    static procedure TexCoord2fColor3fVertex3fvSUN(tc: ^single; c: ^single; v: ^single);
    external 'opengl32.dll' name 'glTexCoord2fColor3fVertex3fvSUN';
    
    static procedure TexCoord2fNormal3fVertex3fSUN(s: single; t: single; nx: single; ny: single; nz: single; x: single; y: single; z: single);
    external 'opengl32.dll' name 'glTexCoord2fNormal3fVertex3fSUN';
    
    static procedure TexCoord2fNormal3fVertex3fvSUN(tc: ^single; n: ^single; v: ^single);
    external 'opengl32.dll' name 'glTexCoord2fNormal3fVertex3fvSUN';
    
    static procedure TexCoord2fColor4fNormal3fVertex3fSUN(s: single; t: single; r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single);
    external 'opengl32.dll' name 'glTexCoord2fColor4fNormal3fVertex3fSUN';
    
    static procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: ^single; c: ^single; n: ^single; v: ^single);
    external 'opengl32.dll' name 'glTexCoord2fColor4fNormal3fVertex3fvSUN';
    
    static procedure TexCoord4fColor4fNormal3fVertex4fSUN(s: single; t: single; p: single; q: single; r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single; w: single);
    external 'opengl32.dll' name 'glTexCoord4fColor4fNormal3fVertex4fSUN';
    
    static procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: ^single; c: ^single; n: ^single; v: ^single);
    external 'opengl32.dll' name 'glTexCoord4fColor4fNormal3fVertex4fvSUN';
    
    static procedure ReplacementCodeuiVertex3fSUN(rc: UInt32; x: single; y: single; z: single);
    external 'opengl32.dll' name 'glReplacementCodeuiVertex3fSUN';
    
    static procedure ReplacementCodeuiVertex3fvSUN(rc: ^UInt32; v: ^single);
    external 'opengl32.dll' name 'glReplacementCodeuiVertex3fvSUN';
    
    static procedure ReplacementCodeuiColor4ubVertex3fSUN(rc: UInt32; r: Byte; g: Byte; b: Byte; a: Byte; x: single; y: single; z: single);
    external 'opengl32.dll' name 'glReplacementCodeuiColor4ubVertex3fSUN';
    
    static procedure ReplacementCodeuiColor4ubVertex3fvSUN(rc: ^UInt32; c: ^Byte; v: ^single);
    external 'opengl32.dll' name 'glReplacementCodeuiColor4ubVertex3fvSUN';
    
    static procedure ReplacementCodeuiColor3fVertex3fSUN(rc: UInt32; r: single; g: single; b: single; x: single; y: single; z: single);
    external 'opengl32.dll' name 'glReplacementCodeuiColor3fVertex3fSUN';
    
    static procedure ReplacementCodeuiColor3fVertex3fvSUN(rc: ^UInt32; c: ^single; v: ^single);
    external 'opengl32.dll' name 'glReplacementCodeuiColor3fVertex3fvSUN';
    
    static procedure ReplacementCodeuiNormal3fVertex3fSUN(rc: UInt32; nx: single; ny: single; nz: single; x: single; y: single; z: single);
    external 'opengl32.dll' name 'glReplacementCodeuiNormal3fVertex3fSUN';
    
    static procedure ReplacementCodeuiNormal3fVertex3fvSUN(rc: ^UInt32; n: ^single; v: ^single);
    external 'opengl32.dll' name 'glReplacementCodeuiNormal3fVertex3fvSUN';
    
    static procedure ReplacementCodeuiColor4fNormal3fVertex3fSUN(rc: UInt32; r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single);
    external 'opengl32.dll' name 'glReplacementCodeuiColor4fNormal3fVertex3fSUN';
    
    static procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: ^UInt32; c: ^single; n: ^single; v: ^single);
    external 'opengl32.dll' name 'glReplacementCodeuiColor4fNormal3fVertex3fvSUN';
    
    static procedure ReplacementCodeuiTexCoord2fVertex3fSUN(rc: UInt32; s: single; t: single; x: single; y: single; z: single);
    external 'opengl32.dll' name 'glReplacementCodeuiTexCoord2fVertex3fSUN';
    
    static procedure ReplacementCodeuiTexCoord2fVertex3fvSUN(rc: ^UInt32; tc: ^single; v: ^single);
    external 'opengl32.dll' name 'glReplacementCodeuiTexCoord2fVertex3fvSUN';
    
    static procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(rc: UInt32; s: single; t: single; nx: single; ny: single; nz: single; x: single; y: single; z: single);
    external 'opengl32.dll' name 'glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN';
    
    static procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: ^UInt32; tc: ^single; n: ^single; v: ^single);
    external 'opengl32.dll' name 'glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN';
    
    static procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(rc: UInt32; s: single; t: single; r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single);
    external 'opengl32.dll' name 'glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN';
    
    static procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: ^UInt32; tc: ^single; c: ^single; n: ^single; v: ^single);
    external 'opengl32.dll' name 'glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN';
    
    {$endregion SUN}
    
  end;
  
  /// Всё устаревшее (то что удалено из последней версии OpenGL + то что собираются удалить в следующих)
  gl_Deprecated = static class
    
    {$region Deprecated}
    
    {$region Old graphics}
    
    static procedure &Begin(mode: PrimitiveType);
    external 'opengl32.dll' name 'glBegin';
    
    static procedure &End;
    external 'opengl32.dll' name 'glEnd';
    static procedure _End; //ToDo #2041
    external 'opengl32.dll' name 'glEnd';
    
    //ToDo тут не все явно
    
    {$region EdgeFlag[]}
    
    {$endregion EdgeFlag[]}
    
    {$region Color[1,2,3,4][ub,f]}
    
    static procedure Color4ub(red: Byte; green: Byte; blue: Byte; alpha: Byte);
    external 'opengl32.dll' name 'glColor4ub';
    
    static procedure Color4f(red: single; green: single; blue: single; alpha: single);
    external 'opengl32.dll' name 'glColor4f';
    
    {$endregion Color[1,2,3,4][ub,f]}
    
    {$region Color[1,2,3,4][ub,f]v}
    
    static procedure Color4fv([MarshalAs(UnmanagedType.LPArray)] v: array of single);
    external 'opengl32.dll' name 'glColor4fv';
    static procedure Color4fv(var v: Vec4f);
    external 'opengl32.dll' name 'glColor4fv';
    static procedure Color4fv(var v: single);
    external 'opengl32.dll' name 'glColor4fv';
    static procedure Color4fv(v: pointer);
    external 'opengl32.dll' name 'glColor4fv';
    
    {$endregion Color[1,2,3,4][ub,f]v}
    
    {$region FogCoord[]}
    
    {$endregion FogCoord[]}
    
    {$region Index[]}
    
    {$endregion Index[]}
    
    {$region Normal3[]}
    
    {$endregion Normal3[]}
    
    {$region SecondaryColor3[]}
    
    {$endregion SecondaryColor3[]}
    
    {$region TexCoord[]}
    
    {$endregion TexCoord[]}
    
    {$region Vertex[1,2,3,4][]}
    
    {$endregion Vertex[1,2,3,4][]}
    
    {$region Vertex[1,2,3,4][]v}
    
    {$endregion Vertex[1,2,3,4][]v}
    
    static procedure Frustumf(left: single; right: single; bottom: single; top: single; zNear: single; zFar: single);
    external 'opengl32.dll' name 'glFrustumf';
    
    static procedure GetLightfv(light: UInt32; pname: UInt32; &params: ^single);
    external 'opengl32.dll' name 'glGetLightfv';
    
    static procedure GetMaterialfv(face: UInt32; pname: UInt32; &params: ^single);
    external 'opengl32.dll' name 'glGetMaterialfv';
    
    static procedure GetPolygonStipple(mask: ^Byte);
    external 'opengl32.dll' name 'glGetPolygonStipple';
    
    static procedure GetTexEnvfv(target: UInt32; pname: UInt32; &params: ^single);
    external 'opengl32.dll' name 'glGetTexEnvfv';
    
    static procedure GetTexEnviv(target: UInt32; pname: UInt32; &params: ^Int32);
    external 'opengl32.dll' name 'glGetTexEnviv';
    
    static procedure Lightfv(light: UInt32; pname: UInt32; &params: ^single);
    external 'opengl32.dll' name 'glLightfv';
    
    static procedure LightModelfv(pname: UInt32; &params: ^single);
    external 'opengl32.dll' name 'glLightModelfv';
    
    static procedure LineStipple(factor: Int32; pattern: UInt16);
    external 'opengl32.dll' name 'glLineStipple';
    
    static procedure ListBase(base: UInt32);
    external 'opengl32.dll' name 'glListBase';
    
    static procedure LoadIdentity;
    external 'opengl32.dll' name 'glLoadIdentity';
    
    static procedure LoadMatrixf(m: ^single);
    external 'opengl32.dll' name 'glLoadMatrixf';
    
    static procedure Materialf(face: UInt32; pname: UInt32; param: single);
    external 'opengl32.dll' name 'glMaterialf';
    
    static procedure Materialfv(face: UInt32; pname: UInt32; &params: ^single);
    external 'opengl32.dll' name 'glMaterialfv';
    
    static procedure MatrixMode(mode: UInt32);
    external 'opengl32.dll' name 'glMatrixMode';
    
    static procedure MultMatrixf(m: ^single);
    external 'opengl32.dll' name 'glMultMatrixf';
    
    static procedure MultiTexCoord2f(target: UInt32; s: single; t: single);
    external 'opengl32.dll' name 'glMultiTexCoord2f';
    
    static procedure MultiTexCoord2fv(target: UInt32; v: ^single);
    external 'opengl32.dll' name 'glMultiTexCoord2fv';
    
    static procedure Normal3f(nx: single; ny: single; nz: single);
    external 'opengl32.dll' name 'glNormal3f';
    
    static procedure Normal3fv(v: ^single);
    external 'opengl32.dll' name 'glNormal3fv';
    
    static procedure NormalPointer(&type: UInt32; stride: Int32; _pointer: pointer);
    external 'opengl32.dll' name 'glNormalPointer';
    
    static procedure Orthof(left: single; right: single; bottom: single; top: single; zNear: single; zFar: single);
    external 'opengl32.dll' name 'glOrthof';
    
    static procedure PolygonStipple(mask: ^Byte);
    external 'opengl32.dll' name 'glPolygonStipple';
    
    static procedure PopMatrix;
    external 'opengl32.dll' name 'glPopMatrix';
    
    static procedure PushMatrix;
    external 'opengl32.dll' name 'glPushMatrix';
    
    static procedure RasterPos3f(x: single; y: single; z: single);
    external 'opengl32.dll' name 'glRasterPos3f';
    
    static procedure Rotatef(angle: single; x: single; y: single; z: single);
    external 'opengl32.dll' name 'glRotatef';
    
    static procedure Scalef(x: single; y: single; z: single);
    external 'opengl32.dll' name 'glScalef';
    
    static procedure ShadeModel(mode: UInt32);
    external 'opengl32.dll' name 'glShadeModel';
    
    static procedure TexCoordPointer(size: Int32; &type: UInt32; stride: Int32; _pointer: pointer);
    external 'opengl32.dll' name 'glTexCoordPointer';
    
    static procedure TexEnvfv(target: UInt32; pname: UInt32; &params: ^single);
    external 'opengl32.dll' name 'glTexEnvfv';
    
    static procedure TexEnvi(target: UInt32; pname: UInt32; param: Int32);
    external 'opengl32.dll' name 'glTexEnvi';
    
    static procedure Translatef(x: single; y: single; z: single);
    external 'opengl32.dll' name 'glTranslatef';
    
    static procedure Vertex2f(x: single; y: single);
    external 'opengl32.dll' name 'glVertex2f';
    
    static procedure Vertex2fv(v: ^single);
    external 'opengl32.dll' name 'glVertex2fv';
    
    static procedure Vertex3f(x: single; y: single; z: single);
    external 'opengl32.dll' name 'glVertex3f';
    
    static procedure Vertex3fv(v: ^single);
    external 'opengl32.dll' name 'glVertex3fv';
    
    static procedure VertexPointer(size: Int32; &type: UInt32; stride: Int32; _pointer: pointer);
    external 'opengl32.dll' name 'glVertexPointer';
    
    {$endregion Old graphics}
    
    {$region Lists}
    
    static function GenLists(range: Int32): UInt32; // : ListName; - напишите если очень надо добавить
    external 'opengl32.dll' name 'glGenLists';
    
    // lists может быть нескольких разных типов массивов,
    // надо многовато перегрузок, как для устаревшей функции
    // если вам для чего то надо - напишите мне
    // желательно, в issue
    static procedure CallLists(n: Int32; &type: DataType; lists: pointer);
    external 'opengl32.dll' name 'glCallLists';
    
    static procedure EndList;
    external 'opengl32.dll' name 'glEndList';
    
    static procedure NewList(list: UInt32; mode: UInt32); // mode это энум который тут не описан, напишите если очень надо добавить
    external 'opengl32.dll' name 'glNewList';
    
    {$endregion Lists}
    
    {$region Misc}
    
    static procedure AlphaFunc(func: ActivationFunc; ref: single);
    external 'opengl32.dll' name 'glAlphaFunc';
    
    static procedure Bitmap(width: Int32; height: Int32; xorig: single; yorig: single; xmove: single; ymove: single; [MarshalAs(UnmanagedType.LPArray)] bitmap: array of byte);
    external 'opengl32.dll' name 'glBitmap';
    static procedure Bitmap(width: Int32; height: Int32; xorig: single; yorig: single; xmove: single; ymove: single; bitmap: IntPtr);
    external 'opengl32.dll' name 'glBitmap';
    static procedure Bitmap(width: Int32; height: Int32; xorig: single; yorig: single; xmove: single; ymove: single; bitmap: pointer);
    external 'opengl32.dll' name 'glBitmap';
    
    static procedure CopyPixels(x: Int32; y: Int32; width: Int32; height: Int32; &type: CopyableImageBuffer);
    external 'opengl32.dll' name 'glCopyPixels';
    
    static procedure DrawPixels(width: Int32; height: Int32; format: DataFormat; &type: CopyableImageBuffer; pixels: pointer);
    external 'opengl32.dll' name 'glDrawPixels';
    
    static procedure ColorPointer(size: Int32; &type: DataType; stride: Int32; _pointer: pointer); // может быть надо другие перегрузки, напишите если очень надо добавить
    external 'opengl32.dll' name 'glColorPointer';
    
    static procedure ClientActiveTexture(texture: TextureUnitId);
    external 'opengl32.dll' name 'glClientActiveTexture';
    
    static procedure DisableClientState(&array: UInt32); // array это энум который тут не описан, напишите если очень надо добавить
    external 'opengl32.dll' name 'glDisableClientState';
    
    static procedure EnableClientState(&array: UInt32);
    external 'opengl32.dll' name 'glEnableClientState';
    
    {$endregion Misc}
    
    {$endregion Deprecated}
    
  end;
  
  /// Расширение OVR - (наверное) OpenVR
  /// Сцена то у обоих глаз общая, отличается только точка обзора
  /// Поэтому рендеринг можно сильно ускорить, сделав всё параллельно и без лишних движений
  gl_OVR = static class
    
    {$region OVR}
    
    static procedure FramebufferTextureMultiviewOVR(target: UInt32; attachment: UInt32; texture: UInt32; level: Int32; baseViewIndex: Int32; numViews: Int32);
    external 'opengl32.dll' name 'glFramebufferTextureMultiviewOVR';
    
    {$endregion OVR}
    
  end;
  
  /// Расширения для разного дебага
  gl_KHR = static class
    
    {$region KHR}
    
    static procedure BlendBarrierKHR;
    external 'opengl32.dll' name 'glBlendBarrierKHR';
    
    static procedure MaxShaderCompilerThreadsKHR(count: UInt32);
    external 'opengl32.dll' name 'glMaxShaderCompilerThreadsKHR';
    
    {$endregion KHR}
    
  end;
  
  /// Расширения для телефонов, консолей и т.п.
  /// В общем для всего того, на чём вы фиг не запустите программу на паскале
  gl_OES = static class
    
    {$region OES}
    
    static procedure MultiTexCoord1bOES(texture: ErrorCode; s: SByte);
    external 'opengl32.dll' name 'glMultiTexCoord1bOES';
    
    static procedure MultiTexCoord1bvOES(texture: ErrorCode; coords: ^SByte);
    external 'opengl32.dll' name 'glMultiTexCoord1bvOES';
    
    static procedure MultiTexCoord2bOES(texture: ErrorCode; s: SByte; t: SByte);
    external 'opengl32.dll' name 'glMultiTexCoord2bOES';
    
    static procedure MultiTexCoord2bvOES(texture: ErrorCode; coords: ^SByte);
    external 'opengl32.dll' name 'glMultiTexCoord2bvOES';
    
    static procedure MultiTexCoord3bOES(texture: ErrorCode; s: SByte; t: SByte; r: SByte);
    external 'opengl32.dll' name 'glMultiTexCoord3bOES';
    
    static procedure MultiTexCoord3bvOES(texture: ErrorCode; coords: ^SByte);
    external 'opengl32.dll' name 'glMultiTexCoord3bvOES';
    
    static procedure MultiTexCoord4bOES(texture: ErrorCode; s: SByte; t: SByte; r: SByte; q: SByte);
    external 'opengl32.dll' name 'glMultiTexCoord4bOES';
    
    static procedure MultiTexCoord4bvOES(texture: ErrorCode; coords: ^SByte);
    external 'opengl32.dll' name 'glMultiTexCoord4bvOES';
    
    static procedure TexCoord1bOES(s: SByte);
    external 'opengl32.dll' name 'glTexCoord1bOES';
    
    static procedure TexCoord1bvOES(coords: ^SByte);
    external 'opengl32.dll' name 'glTexCoord1bvOES';
    
    static procedure TexCoord2bOES(s: SByte; t: SByte);
    external 'opengl32.dll' name 'glTexCoord2bOES';
    
    static procedure TexCoord2bvOES(coords: ^SByte);
    external 'opengl32.dll' name 'glTexCoord2bvOES';
    
    static procedure TexCoord3bOES(s: SByte; t: SByte; r: SByte);
    external 'opengl32.dll' name 'glTexCoord3bOES';
    
    static procedure TexCoord3bvOES(coords: ^SByte);
    external 'opengl32.dll' name 'glTexCoord3bvOES';
    
    static procedure TexCoord4bOES(s: SByte; t: SByte; r: SByte; q: SByte);
    external 'opengl32.dll' name 'glTexCoord4bOES';
    
    static procedure TexCoord4bvOES(coords: ^SByte);
    external 'opengl32.dll' name 'glTexCoord4bvOES';
    
    static procedure Vertex2bOES(x: SByte; y: SByte);
    external 'opengl32.dll' name 'glVertex2bOES';
    
    static procedure Vertex2bvOES(coords: ^SByte);
    external 'opengl32.dll' name 'glVertex2bvOES';
    
    static procedure Vertex3bOES(x: SByte; y: SByte; z: SByte);
    external 'opengl32.dll' name 'glVertex3bOES';
    
    static procedure Vertex3bvOES(coords: ^SByte);
    external 'opengl32.dll' name 'glVertex3bvOES';
    
    static procedure Vertex4bOES(x: SByte; y: SByte; z: SByte; w: SByte);
    external 'opengl32.dll' name 'glVertex4bOES';
    
    static procedure Vertex4bvOES(coords: ^SByte);
    external 'opengl32.dll' name 'glVertex4bvOES';
    
    static procedure AlphaFuncxOES(func: ErrorCode; ref: fixed);
    external 'opengl32.dll' name 'glAlphaFuncxOES';
    
    static procedure ClearColorxOES(red: fixed; green: fixed; blue: fixed; alpha: fixed);
    external 'opengl32.dll' name 'glClearColorxOES';
    
    static procedure ClearDepthxOES(depth: fixed);
    external 'opengl32.dll' name 'glClearDepthxOES';
    
    static procedure ClipPlanexOES(plane: ErrorCode; equation: ^fixed);
    external 'opengl32.dll' name 'glClipPlanexOES';
    
    static procedure Color4xOES(red: fixed; green: fixed; blue: fixed; alpha: fixed);
    external 'opengl32.dll' name 'glColor4xOES';
    
    static procedure DepthRangexOES(n: fixed; f: fixed);
    external 'opengl32.dll' name 'glDepthRangexOES';
    
    static procedure FogxOES(pname: ErrorCode; param: fixed);
    external 'opengl32.dll' name 'glFogxOES';
    
    static procedure FogxvOES(pname: ErrorCode; param: ^fixed);
    external 'opengl32.dll' name 'glFogxvOES';
    
    static procedure FrustumxOES(l: fixed; r: fixed; b: fixed; t: fixed; n: fixed; f: fixed);
    external 'opengl32.dll' name 'glFrustumxOES';
    
    static procedure GetClipPlanexOES(plane: ErrorCode; equation: ^fixed);
    external 'opengl32.dll' name 'glGetClipPlanexOES';
    
    static procedure GetFixedvOES(pname: ErrorCode; &params: ^fixed);
    external 'opengl32.dll' name 'glGetFixedvOES';
    
    static procedure GetTexEnvxvOES(target: ErrorCode; pname: ErrorCode; &params: ^fixed);
    external 'opengl32.dll' name 'glGetTexEnvxvOES';
    
    static procedure GetTexParameterxvOES(target: ErrorCode; pname: ErrorCode; &params: ^fixed);
    external 'opengl32.dll' name 'glGetTexParameterxvOES';
    
    static procedure LightModelxOES(pname: ErrorCode; param: fixed);
    external 'opengl32.dll' name 'glLightModelxOES';
    
    static procedure LightModelxvOES(pname: ErrorCode; param: ^fixed);
    external 'opengl32.dll' name 'glLightModelxvOES';
    
    static procedure LightxOES(light: ErrorCode; pname: ErrorCode; param: fixed);
    external 'opengl32.dll' name 'glLightxOES';
    
    static procedure LightxvOES(light: ErrorCode; pname: ErrorCode; &params: ^fixed);
    external 'opengl32.dll' name 'glLightxvOES';
    
    static procedure LineWidthxOES(width: fixed);
    external 'opengl32.dll' name 'glLineWidthxOES';
    
    static procedure LoadMatrixxOES(m: ^fixed);
    external 'opengl32.dll' name 'glLoadMatrixxOES';
    
    static procedure MaterialxOES(face: ErrorCode; pname: ErrorCode; param: fixed);
    external 'opengl32.dll' name 'glMaterialxOES';
    
    static procedure MaterialxvOES(face: ErrorCode; pname: ErrorCode; param: ^fixed);
    external 'opengl32.dll' name 'glMaterialxvOES';
    
    static procedure MultMatrixxOES(m: ^fixed);
    external 'opengl32.dll' name 'glMultMatrixxOES';
    
    static procedure MultiTexCoord4xOES(texture: ErrorCode; s: fixed; t: fixed; r: fixed; q: fixed);
    external 'opengl32.dll' name 'glMultiTexCoord4xOES';
    
    static procedure Normal3xOES(nx: fixed; ny: fixed; nz: fixed);
    external 'opengl32.dll' name 'glNormal3xOES';
    
    static procedure OrthoxOES(l: fixed; r: fixed; b: fixed; t: fixed; n: fixed; f: fixed);
    external 'opengl32.dll' name 'glOrthoxOES';
    
    static procedure PointParameterxvOES(pname: ErrorCode; &params: ^fixed);
    external 'opengl32.dll' name 'glPointParameterxvOES';
    
    static procedure PointSizexOES(size: fixed);
    external 'opengl32.dll' name 'glPointSizexOES';
    
    static procedure PolygonOffsetxOES(factor: fixed; units: fixed);
    external 'opengl32.dll' name 'glPolygonOffsetxOES';
    
    static procedure RotatexOES(angle: fixed; x: fixed; y: fixed; z: fixed);
    external 'opengl32.dll' name 'glRotatexOES';
    
    static procedure ScalexOES(x: fixed; y: fixed; z: fixed);
    external 'opengl32.dll' name 'glScalexOES';
    
    static procedure TexEnvxOES(target: ErrorCode; pname: ErrorCode; param: fixed);
    external 'opengl32.dll' name 'glTexEnvxOES';
    
    static procedure TexEnvxvOES(target: ErrorCode; pname: ErrorCode; &params: ^fixed);
    external 'opengl32.dll' name 'glTexEnvxvOES';
    
    static procedure TexParameterxOES(target: ErrorCode; pname: ErrorCode; param: fixed);
    external 'opengl32.dll' name 'glTexParameterxOES';
    
    static procedure TexParameterxvOES(target: ErrorCode; pname: ErrorCode; &params: ^fixed);
    external 'opengl32.dll' name 'glTexParameterxvOES';
    
    static procedure TranslatexOES(x: fixed; y: fixed; z: fixed);
    external 'opengl32.dll' name 'glTranslatexOES';
    
    static procedure AccumxOES(op: ErrorCode; value: fixed);
    external 'opengl32.dll' name 'glAccumxOES';
    
    static procedure BitmapxOES(width: Int32; height: Int32; xorig: fixed; yorig: fixed; xmove: fixed; ymove: fixed; bitmap: ^Byte);
    external 'opengl32.dll' name 'glBitmapxOES';
    
    static procedure BlendColorxOES(red: fixed; green: fixed; blue: fixed; alpha: fixed);
    external 'opengl32.dll' name 'glBlendColorxOES';
    
    static procedure ClearAccumxOES(red: fixed; green: fixed; blue: fixed; alpha: fixed);
    external 'opengl32.dll' name 'glClearAccumxOES';
    
    static procedure Color3xOES(red: fixed; green: fixed; blue: fixed);
    external 'opengl32.dll' name 'glColor3xOES';
    
    static procedure Color3xvOES(components: ^fixed);
    external 'opengl32.dll' name 'glColor3xvOES';
    
    static procedure Color4xvOES(components: ^fixed);
    external 'opengl32.dll' name 'glColor4xvOES';
    
    static procedure ConvolutionParameterxOES(target: ErrorCode; pname: ErrorCode; param: fixed);
    external 'opengl32.dll' name 'glConvolutionParameterxOES';
    
    static procedure ConvolutionParameterxvOES(target: ErrorCode; pname: ErrorCode; &params: ^fixed);
    external 'opengl32.dll' name 'glConvolutionParameterxvOES';
    
    static procedure EvalCoord1xOES(u: fixed);
    external 'opengl32.dll' name 'glEvalCoord1xOES';
    
    static procedure EvalCoord1xvOES(coords: ^fixed);
    external 'opengl32.dll' name 'glEvalCoord1xvOES';
    
    static procedure EvalCoord2xOES(u: fixed; v: fixed);
    external 'opengl32.dll' name 'glEvalCoord2xOES';
    
    static procedure EvalCoord2xvOES(coords: ^fixed);
    external 'opengl32.dll' name 'glEvalCoord2xvOES';
    
    static procedure FeedbackBufferxOES(n: Int32; &type: ErrorCode; buffer: ^fixed);
    external 'opengl32.dll' name 'glFeedbackBufferxOES';
    
    static procedure GetConvolutionParameterxvOES(target: ErrorCode; pname: ErrorCode; &params: ^fixed);
    external 'opengl32.dll' name 'glGetConvolutionParameterxvOES';
    
    static procedure GetHistogramParameterxvOES(target: ErrorCode; pname: ErrorCode; &params: ^fixed);
    external 'opengl32.dll' name 'glGetHistogramParameterxvOES';
    
    static procedure GetLightxOES(light: ErrorCode; pname: ErrorCode; &params: ^fixed);
    external 'opengl32.dll' name 'glGetLightxOES';
    
    static procedure GetMapxvOES(target: ErrorCode; query: ErrorCode; v: ^fixed);
    external 'opengl32.dll' name 'glGetMapxvOES';
    
    static procedure GetMaterialxOES(face: ErrorCode; pname: ErrorCode; param: fixed);
    external 'opengl32.dll' name 'glGetMaterialxOES';
    
    static procedure GetTexGenxvOES(coord: ErrorCode; pname: ErrorCode; &params: ^fixed);
    external 'opengl32.dll' name 'glGetTexGenxvOES';
    
    static procedure GetTexLevelParameterxvOES(target: ErrorCode; level: Int32; pname: ErrorCode; &params: ^fixed);
    external 'opengl32.dll' name 'glGetTexLevelParameterxvOES';
    
    static procedure IndexxOES(component: fixed);
    external 'opengl32.dll' name 'glIndexxOES';
    
    static procedure IndexxvOES(component: ^fixed);
    external 'opengl32.dll' name 'glIndexxvOES';
    
    static procedure LoadTransposeMatrixxOES(m: ^fixed);
    external 'opengl32.dll' name 'glLoadTransposeMatrixxOES';
    
    static procedure Map1xOES(target: ErrorCode; u1: fixed; u2: fixed; stride: Int32; order: Int32; points: fixed);
    external 'opengl32.dll' name 'glMap1xOES';
    
    static procedure Map2xOES(target: ErrorCode; u1: fixed; u2: fixed; ustride: Int32; uorder: Int32; v1: fixed; v2: fixed; vstride: Int32; vorder: Int32; points: fixed);
    external 'opengl32.dll' name 'glMap2xOES';
    
    static procedure MapGrid1xOES(n: Int32; u1: fixed; u2: fixed);
    external 'opengl32.dll' name 'glMapGrid1xOES';
    
    static procedure MapGrid2xOES(n: Int32; u1: fixed; u2: fixed; v1: fixed; v2: fixed);
    external 'opengl32.dll' name 'glMapGrid2xOES';
    
    static procedure MultTransposeMatrixxOES(m: ^fixed);
    external 'opengl32.dll' name 'glMultTransposeMatrixxOES';
    
    static procedure MultiTexCoord1xOES(texture: ErrorCode; s: fixed);
    external 'opengl32.dll' name 'glMultiTexCoord1xOES';
    
    static procedure MultiTexCoord1xvOES(texture: ErrorCode; coords: ^fixed);
    external 'opengl32.dll' name 'glMultiTexCoord1xvOES';
    
    static procedure MultiTexCoord2xOES(texture: ErrorCode; s: fixed; t: fixed);
    external 'opengl32.dll' name 'glMultiTexCoord2xOES';
    
    static procedure MultiTexCoord2xvOES(texture: ErrorCode; coords: ^fixed);
    external 'opengl32.dll' name 'glMultiTexCoord2xvOES';
    
    static procedure MultiTexCoord3xOES(texture: ErrorCode; s: fixed; t: fixed; r: fixed);
    external 'opengl32.dll' name 'glMultiTexCoord3xOES';
    
    static procedure MultiTexCoord3xvOES(texture: ErrorCode; coords: ^fixed);
    external 'opengl32.dll' name 'glMultiTexCoord3xvOES';
    
    static procedure MultiTexCoord4xvOES(texture: ErrorCode; coords: ^fixed);
    external 'opengl32.dll' name 'glMultiTexCoord4xvOES';
    
    static procedure Normal3xvOES(coords: ^fixed);
    external 'opengl32.dll' name 'glNormal3xvOES';
    
    static procedure PassThroughxOES(token: fixed);
    external 'opengl32.dll' name 'glPassThroughxOES';
    
    static procedure PixelTransferxOES(pname: ErrorCode; param: fixed);
    external 'opengl32.dll' name 'glPixelTransferxOES';
    
    static procedure PixelZoomxOES(xfactor: fixed; yfactor: fixed);
    external 'opengl32.dll' name 'glPixelZoomxOES';
    
    static procedure PrioritizeTexturesxOES(n: Int32; textures: ^UInt32; priorities: ^fixed);
    external 'opengl32.dll' name 'glPrioritizeTexturesxOES';
    
    static procedure RasterPos2xOES(x: fixed; y: fixed);
    external 'opengl32.dll' name 'glRasterPos2xOES';
    
    static procedure RasterPos2xvOES(coords: ^fixed);
    external 'opengl32.dll' name 'glRasterPos2xvOES';
    
    static procedure RasterPos3xOES(x: fixed; y: fixed; z: fixed);
    external 'opengl32.dll' name 'glRasterPos3xOES';
    
    static procedure RasterPos3xvOES(coords: ^fixed);
    external 'opengl32.dll' name 'glRasterPos3xvOES';
    
    static procedure RasterPos4xOES(x: fixed; y: fixed; z: fixed; w: fixed);
    external 'opengl32.dll' name 'glRasterPos4xOES';
    
    static procedure RasterPos4xvOES(coords: ^fixed);
    external 'opengl32.dll' name 'glRasterPos4xvOES';
    
    static procedure RectxOES(x1: fixed; y1: fixed; x2: fixed; y2: fixed);
    external 'opengl32.dll' name 'glRectxOES';
    
    static procedure RectxvOES(v1: ^fixed; v2: ^fixed);
    external 'opengl32.dll' name 'glRectxvOES';
    
    static procedure TexCoord1xOES(s: fixed);
    external 'opengl32.dll' name 'glTexCoord1xOES';
    
    static procedure TexCoord1xvOES(coords: ^fixed);
    external 'opengl32.dll' name 'glTexCoord1xvOES';
    
    static procedure TexCoord2xOES(s: fixed; t: fixed);
    external 'opengl32.dll' name 'glTexCoord2xOES';
    
    static procedure TexCoord2xvOES(coords: ^fixed);
    external 'opengl32.dll' name 'glTexCoord2xvOES';
    
    static procedure TexCoord3xOES(s: fixed; t: fixed; r: fixed);
    external 'opengl32.dll' name 'glTexCoord3xOES';
    
    static procedure TexCoord3xvOES(coords: ^fixed);
    external 'opengl32.dll' name 'glTexCoord3xvOES';
    
    static procedure TexCoord4xOES(s: fixed; t: fixed; r: fixed; q: fixed);
    external 'opengl32.dll' name 'glTexCoord4xOES';
    
    static procedure TexCoord4xvOES(coords: ^fixed);
    external 'opengl32.dll' name 'glTexCoord4xvOES';
    
    static procedure TexGenxOES(coord: ErrorCode; pname: ErrorCode; param: fixed);
    external 'opengl32.dll' name 'glTexGenxOES';
    
    static procedure TexGenxvOES(coord: ErrorCode; pname: ErrorCode; &params: ^fixed);
    external 'opengl32.dll' name 'glTexGenxvOES';
    
    static procedure Vertex2xOES(x: fixed);
    external 'opengl32.dll' name 'glVertex2xOES';
    
    static procedure Vertex2xvOES(coords: ^fixed);
    external 'opengl32.dll' name 'glVertex2xvOES';
    
    static procedure Vertex3xOES(x: fixed; y: fixed);
    external 'opengl32.dll' name 'glVertex3xOES';
    
    static procedure Vertex3xvOES(coords: ^fixed);
    external 'opengl32.dll' name 'glVertex3xvOES';
    
    static procedure Vertex4xOES(x: fixed; y: fixed; z: fixed);
    external 'opengl32.dll' name 'glVertex4xOES';
    
    static procedure Vertex4xvOES(coords: ^fixed);
    external 'opengl32.dll' name 'glVertex4xvOES';
    
    static function QueryMatrixxOES(mantissa: ^fixed; exponent: ^Int32): UInt32;
    external 'opengl32.dll' name 'glQueryMatrixxOES';
    
    static procedure ClearDepthfOES(depth: single);
    external 'opengl32.dll' name 'glClearDepthfOES';
    
    static procedure ClipPlanefOES(plane: ErrorCode; equation: ^single);
    external 'opengl32.dll' name 'glClipPlanefOES';
    
    static procedure DepthRangefOES(n: single; f: single);
    external 'opengl32.dll' name 'glDepthRangefOES';
    
    static procedure FrustumfOES(l: single; r: single; b: single; t: single; n: single; f: single);
    external 'opengl32.dll' name 'glFrustumfOES';
    
    static procedure GetClipPlanefOES(plane: ErrorCode; equation: ^single);
    external 'opengl32.dll' name 'glGetClipPlanefOES';
    
    static procedure OrthofOES(l: single; r: single; b: single; t: single; n: single; f: single);
    external 'opengl32.dll' name 'glOrthofOES';
    
    {$endregion OES}
    
  end;
  
  /// Расширения для надгрызенных яблок
  gl_APPLE = static class
    
    {$region APPLE}
    
    static procedure ElementPointerAPPLE(&type: ErrorCode; _pointer: pointer);
    external 'opengl32.dll' name 'glElementPointerAPPLE';
    
    static procedure DrawElementArrayAPPLE(mode: ErrorCode; first: Int32; count: Int32);
    external 'opengl32.dll' name 'glDrawElementArrayAPPLE';
    
    static procedure DrawRangeElementArrayAPPLE(mode: ErrorCode; start: UInt32; &end: UInt32; first: Int32; count: Int32);
    external 'opengl32.dll' name 'glDrawRangeElementArrayAPPLE';
    
    static procedure MultiDrawElementArrayAPPLE(mode: ErrorCode; first: ^Int32; count: ^Int32; primcount: Int32);
    external 'opengl32.dll' name 'glMultiDrawElementArrayAPPLE';
    
    static procedure MultiDrawRangeElementArrayAPPLE(mode: ErrorCode; start: UInt32; &end: UInt32; first: ^Int32; count: ^Int32; primcount: Int32);
    external 'opengl32.dll' name 'glMultiDrawRangeElementArrayAPPLE';
    
    static procedure GenFencesAPPLE(n: Int32; fences: ^UInt32);
    external 'opengl32.dll' name 'glGenFencesAPPLE';
    
    static procedure DeleteFencesAPPLE(n: Int32; fences: ^UInt32);
    external 'opengl32.dll' name 'glDeleteFencesAPPLE';
    
    static procedure SetFenceAPPLE(fence: UInt32);
    external 'opengl32.dll' name 'glSetFenceAPPLE';
    
    static function IsFenceAPPLE(fence: UInt32): Byte;
    external 'opengl32.dll' name 'glIsFenceAPPLE';
    
    static function TestFenceAPPLE(fence: UInt32): Byte;
    external 'opengl32.dll' name 'glTestFenceAPPLE';
    
    static procedure FinishFenceAPPLE(fence: UInt32);
    external 'opengl32.dll' name 'glFinishFenceAPPLE';
    
    static function TestObjectAPPLE(object: ErrorCode; name: UInt32): Byte;
    external 'opengl32.dll' name 'glTestObjectAPPLE';
    
    static procedure FinishObjectAPPLE(object: ErrorCode; name: Int32);
    external 'opengl32.dll' name 'glFinishObjectAPPLE';
    
    static procedure BufferParameteriAPPLE(target: ErrorCode; pname: ErrorCode; param: Int32);
    external 'opengl32.dll' name 'glBufferParameteriAPPLE';
    
    static procedure FlushMappedBufferRangeAPPLE(target: ErrorCode; offset: IntPtr; size: UIntPtr);
    external 'opengl32.dll' name 'glFlushMappedBufferRangeAPPLE';
    
    static function ObjectPurgeableAPPLE(objectType: ErrorCode; name: UInt32; option: ErrorCode): ErrorCode;
    external 'opengl32.dll' name 'glObjectPurgeableAPPLE';
    
    static function ObjectUnpurgeableAPPLE(objectType: ErrorCode; name: UInt32; option: ErrorCode): ErrorCode;
    external 'opengl32.dll' name 'glObjectUnpurgeableAPPLE';
    
    static procedure GetObjectParameterivAPPLE(objectType: ErrorCode; name: UInt32; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetObjectParameterivAPPLE';
    
    static procedure TextureRangeAPPLE(target: ErrorCode; length: Int32; _pointer: pointer);
    external 'opengl32.dll' name 'glTextureRangeAPPLE';
    
    static procedure GetTexParameterPointervAPPLE(target: ErrorCode; pname: ErrorCode; &params: ^pointer);
    external 'opengl32.dll' name 'glGetTexParameterPointervAPPLE';
    
    static procedure BindVertexArrayAPPLE(&array: UInt32);
    external 'opengl32.dll' name 'glBindVertexArrayAPPLE';
    
    static procedure DeleteVertexArraysAPPLE(n: Int32; arrays: ^UInt32);
    external 'opengl32.dll' name 'glDeleteVertexArraysAPPLE';
    
    static procedure GenVertexArraysAPPLE(n: Int32; arrays: ^UInt32);
    external 'opengl32.dll' name 'glGenVertexArraysAPPLE';
    
    static function IsVertexArrayAPPLE(&array: UInt32): Byte;
    external 'opengl32.dll' name 'glIsVertexArrayAPPLE';
    
    static procedure VertexArrayRangeAPPLE(length: Int32; _pointer: pointer);
    external 'opengl32.dll' name 'glVertexArrayRangeAPPLE';
    
    static procedure FlushVertexArrayRangeAPPLE(length: Int32; _pointer: pointer);
    external 'opengl32.dll' name 'glFlushVertexArrayRangeAPPLE';
    
    static procedure VertexArrayParameteriAPPLE(pname: ErrorCode; param: Int32);
    external 'opengl32.dll' name 'glVertexArrayParameteriAPPLE';
    
    static procedure EnableVertexAttribAPPLE(index: UInt32; pname: ErrorCode);
    external 'opengl32.dll' name 'glEnableVertexAttribAPPLE';
    
    static procedure DisableVertexAttribAPPLE(index: UInt32; pname: ErrorCode);
    external 'opengl32.dll' name 'glDisableVertexAttribAPPLE';
    
    static function IsVertexAttribEnabledAPPLE(index: UInt32; pname: ErrorCode): Byte;
    external 'opengl32.dll' name 'glIsVertexAttribEnabledAPPLE';
    
    static procedure MapVertexAttrib1dAPPLE(index: UInt32; size: UInt32; u1: double; u2: double; stride: Int32; order: Int32; points: ^double);
    external 'opengl32.dll' name 'glMapVertexAttrib1dAPPLE';
    
    static procedure MapVertexAttrib1fAPPLE(index: UInt32; size: UInt32; u1: single; u2: single; stride: Int32; order: Int32; points: ^single);
    external 'opengl32.dll' name 'glMapVertexAttrib1fAPPLE';
    
    static procedure MapVertexAttrib2dAPPLE(index: UInt32; size: UInt32; u1: double; u2: double; ustride: Int32; uorder: Int32; v1: double; v2: double; vstride: Int32; vorder: Int32; points: ^double);
    external 'opengl32.dll' name 'glMapVertexAttrib2dAPPLE';
    
    static procedure MapVertexAttrib2fAPPLE(index: UInt32; size: UInt32; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; points: ^single);
    external 'opengl32.dll' name 'glMapVertexAttrib2fAPPLE';
    
    {$endregion APPLE}
    
  end;
  
  /// Расширения GREMEDY для логирования
  gl_GREMEDY = static class
    
    {$region GREMEDY}
    
    static procedure FrameTerminatorGREMEDY;
    external 'opengl32.dll' name 'glFrameTerminatorGREMEDY';
    
    static procedure StringMarkerGREMEDY(len: Int32; string: pointer);
    external 'opengl32.dll' name 'glStringMarkerGREMEDY';
    
    {$endregion GREMEDY}
    
  end;
  
  /// Расширения для ноутбуков от HP
  /// Первая страница ответов в гугле заполнена:
  /// "у меня не работает OpenGL на HP ноуте, хелп"
  /// Выглядит как достаточнно инфы)))
  gl_HP = static class
    
    {$region HP}
    
    static procedure ImageTransformParameteriHP(target: ErrorCode; pname: ErrorCode; param: Int32);
    external 'opengl32.dll' name 'glImageTransformParameteriHP';
    
    static procedure ImageTransformParameterfHP(target: ErrorCode; pname: ErrorCode; param: single);
    external 'opengl32.dll' name 'glImageTransformParameterfHP';
    
    static procedure ImageTransformParameterivHP(target: ErrorCode; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glImageTransformParameterivHP';
    
    static procedure ImageTransformParameterfvHP(target: ErrorCode; pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glImageTransformParameterfvHP';
    
    static procedure GetImageTransformParameterivHP(target: ErrorCode; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetImageTransformParameterivHP';
    
    static procedure GetImageTransformParameterfvHP(target: ErrorCode; pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glGetImageTransformParameterfvHP';
    
    {$endregion HP}
    
  end;
  
  /// Расширения для "International Business Machines"
  /// То есть для электроники для бизнеса
  gl_IBM = static class
    
    {$region IBM}
    
    static procedure MultiModeDrawArraysIBM(mode: ^ErrorCode; first: ^Int32; count: ^Int32; primcount: Int32; modestride: Int32);
    external 'opengl32.dll' name 'glMultiModeDrawArraysIBM';
    
    static procedure MultiModeDrawElementsIBM(mode: ^ErrorCode; count: ^Int32; &type: ErrorCode; indices: ^pointer; primcount: Int32; modestride: Int32);
    external 'opengl32.dll' name 'glMultiModeDrawElementsIBM';
    
    static procedure FlushStaticDataIBM(target: ErrorCode);
    external 'opengl32.dll' name 'glFlushStaticDataIBM';
    
    static procedure ColorPointerListIBM(size: Int32; &type: ErrorCode; stride: Int32; _pointer: ^pointer; ptrstride: Int32);
    external 'opengl32.dll' name 'glColorPointerListIBM';
    
    static procedure SecondaryColorPointerListIBM(size: Int32; &type: ErrorCode; stride: Int32; _pointer: ^pointer; ptrstride: Int32);
    external 'opengl32.dll' name 'glSecondaryColorPointerListIBM';
    
    static procedure EdgeFlagPointerListIBM(stride: Int32; _pointer: ^^Byte; ptrstride: Int32);
    external 'opengl32.dll' name 'glEdgeFlagPointerListIBM';
    
    static procedure FogCoordPointerListIBM(&type: ErrorCode; stride: Int32; _pointer: ^pointer; ptrstride: Int32);
    external 'opengl32.dll' name 'glFogCoordPointerListIBM';
    
    static procedure IndexPointerListIBM(&type: ErrorCode; stride: Int32; _pointer: ^pointer; ptrstride: Int32);
    external 'opengl32.dll' name 'glIndexPointerListIBM';
    
    static procedure NormalPointerListIBM(&type: ErrorCode; stride: Int32; _pointer: ^pointer; ptrstride: Int32);
    external 'opengl32.dll' name 'glNormalPointerListIBM';
    
    static procedure TexCoordPointerListIBM(size: Int32; &type: ErrorCode; stride: Int32; _pointer: ^pointer; ptrstride: Int32);
    external 'opengl32.dll' name 'glTexCoordPointerListIBM';
    
    static procedure VertexPointerListIBM(size: Int32; &type: ErrorCode; stride: Int32; _pointer: ^pointer; ptrstride: Int32);
    external 'opengl32.dll' name 'glVertexPointerListIBM';
    
    {$endregion IBM}
    
  end;
  
  /// Intergraph Corporation
  /// Вроде что то древнее и влиятельное, вроде как на уровне Oracle и Microsoft
  /// Ну понятно, поэтому у них аж 1 функция))
  gl_INGR = static class
    
    {$region INGR}
    
    static procedure BlendFuncSeparateINGR(sfactorRGB: ErrorCode; dfactorRGB: ErrorCode; sfactorAlpha: ErrorCode; dfactorAlpha: ErrorCode);
    external 'opengl32.dll' name 'glBlendFuncSeparateINGR';
    
    {$endregion INGR}
    
  end;
  
  /// Совместное с Vulkan расширение для 3D графики
  /// Которое такое важное что на нём UNIX-подобные системы строятся и без него не работают
  /// Vulkan, кстати, те же люди придумывали, что OpenGL
  gl_MESA = static class
    
    {$region MESA}
    
    static procedure ResizeBuffersMESA;
    external 'opengl32.dll' name 'glResizeBuffersMESA';
    
    static procedure WindowPos2dMESA(x: double; y: double);
    external 'opengl32.dll' name 'glWindowPos2dMESA';
    
    static procedure WindowPos2dvMESA(v: ^double);
    external 'opengl32.dll' name 'glWindowPos2dvMESA';
    
    static procedure WindowPos2fMESA(x: single; y: single);
    external 'opengl32.dll' name 'glWindowPos2fMESA';
    
    static procedure WindowPos2fvMESA(v: ^single);
    external 'opengl32.dll' name 'glWindowPos2fvMESA';
    
    static procedure WindowPos2iMESA(x: Int32; y: Int32);
    external 'opengl32.dll' name 'glWindowPos2iMESA';
    
    static procedure WindowPos2ivMESA(v: ^Int32);
    external 'opengl32.dll' name 'glWindowPos2ivMESA';
    
    static procedure WindowPos2sMESA(x: Int16; y: Int16);
    external 'opengl32.dll' name 'glWindowPos2sMESA';
    
    static procedure WindowPos2svMESA(v: ^Int16);
    external 'opengl32.dll' name 'glWindowPos2svMESA';
    
    static procedure WindowPos3dMESA(x: double; y: double; z: double);
    external 'opengl32.dll' name 'glWindowPos3dMESA';
    
    static procedure WindowPos3dvMESA(v: ^double);
    external 'opengl32.dll' name 'glWindowPos3dvMESA';
    
    static procedure WindowPos3fMESA(x: single; y: single; z: single);
    external 'opengl32.dll' name 'glWindowPos3fMESA';
    
    static procedure WindowPos3fvMESA(v: ^single);
    external 'opengl32.dll' name 'glWindowPos3fvMESA';
    
    static procedure WindowPos3iMESA(x: Int32; y: Int32; z: Int32);
    external 'opengl32.dll' name 'glWindowPos3iMESA';
    
    static procedure WindowPos3ivMESA(v: ^Int32);
    external 'opengl32.dll' name 'glWindowPos3ivMESA';
    
    static procedure WindowPos3sMESA(x: Int16; y: Int16; z: Int16);
    external 'opengl32.dll' name 'glWindowPos3sMESA';
    
    static procedure WindowPos3svMESA(v: ^Int16);
    external 'opengl32.dll' name 'glWindowPos3svMESA';
    
    static procedure WindowPos4dMESA(x: double; y: double; z: double; w: double);
    external 'opengl32.dll' name 'glWindowPos4dMESA';
    
    static procedure WindowPos4dvMESA(v: ^double);
    external 'opengl32.dll' name 'glWindowPos4dvMESA';
    
    static procedure WindowPos4fMESA(x: single; y: single; z: single; w: single);
    external 'opengl32.dll' name 'glWindowPos4fMESA';
    
    static procedure WindowPos4fvMESA(v: ^single);
    external 'opengl32.dll' name 'glWindowPos4fvMESA';
    
    static procedure WindowPos4iMESA(x: Int32; y: Int32; z: Int32; w: Int32);
    external 'opengl32.dll' name 'glWindowPos4iMESA';
    
    static procedure WindowPos4ivMESA(v: ^Int32);
    external 'opengl32.dll' name 'glWindowPos4ivMESA';
    
    static procedure WindowPos4sMESA(x: Int16; y: Int16; z: Int16; w: Int16);
    external 'opengl32.dll' name 'glWindowPos4sMESA';
    
    static procedure WindowPos4svMESA(v: ^Int16);
    external 'opengl32.dll' name 'glWindowPos4svMESA';
    
    {$endregion MESA}
    
  end;
  
  /// Silicon Graphics, Inc.
  gl_SGI = static class
    
    {$region SGI}
    
    static procedure ColorTableSGI(target: ErrorCode; internalformat: ErrorCode; width: Int32; format: ErrorCode; &type: ErrorCode; table: pointer);
    external 'opengl32.dll' name 'glColorTableSGI';
    
    static procedure ColorTableParameterfvSGI(target: ErrorCode; pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glColorTableParameterfvSGI';
    
    static procedure ColorTableParameterivSGI(target: ErrorCode; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glColorTableParameterivSGI';
    
    static procedure CopyColorTableSGI(target: ErrorCode; internalformat: ErrorCode; x: Int32; y: Int32; width: Int32);
    external 'opengl32.dll' name 'glCopyColorTableSGI';
    
    static procedure GetColorTableSGI(target: ErrorCode; format: ErrorCode; &type: ErrorCode; table: pointer);
    external 'opengl32.dll' name 'glGetColorTableSGI';
    
    static procedure GetColorTableParameterfvSGI(target: ErrorCode; pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glGetColorTableParameterfvSGI';
    
    static procedure GetColorTableParameterivSGI(target: ErrorCode; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetColorTableParameterivSGI';
    
    {$endregion SGI}
    
    // эксперементальное, то есть то, что может быть удалено/изменено в любой момент:
    
    {$region SGIS}
    
    static procedure DetailTexFuncSGIS(target: ErrorCode; n: Int32; points: ^single);
    external 'opengl32.dll' name 'glDetailTexFuncSGIS';
    
    static procedure GetDetailTexFuncSGIS(target: ErrorCode; points: ^single);
    external 'opengl32.dll' name 'glGetDetailTexFuncSGIS';
    
    static procedure FogFuncSGIS(n: Int32; points: ^single);
    external 'opengl32.dll' name 'glFogFuncSGIS';
    
    static procedure GetFogFuncSGIS(points: ^single);
    external 'opengl32.dll' name 'glGetFogFuncSGIS';
    
    static procedure SampleMaskSGIS(value: single; invert: Byte);
    external 'opengl32.dll' name 'glSampleMaskSGIS';
    
    static procedure SamplePatternSGIS(pattern: ErrorCode);
    external 'opengl32.dll' name 'glSamplePatternSGIS';
    
    static procedure PixelTexGenParameteriSGIS(pname: ErrorCode; param: Int32);
    external 'opengl32.dll' name 'glPixelTexGenParameteriSGIS';
    
    static procedure PixelTexGenParameterivSGIS(pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glPixelTexGenParameterivSGIS';
    
    static procedure PixelTexGenParameterfSGIS(pname: ErrorCode; param: single);
    external 'opengl32.dll' name 'glPixelTexGenParameterfSGIS';
    
    static procedure PixelTexGenParameterfvSGIS(pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glPixelTexGenParameterfvSGIS';
    
    static procedure GetPixelTexGenParameterivSGIS(pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetPixelTexGenParameterivSGIS';
    
    static procedure GetPixelTexGenParameterfvSGIS(pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glGetPixelTexGenParameterfvSGIS';
    
    static procedure PointParameterfSGIS(pname: ErrorCode; param: single);
    external 'opengl32.dll' name 'glPointParameterfSGIS';
    
    static procedure PointParameterfvSGIS(pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glPointParameterfvSGIS';
    
    static procedure SharpenTexFuncSGIS(target: ErrorCode; n: Int32; points: ^single);
    external 'opengl32.dll' name 'glSharpenTexFuncSGIS';
    
    static procedure GetSharpenTexFuncSGIS(target: ErrorCode; points: ^single);
    external 'opengl32.dll' name 'glGetSharpenTexFuncSGIS';
    
    static procedure TexImage4DSGIS(target: ErrorCode; level: Int32; internalformat: ErrorCode; width: Int32; height: Int32; depth: Int32; size4d: Int32; border: Int32; format: ErrorCode; &type: ErrorCode; pixels: pointer);
    external 'opengl32.dll' name 'glTexImage4DSGIS';
    
    static procedure TexSubImage4DSGIS(target: ErrorCode; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; woffset: Int32; width: Int32; height: Int32; depth: Int32; size4d: Int32; format: ErrorCode; &type: ErrorCode; pixels: pointer);
    external 'opengl32.dll' name 'glTexSubImage4DSGIS';
    
    static procedure TextureColorMaskSGIS(red: Byte; green: Byte; blue: Byte; alpha: Byte);
    external 'opengl32.dll' name 'glTextureColorMaskSGIS';
    
    static procedure GetTexFilterFuncSGIS(target: ErrorCode; filter: ErrorCode; weights: ^single);
    external 'opengl32.dll' name 'glGetTexFilterFuncSGIS';
    
    static procedure TexFilterFuncSGIS(target: ErrorCode; filter: ErrorCode; n: Int32; weights: ^single);
    external 'opengl32.dll' name 'glTexFilterFuncSGIS';
    
    {$endregion SGIS}
    
    {$region SGIX}
    
    static procedure AsyncMarkerSGIX(marker: UInt32);
    external 'opengl32.dll' name 'glAsyncMarkerSGIX';
    
    static function FinishAsyncSGIX(markerp: ^UInt32): Int32;
    external 'opengl32.dll' name 'glFinishAsyncSGIX';
    
    static function PollAsyncSGIX(markerp: ^UInt32): Int32;
    external 'opengl32.dll' name 'glPollAsyncSGIX';
    
    static function GenAsyncMarkersSGIX(range: Int32): UInt32;
    external 'opengl32.dll' name 'glGenAsyncMarkersSGIX';
    
    static procedure DeleteAsyncMarkersSGIX(marker: UInt32; range: Int32);
    external 'opengl32.dll' name 'glDeleteAsyncMarkersSGIX';
    
    static function IsAsyncMarkerSGIX(marker: UInt32): Byte;
    external 'opengl32.dll' name 'glIsAsyncMarkerSGIX';
    
    static procedure FlushRasterSGIX;
    external 'opengl32.dll' name 'glFlushRasterSGIX';
    
    static procedure FragmentColorMaterialSGIX(face: ErrorCode; mode: ErrorCode);
    external 'opengl32.dll' name 'glFragmentColorMaterialSGIX';
    
    static procedure FragmentLightfSGIX(light: ErrorCode; pname: ErrorCode; param: single);
    external 'opengl32.dll' name 'glFragmentLightfSGIX';
    
    static procedure FragmentLightfvSGIX(light: ErrorCode; pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glFragmentLightfvSGIX';
    
    static procedure FragmentLightiSGIX(light: ErrorCode; pname: ErrorCode; param: Int32);
    external 'opengl32.dll' name 'glFragmentLightiSGIX';
    
    static procedure FragmentLightivSGIX(light: ErrorCode; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glFragmentLightivSGIX';
    
    static procedure FragmentLightModelfSGIX(pname: ErrorCode; param: single);
    external 'opengl32.dll' name 'glFragmentLightModelfSGIX';
    
    static procedure FragmentLightModelfvSGIX(pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glFragmentLightModelfvSGIX';
    
    static procedure FragmentLightModeliSGIX(pname: ErrorCode; param: Int32);
    external 'opengl32.dll' name 'glFragmentLightModeliSGIX';
    
    static procedure FragmentLightModelivSGIX(pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glFragmentLightModelivSGIX';
    
    static procedure FragmentMaterialfSGIX(face: ErrorCode; pname: ErrorCode; param: single);
    external 'opengl32.dll' name 'glFragmentMaterialfSGIX';
    
    static procedure FragmentMaterialfvSGIX(face: ErrorCode; pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glFragmentMaterialfvSGIX';
    
    static procedure FragmentMaterialiSGIX(face: ErrorCode; pname: ErrorCode; param: Int32);
    external 'opengl32.dll' name 'glFragmentMaterialiSGIX';
    
    static procedure FragmentMaterialivSGIX(face: ErrorCode; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glFragmentMaterialivSGIX';
    
    static procedure GetFragmentLightfvSGIX(light: ErrorCode; pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glGetFragmentLightfvSGIX';
    
    static procedure GetFragmentLightivSGIX(light: ErrorCode; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetFragmentLightivSGIX';
    
    static procedure GetFragmentMaterialfvSGIX(face: ErrorCode; pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glGetFragmentMaterialfvSGIX';
    
    static procedure GetFragmentMaterialivSGIX(face: ErrorCode; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetFragmentMaterialivSGIX';
    
    static procedure LightEnviSGIX(pname: ErrorCode; param: Int32);
    external 'opengl32.dll' name 'glLightEnviSGIX';
    
    static procedure FrameZoomSGIX(factor: Int32);
    external 'opengl32.dll' name 'glFrameZoomSGIX';
    
    static procedure IglooInterfaceSGIX(pname: ErrorCode; &params: pointer);
    external 'opengl32.dll' name 'glIglooInterfaceSGIX';
    
    static function GetInstrumentsSGIX: Int32;
    external 'opengl32.dll' name 'glGetInstrumentsSGIX';
    
    static procedure InstrumentsBufferSGIX(size: Int32; buffer: ^Int32);
    external 'opengl32.dll' name 'glInstrumentsBufferSGIX';
    
    static function PollInstrumentsSGIX(marker_p: ^Int32): Int32;
    external 'opengl32.dll' name 'glPollInstrumentsSGIX';
    
    static procedure ReadInstrumentsSGIX(marker: Int32);
    external 'opengl32.dll' name 'glReadInstrumentsSGIX';
    
    static procedure StartInstrumentsSGIX;
    external 'opengl32.dll' name 'glStartInstrumentsSGIX';
    
    static procedure StopInstrumentsSGIX(marker: Int32);
    external 'opengl32.dll' name 'glStopInstrumentsSGIX';
    
    static procedure GetListParameterfvSGIX(list: UInt32; pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glGetListParameterfvSGIX';
    
    static procedure GetListParameterivSGIX(list: UInt32; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetListParameterivSGIX';
    
    static procedure ListParameterfSGIX(list: UInt32; pname: ErrorCode; param: single);
    external 'opengl32.dll' name 'glListParameterfSGIX';
    
    static procedure ListParameterfvSGIX(list: UInt32; pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glListParameterfvSGIX';
    
    static procedure ListParameteriSGIX(list: UInt32; pname: ErrorCode; param: Int32);
    external 'opengl32.dll' name 'glListParameteriSGIX';
    
    static procedure ListParameterivSGIX(list: UInt32; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glListParameterivSGIX';
    
    static procedure PixelTexGenSGIX(mode: ErrorCode);
    external 'opengl32.dll' name 'glPixelTexGenSGIX';
    
    static procedure DeformationMap3dSGIX(target: ErrorCode; u1: double; u2: double; ustride: Int32; uorder: Int32; v1: double; v2: double; vstride: Int32; vorder: Int32; w1: double; w2: double; wstride: Int32; worder: Int32; points: ^double);
    external 'opengl32.dll' name 'glDeformationMap3dSGIX';
    
    static procedure DeformationMap3fSGIX(target: ErrorCode; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; w1: single; w2: single; wstride: Int32; worder: Int32; points: ^single);
    external 'opengl32.dll' name 'glDeformationMap3fSGIX';
    
    static procedure DeformSGIX(mask: UInt32);
    external 'opengl32.dll' name 'glDeformSGIX';
    
    static procedure LoadIdentityDeformationMapSGIX(mask: UInt32);
    external 'opengl32.dll' name 'glLoadIdentityDeformationMapSGIX';
    
    static procedure ReferencePlaneSGIX(equation: ^double);
    external 'opengl32.dll' name 'glReferencePlaneSGIX';
    
    static procedure SpriteParameterfSGIX(pname: ErrorCode; param: single);
    external 'opengl32.dll' name 'glSpriteParameterfSGIX';
    
    static procedure SpriteParameterfvSGIX(pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glSpriteParameterfvSGIX';
    
    static procedure SpriteParameteriSGIX(pname: ErrorCode; param: Int32);
    external 'opengl32.dll' name 'glSpriteParameteriSGIX';
    
    static procedure SpriteParameterivSGIX(pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glSpriteParameterivSGIX';
    
    static procedure TagSampleBufferSGIX;
    external 'opengl32.dll' name 'glTagSampleBufferSGIX';
    
    {$endregion SGIX}
    
  end;
  
  //ToDo досортировать
  
  /// То, до чего у меня дойдут руки позже
  /// Наверное, большинство функций тут - устаревшие
  /// Потому что их нет в спецификации ядра OpenGL
  /// И у них нет приставки расширения на конце (несколько больших букв, как EXT или NV)
  /// А других групп функций - я ещё не встречал
  gl_unsorted = static class
    
    {$region unsorted}
    
    static procedure MultiTexCoord1d(target: ErrorCode; s: double);
    external 'opengl32.dll' name 'glMultiTexCoord1d';
    
    static procedure MultiTexCoord1dv(target: ErrorCode; v: ^double);
    external 'opengl32.dll' name 'glMultiTexCoord1dv';
    
    static procedure MultiTexCoord1f(target: ErrorCode; s: single);
    external 'opengl32.dll' name 'glMultiTexCoord1f';
    
    static procedure MultiTexCoord1fv(target: ErrorCode; v: ^single);
    external 'opengl32.dll' name 'glMultiTexCoord1fv';
    
    static procedure MultiTexCoord1i(target: ErrorCode; s: Int32);
    external 'opengl32.dll' name 'glMultiTexCoord1i';
    
    static procedure MultiTexCoord1iv(target: ErrorCode; v: ^Int32);
    external 'opengl32.dll' name 'glMultiTexCoord1iv';
    
    static procedure MultiTexCoord1s(target: ErrorCode; s: Int16);
    external 'opengl32.dll' name 'glMultiTexCoord1s';
    
    static procedure MultiTexCoord1sv(target: ErrorCode; v: ^Int16);
    external 'opengl32.dll' name 'glMultiTexCoord1sv';
    
    static procedure MultiTexCoord2d(target: ErrorCode; s: double; t: double);
    external 'opengl32.dll' name 'glMultiTexCoord2d';
    
    static procedure MultiTexCoord2dv(target: ErrorCode; v: ^double);
    external 'opengl32.dll' name 'glMultiTexCoord2dv';
    
    static procedure MultiTexCoord2i(target: ErrorCode; s: Int32; t: Int32);
    external 'opengl32.dll' name 'glMultiTexCoord2i';
    
    static procedure MultiTexCoord2iv(target: ErrorCode; v: ^Int32);
    external 'opengl32.dll' name 'glMultiTexCoord2iv';
    
    static procedure MultiTexCoord2s(target: ErrorCode; s: Int16; t: Int16);
    external 'opengl32.dll' name 'glMultiTexCoord2s';
    
    static procedure MultiTexCoord2sv(target: ErrorCode; v: ^Int16);
    external 'opengl32.dll' name 'glMultiTexCoord2sv';
    
    static procedure MultiTexCoord3d(target: ErrorCode; s: double; t: double; r: double);
    external 'opengl32.dll' name 'glMultiTexCoord3d';
    
    static procedure MultiTexCoord3dv(target: ErrorCode; v: ^double);
    external 'opengl32.dll' name 'glMultiTexCoord3dv';
    
    static procedure MultiTexCoord3f(target: ErrorCode; s: single; t: single; r: single);
    external 'opengl32.dll' name 'glMultiTexCoord3f';
    
    static procedure MultiTexCoord3fv(target: ErrorCode; v: ^single);
    external 'opengl32.dll' name 'glMultiTexCoord3fv';
    
    static procedure MultiTexCoord3i(target: ErrorCode; s: Int32; t: Int32; r: Int32);
    external 'opengl32.dll' name 'glMultiTexCoord3i';
    
    static procedure MultiTexCoord3iv(target: ErrorCode; v: ^Int32);
    external 'opengl32.dll' name 'glMultiTexCoord3iv';
    
    static procedure MultiTexCoord3s(target: ErrorCode; s: Int16; t: Int16; r: Int16);
    external 'opengl32.dll' name 'glMultiTexCoord3s';
    
    static procedure MultiTexCoord3sv(target: ErrorCode; v: ^Int16);
    external 'opengl32.dll' name 'glMultiTexCoord3sv';
    
    static procedure MultiTexCoord4d(target: ErrorCode; s: double; t: double; r: double; q: double);
    external 'opengl32.dll' name 'glMultiTexCoord4d';
    
    static procedure MultiTexCoord4dv(target: ErrorCode; v: ^double);
    external 'opengl32.dll' name 'glMultiTexCoord4dv';
    
    static procedure MultiTexCoord4f(target: ErrorCode; s: single; t: single; r: single; q: single);
    external 'opengl32.dll' name 'glMultiTexCoord4f';
    
    static procedure MultiTexCoord4fv(target: ErrorCode; v: ^single);
    external 'opengl32.dll' name 'glMultiTexCoord4fv';
    
    static procedure MultiTexCoord4i(target: ErrorCode; s: Int32; t: Int32; r: Int32; q: Int32);
    external 'opengl32.dll' name 'glMultiTexCoord4i';
    
    static procedure MultiTexCoord4iv(target: ErrorCode; v: ^Int32);
    external 'opengl32.dll' name 'glMultiTexCoord4iv';
    
    static procedure MultiTexCoord4s(target: ErrorCode; s: Int16; t: Int16; r: Int16; q: Int16);
    external 'opengl32.dll' name 'glMultiTexCoord4s';
    
    static procedure MultiTexCoord4sv(target: ErrorCode; v: ^Int16);
    external 'opengl32.dll' name 'glMultiTexCoord4sv';
    
    static procedure LoadTransposeMatrixf(m: ^single);
    external 'opengl32.dll' name 'glLoadTransposeMatrixf';
    
    static procedure LoadTransposeMatrixd(m: ^double);
    external 'opengl32.dll' name 'glLoadTransposeMatrixd';
    
    static procedure MultTransposeMatrixf(m: ^single);
    external 'opengl32.dll' name 'glMultTransposeMatrixf';
    
    static procedure MultTransposeMatrixd(m: ^double);
    external 'opengl32.dll' name 'glMultTransposeMatrixd';
    
    static procedure FogCoordf(coord: single);
    external 'opengl32.dll' name 'glFogCoordf';
    
    static procedure FogCoordfv(coord: ^single);
    external 'opengl32.dll' name 'glFogCoordfv';
    
    static procedure FogCoordd(coord: double);
    external 'opengl32.dll' name 'glFogCoordd';
    
    static procedure FogCoorddv(coord: ^double);
    external 'opengl32.dll' name 'glFogCoorddv';
    
    static procedure FogCoordPointer(&type: ErrorCode; stride: Int32; _pointer: pointer);
    external 'opengl32.dll' name 'glFogCoordPointer';
    
    static procedure SecondaryColor3b(red: SByte; green: SByte; blue: SByte);
    external 'opengl32.dll' name 'glSecondaryColor3b';
    
    static procedure SecondaryColor3bv(v: ^SByte);
    external 'opengl32.dll' name 'glSecondaryColor3bv';
    
    static procedure SecondaryColor3d(red: double; green: double; blue: double);
    external 'opengl32.dll' name 'glSecondaryColor3d';
    
    static procedure SecondaryColor3dv(v: ^double);
    external 'opengl32.dll' name 'glSecondaryColor3dv';
    
    static procedure SecondaryColor3f(red: single; green: single; blue: single);
    external 'opengl32.dll' name 'glSecondaryColor3f';
    
    static procedure SecondaryColor3fv(v: ^single);
    external 'opengl32.dll' name 'glSecondaryColor3fv';
    
    static procedure SecondaryColor3i(red: Int32; green: Int32; blue: Int32);
    external 'opengl32.dll' name 'glSecondaryColor3i';
    
    static procedure SecondaryColor3iv(v: ^Int32);
    external 'opengl32.dll' name 'glSecondaryColor3iv';
    
    static procedure SecondaryColor3s(red: Int16; green: Int16; blue: Int16);
    external 'opengl32.dll' name 'glSecondaryColor3s';
    
    static procedure SecondaryColor3sv(v: ^Int16);
    external 'opengl32.dll' name 'glSecondaryColor3sv';
    
    static procedure SecondaryColor3ub(red: Byte; green: Byte; blue: Byte);
    external 'opengl32.dll' name 'glSecondaryColor3ub';
    
    static procedure SecondaryColor3ubv(v: ^Byte);
    external 'opengl32.dll' name 'glSecondaryColor3ubv';
    
    static procedure SecondaryColor3ui(red: UInt32; green: UInt32; blue: UInt32);
    external 'opengl32.dll' name 'glSecondaryColor3ui';
    
    static procedure SecondaryColor3uiv(v: ^UInt32);
    external 'opengl32.dll' name 'glSecondaryColor3uiv';
    
    static procedure SecondaryColor3us(red: UInt16; green: UInt16; blue: UInt16);
    external 'opengl32.dll' name 'glSecondaryColor3us';
    
    static procedure SecondaryColor3usv(v: ^UInt16);
    external 'opengl32.dll' name 'glSecondaryColor3usv';
    
    static procedure SecondaryColorPointer(size: Int32; &type: ErrorCode; stride: Int32; _pointer: pointer);
    external 'opengl32.dll' name 'glSecondaryColorPointer';
    
    static procedure WindowPos2d(x: double; y: double);
    external 'opengl32.dll' name 'glWindowPos2d';
    
    static procedure WindowPos2dv(v: ^double);
    external 'opengl32.dll' name 'glWindowPos2dv';
    
    static procedure WindowPos2f(x: single; y: single);
    external 'opengl32.dll' name 'glWindowPos2f';
    
    static procedure WindowPos2fv(v: ^single);
    external 'opengl32.dll' name 'glWindowPos2fv';
    
    static procedure WindowPos2i(x: Int32; y: Int32);
    external 'opengl32.dll' name 'glWindowPos2i';
    
    static procedure WindowPos2iv(v: ^Int32);
    external 'opengl32.dll' name 'glWindowPos2iv';
    
    static procedure WindowPos2s(x: Int16; y: Int16);
    external 'opengl32.dll' name 'glWindowPos2s';
    
    static procedure WindowPos2sv(v: ^Int16);
    external 'opengl32.dll' name 'glWindowPos2sv';
    
    static procedure WindowPos3d(x: double; y: double; z: double);
    external 'opengl32.dll' name 'glWindowPos3d';
    
    static procedure WindowPos3dv(v: ^double);
    external 'opengl32.dll' name 'glWindowPos3dv';
    
    static procedure WindowPos3f(x: single; y: single; z: single);
    external 'opengl32.dll' name 'glWindowPos3f';
    
    static procedure WindowPos3fv(v: ^single);
    external 'opengl32.dll' name 'glWindowPos3fv';
    
    static procedure WindowPos3i(x: Int32; y: Int32; z: Int32);
    external 'opengl32.dll' name 'glWindowPos3i';
    
    static procedure WindowPos3iv(v: ^Int32);
    external 'opengl32.dll' name 'glWindowPos3iv';
    
    static procedure WindowPos3s(x: Int16; y: Int16; z: Int16);
    external 'opengl32.dll' name 'glWindowPos3s';
    
    static procedure WindowPos3sv(v: ^Int16);
    external 'opengl32.dll' name 'glWindowPos3sv';
    
    static function CreateProgram: UInt32;
    external 'opengl32.dll' name 'glCreateProgram';
    
    static procedure VertexP2ui(&type: ErrorCode; value: UInt32);
    external 'opengl32.dll' name 'glVertexP2ui';
    
    static procedure VertexP2uiv(&type: ErrorCode; value: ^UInt32);
    external 'opengl32.dll' name 'glVertexP2uiv';
    
    static procedure VertexP3ui(&type: ErrorCode; value: UInt32);
    external 'opengl32.dll' name 'glVertexP3ui';
    
    static procedure VertexP3uiv(&type: ErrorCode; value: ^UInt32);
    external 'opengl32.dll' name 'glVertexP3uiv';
    
    static procedure VertexP4ui(&type: ErrorCode; value: UInt32);
    external 'opengl32.dll' name 'glVertexP4ui';
    
    static procedure VertexP4uiv(&type: ErrorCode; value: ^UInt32);
    external 'opengl32.dll' name 'glVertexP4uiv';
    
    static procedure TexCoordP1ui(&type: ErrorCode; coords: UInt32);
    external 'opengl32.dll' name 'glTexCoordP1ui';
    
    static procedure TexCoordP1uiv(&type: ErrorCode; coords: ^UInt32);
    external 'opengl32.dll' name 'glTexCoordP1uiv';
    
    static procedure TexCoordP2ui(&type: ErrorCode; coords: UInt32);
    external 'opengl32.dll' name 'glTexCoordP2ui';
    
    static procedure TexCoordP2uiv(&type: ErrorCode; coords: ^UInt32);
    external 'opengl32.dll' name 'glTexCoordP2uiv';
    
    static procedure TexCoordP3ui(&type: ErrorCode; coords: UInt32);
    external 'opengl32.dll' name 'glTexCoordP3ui';
    
    static procedure TexCoordP3uiv(&type: ErrorCode; coords: ^UInt32);
    external 'opengl32.dll' name 'glTexCoordP3uiv';
    
    static procedure TexCoordP4ui(&type: ErrorCode; coords: UInt32);
    external 'opengl32.dll' name 'glTexCoordP4ui';
    
    static procedure TexCoordP4uiv(&type: ErrorCode; coords: ^UInt32);
    external 'opengl32.dll' name 'glTexCoordP4uiv';
    
    static procedure MultiTexCoordP1ui(texture: ErrorCode; &type: ErrorCode; coords: UInt32);
    external 'opengl32.dll' name 'glMultiTexCoordP1ui';
    
    static procedure MultiTexCoordP1uiv(texture: ErrorCode; &type: ErrorCode; coords: ^UInt32);
    external 'opengl32.dll' name 'glMultiTexCoordP1uiv';
    
    static procedure MultiTexCoordP2ui(texture: ErrorCode; &type: ErrorCode; coords: UInt32);
    external 'opengl32.dll' name 'glMultiTexCoordP2ui';
    
    static procedure MultiTexCoordP2uiv(texture: ErrorCode; &type: ErrorCode; coords: ^UInt32);
    external 'opengl32.dll' name 'glMultiTexCoordP2uiv';
    
    static procedure MultiTexCoordP3ui(texture: ErrorCode; &type: ErrorCode; coords: UInt32);
    external 'opengl32.dll' name 'glMultiTexCoordP3ui';
    
    static procedure MultiTexCoordP3uiv(texture: ErrorCode; &type: ErrorCode; coords: ^UInt32);
    external 'opengl32.dll' name 'glMultiTexCoordP3uiv';
    
    static procedure MultiTexCoordP4ui(texture: ErrorCode; &type: ErrorCode; coords: UInt32);
    external 'opengl32.dll' name 'glMultiTexCoordP4ui';
    
    static procedure MultiTexCoordP4uiv(texture: ErrorCode; &type: ErrorCode; coords: ^UInt32);
    external 'opengl32.dll' name 'glMultiTexCoordP4uiv';
    
    static procedure NormalP3ui(&type: ErrorCode; coords: UInt32);
    external 'opengl32.dll' name 'glNormalP3ui';
    
    static procedure NormalP3uiv(&type: ErrorCode; coords: ^UInt32);
    external 'opengl32.dll' name 'glNormalP3uiv';
    
    static procedure ColorP3ui(&type: ErrorCode; color: UInt32);
    external 'opengl32.dll' name 'glColorP3ui';
    
    static procedure ColorP3uiv(&type: ErrorCode; color: ^UInt32);
    external 'opengl32.dll' name 'glColorP3uiv';
    
    static procedure ColorP4ui(&type: ErrorCode; color: UInt32);
    external 'opengl32.dll' name 'glColorP4ui';
    
    static procedure ColorP4uiv(&type: ErrorCode; color: ^UInt32);
    external 'opengl32.dll' name 'glColorP4uiv';
    
    static procedure SecondaryColorP3ui(&type: ErrorCode; color: UInt32);
    external 'opengl32.dll' name 'glSecondaryColorP3ui';
    
    static procedure SecondaryColorP3uiv(&type: ErrorCode; color: ^UInt32);
    external 'opengl32.dll' name 'glSecondaryColorP3uiv';
    
    static procedure GetnMapdv(target: ErrorCode; query: ErrorCode; bufSize: Int32; v: ^double);
    external 'opengl32.dll' name 'glGetnMapdv';
    
    static procedure GetnMapfv(target: ErrorCode; query: ErrorCode; bufSize: Int32; v: ^single);
    external 'opengl32.dll' name 'glGetnMapfv';
    
    static procedure GetnMapiv(target: ErrorCode; query: ErrorCode; bufSize: Int32; v: ^Int32);
    external 'opengl32.dll' name 'glGetnMapiv';
    
    static procedure GetnPixelMapfv(map: ErrorCode; bufSize: Int32; values: ^single);
    external 'opengl32.dll' name 'glGetnPixelMapfv';
    
    static procedure GetnPixelMapuiv(map: ErrorCode; bufSize: Int32; values: ^UInt32);
    external 'opengl32.dll' name 'glGetnPixelMapuiv';
    
    static procedure GetnPixelMapusv(map: ErrorCode; bufSize: Int32; values: ^UInt16);
    external 'opengl32.dll' name 'glGetnPixelMapusv';
    
    static procedure GetnPolygonStipple(bufSize: Int32; pattern: ^Byte);
    external 'opengl32.dll' name 'glGetnPolygonStipple';
    
    static procedure GetnColorTable(target: ErrorCode; format: ErrorCode; &type: ErrorCode; bufSize: Int32; table: pointer);
    external 'opengl32.dll' name 'glGetnColorTable';
    
    static procedure GetnConvolutionFilter(target: ErrorCode; format: ErrorCode; &type: ErrorCode; bufSize: Int32; image: pointer);
    external 'opengl32.dll' name 'glGetnConvolutionFilter';
    
    static procedure GetnSeparableFilter(target: ErrorCode; format: ErrorCode; &type: ErrorCode; rowBufSize: Int32; row: pointer; columnBufSize: Int32; column: pointer; span: pointer);
    external 'opengl32.dll' name 'glGetnSeparableFilter';
    
    static procedure GetnHistogram(target: ErrorCode; reset: Byte; format: ErrorCode; &type: ErrorCode; bufSize: Int32; values: pointer);
    external 'opengl32.dll' name 'glGetnHistogram';
    
    static procedure GetnMinmax(target: ErrorCode; reset: Byte; format: ErrorCode; &type: ErrorCode; bufSize: Int32; values: pointer);
    external 'opengl32.dll' name 'glGetnMinmax';
    
    static procedure ColorTable(target: ErrorCode; internalformat: ErrorCode; width: Int32; format: ErrorCode; &type: ErrorCode; table: pointer);
    external 'opengl32.dll' name 'glColorTable';
    
    static procedure ColorTableParameterfv(target: ErrorCode; pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glColorTableParameterfv';
    
    static procedure ColorTableParameteriv(target: ErrorCode; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glColorTableParameteriv';
    
    static procedure CopyColorTable(target: ErrorCode; internalformat: ErrorCode; x: Int32; y: Int32; width: Int32);
    external 'opengl32.dll' name 'glCopyColorTable';
    
    static procedure GetColorTable(target: ErrorCode; format: ErrorCode; &type: ErrorCode; table: pointer);
    external 'opengl32.dll' name 'glGetColorTable';
    
    static procedure GetColorTableParameterfv(target: ErrorCode; pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glGetColorTableParameterfv';
    
    static procedure GetColorTableParameteriv(target: ErrorCode; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetColorTableParameteriv';
    
    static procedure ColorSubTable(target: ErrorCode; start: Int32; count: Int32; format: ErrorCode; &type: ErrorCode; data: pointer);
    external 'opengl32.dll' name 'glColorSubTable';
    
    static procedure CopyColorSubTable(target: ErrorCode; start: Int32; x: Int32; y: Int32; width: Int32);
    external 'opengl32.dll' name 'glCopyColorSubTable';
    
    static procedure ConvolutionFilter1D(target: ErrorCode; internalformat: ErrorCode; width: Int32; format: ErrorCode; &type: ErrorCode; image: pointer);
    external 'opengl32.dll' name 'glConvolutionFilter1D';
    
    static procedure ConvolutionFilter2D(target: ErrorCode; internalformat: ErrorCode; width: Int32; height: Int32; format: ErrorCode; &type: ErrorCode; image: pointer);
    external 'opengl32.dll' name 'glConvolutionFilter2D';
    
    static procedure ConvolutionParameterf(target: ErrorCode; pname: ErrorCode; &params: single);
    external 'opengl32.dll' name 'glConvolutionParameterf';
    
    static procedure ConvolutionParameterfv(target: ErrorCode; pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glConvolutionParameterfv';
    
    static procedure ConvolutionParameteri(target: ErrorCode; pname: ErrorCode; &params: Int32);
    external 'opengl32.dll' name 'glConvolutionParameteri';
    
    static procedure ConvolutionParameteriv(target: ErrorCode; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glConvolutionParameteriv';
    
    static procedure CopyConvolutionFilter1D(target: ErrorCode; internalformat: ErrorCode; x: Int32; y: Int32; width: Int32);
    external 'opengl32.dll' name 'glCopyConvolutionFilter1D';
    
    static procedure CopyConvolutionFilter2D(target: ErrorCode; internalformat: ErrorCode; x: Int32; y: Int32; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glCopyConvolutionFilter2D';
    
    static procedure GetConvolutionFilter(target: ErrorCode; format: ErrorCode; &type: ErrorCode; image: pointer);
    external 'opengl32.dll' name 'glGetConvolutionFilter';
    
    static procedure GetConvolutionParameterfv(target: ErrorCode; pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glGetConvolutionParameterfv';
    
    static procedure GetConvolutionParameteriv(target: ErrorCode; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetConvolutionParameteriv';
    
    static procedure GetSeparableFilter(target: ErrorCode; format: ErrorCode; &type: ErrorCode; row: pointer; column: pointer; span: pointer);
    external 'opengl32.dll' name 'glGetSeparableFilter';
    
    static procedure SeparableFilter2D(target: ErrorCode; internalformat: ErrorCode; width: Int32; height: Int32; format: ErrorCode; &type: ErrorCode; row: pointer; column: pointer);
    external 'opengl32.dll' name 'glSeparableFilter2D';
    
    static procedure GetHistogram(target: ErrorCode; reset: Byte; format: ErrorCode; &type: ErrorCode; values: pointer);
    external 'opengl32.dll' name 'glGetHistogram';
    
    static procedure GetHistogramParameterfv(target: ErrorCode; pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glGetHistogramParameterfv';
    
    static procedure GetHistogramParameteriv(target: ErrorCode; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetHistogramParameteriv';
    
    static procedure GetMinmax(target: ErrorCode; reset: Byte; format: ErrorCode; &type: ErrorCode; values: pointer);
    external 'opengl32.dll' name 'glGetMinmax';
    
    static procedure GetMinmaxParameterfv(target: ErrorCode; pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glGetMinmaxParameterfv';
    
    static procedure GetMinmaxParameteriv(target: ErrorCode; pname: ErrorCode; &params: ^Int32);
    external 'opengl32.dll' name 'glGetMinmaxParameteriv';
    
    static procedure Histogram(target: ErrorCode; width: Int32; internalformat: ErrorCode; sink: Byte);
    external 'opengl32.dll' name 'glHistogram';
    
    static procedure Minmax(target: ErrorCode; internalformat: ErrorCode; sink: Byte);
    external 'opengl32.dll' name 'glMinmax';
    
    static procedure ResetHistogram(target: ErrorCode);
    external 'opengl32.dll' name 'glResetHistogram';
    
    static procedure ResetMinmax(target: ErrorCode);
    external 'opengl32.dll' name 'glResetMinmax';
    
    static procedure GetPixelMapxv(map: ErrorCode; size: Int32; values: ^fixed);
    external 'opengl32.dll' name 'glGetPixelMapxv';
    
    static procedure PixelMapx(map: ErrorCode; size: Int32; values: ^fixed);
    external 'opengl32.dll' name 'glPixelMapx';
    
    static procedure PixelStorex(pname: ErrorCode; param: fixed);
    external 'opengl32.dll' name 'glPixelStorex';
    
    static procedure TbufferMask3DFX(mask: UInt32);
    external 'opengl32.dll' name 'glTbufferMask3DFX';
    
    static procedure AlphaFuncx(func: ErrorCode; ref: Int32);
    external 'opengl32.dll' name 'glAlphaFuncx';
    
    static procedure ClearColorx(red: Int32; green: Int32; blue: Int32; alpha: Int32);
    external 'opengl32.dll' name 'glClearColorx';
    
    static procedure ClearDepthx(depth: Int32);
    external 'opengl32.dll' name 'glClearDepthx';
    
    static procedure Color4x(red: fixed; green: fixed; blue: fixed; alpha: fixed);
    external 'opengl32.dll' name 'glColor4x';
    
    static procedure DepthRangex(zNear: Int32; zFar: Int32);
    external 'opengl32.dll' name 'glDepthRangex';
    
    static procedure Fogf(pname: ErrorCode; param: single);
    external 'opengl32.dll' name 'glFogf';
    
    static procedure Fogfv(pname: ErrorCode; &params: ^single);
    external 'opengl32.dll' name 'glFogfv';
    
    static procedure Fogx(pname: ErrorCode; param: fixed);
    external 'opengl32.dll' name 'glFogx';
    
    static procedure Fogxv(pname: ErrorCode; &params: ^fixed);
    external 'opengl32.dll' name 'glFogxv';
    
    static procedure Frustumx(left: fixed; right: fixed; bottom: fixed; top: fixed; zNear: fixed; zFar: fixed);
    external 'opengl32.dll' name 'glFrustumx';
    
    static procedure LightModelf(pname: ErrorCode; param: single);
    external 'opengl32.dll' name 'glLightModelf';
    
    static procedure LightModelx(pname: ErrorCode; param: fixed);
    external 'opengl32.dll' name 'glLightModelx';
    
    static procedure LightModelxv(pname: ErrorCode; &params: ^fixed);
    external 'opengl32.dll' name 'glLightModelxv';
    
    static procedure Lightf(light: ErrorCode; pname: ErrorCode; param: single);
    external 'opengl32.dll' name 'glLightf';
    
    static procedure Lightx(light: ErrorCode; pname: ErrorCode; param: fixed);
    external 'opengl32.dll' name 'glLightx';
    
    static procedure Lightxv(light: ErrorCode; pname: ErrorCode; &params: ^fixed);
    external 'opengl32.dll' name 'glLightxv';
    
    static procedure LineWidthx(width: fixed);
    external 'opengl32.dll' name 'glLineWidthx';
    
    static procedure LoadMatrixx(m: ^fixed);
    external 'opengl32.dll' name 'glLoadMatrixx';
    
    static procedure Materialx(face: ErrorCode; pname: ErrorCode; param: fixed);
    external 'opengl32.dll' name 'glMaterialx';
    
    static procedure Materialxv(face: ErrorCode; pname: ErrorCode; &params: ^fixed);
    external 'opengl32.dll' name 'glMaterialxv';
    
    static procedure MultMatrixx(m: ^fixed);
    external 'opengl32.dll' name 'glMultMatrixx';
    
    static procedure MultiTexCoord4x(target: ErrorCode; s: fixed; t: fixed; r: fixed; q: fixed);
    external 'opengl32.dll' name 'glMultiTexCoord4x';
    
    static procedure Normal3x(nx: fixed; ny: fixed; nz: fixed);
    external 'opengl32.dll' name 'glNormal3x';
    
    static procedure Orthox(left: fixed; right: fixed; bottom: fixed; top: fixed; zNear: fixed; zFar: fixed);
    external 'opengl32.dll' name 'glOrthox';
    
    static procedure PointSizex(size: fixed);
    external 'opengl32.dll' name 'glPointSizex';
    
    static procedure PolygonOffsetx(factor: fixed; units: fixed);
    external 'opengl32.dll' name 'glPolygonOffsetx';
    
    static procedure Rotatex(angle: fixed; x: fixed; y: fixed; z: fixed);
    external 'opengl32.dll' name 'glRotatex';
    
    static procedure SampleCoveragex(value: Int32; invert: Byte);
    external 'opengl32.dll' name 'glSampleCoveragex';
    
    static procedure Scalex(x: fixed; y: fixed; z: fixed);
    external 'opengl32.dll' name 'glScalex';
    
    static procedure TexEnvf(target: ErrorCode; pname: ErrorCode; param: single);
    external 'opengl32.dll' name 'glTexEnvf';
    
    static procedure TexEnvx(target: ErrorCode; pname: ErrorCode; param: fixed);
    external 'opengl32.dll' name 'glTexEnvx';
    
    static procedure TexEnvxv(target: ErrorCode; pname: ErrorCode; &params: ^fixed);
    external 'opengl32.dll' name 'glTexEnvxv';
    
    static procedure TexParameterx(target: ErrorCode; pname: ErrorCode; param: fixed);
    external 'opengl32.dll' name 'glTexParameterx';
    
    static procedure Translatex(x: fixed; y: fixed; z: fixed);
    external 'opengl32.dll' name 'glTranslatex';
    
    {$endregion unsorted}
    
  end;
  
end.